<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/font-awesome.min.css">

    <link href="http://xion.io/style.css" rel="stylesheet">




  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

    <meta name="author" content="Karol Kuczmarski" />
    <meta name="description" content="" />
<meta property="og:site_name" content="Karol Kuczmarski's Blog"/>
<meta property="og:type" content="blog"/>
<meta property="og:title" content="Karol Kuczmarski's Blog"/>
<meta property="og:description" content=""/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://xion.io"/>
<meta property="og:image" content="http://xion.io/logo.jpeg">

  <title>Karol Kuczmarski's Blog &ndash; Tag: streams</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://xion.io">
        <img src="http://xion.io/logo.jpeg" alt="Karol Kuczmarski" title="Karol Kuczmarski">
      </a>
      <h1><a href="http://xion.io">Karol Kuczmarski</a></h1>
      <p>fn(Tea) -> Code</p>
      <nav>
        <ul class="list">
          <li><a href="http://xion.io/page/about.html#about">About</a></li>
          <li><a href="http://xion.io/page/projects.html#projects">Projects</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-github" href="http://github.com/Xion" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-stack-overflow" href="http://stackoverflow.com/users/434799/xion" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
        <li><a class="sc-twitter" href="http://twitter.com/Xion__" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-google" href="https://plus.google.com/+KarolKuczmarski" target="_blank"><i class="fa fa-google"></i></a></li>
        <li><a class="sc-rss" href="/feeds/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="http://xion.io">Home</a>
      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>
      <a href="http://xion.org.pl/">Old blog</a>
    </nav>

<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-unfold-pagination.html#rust-unfold-pagination">Unfolding a Stream of paginated&nbsp;items</a></h2>
    <p>
      Posted on Wed 24 January 2018 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/tokio.html">Tokio</a>,      <a href="http://xion.io/tag/streams.html">streams</a>,      <a href="http://xion.io/tag/http.html">HTTP</a>      &#8226; <a href="http://xion.io/post/code/rust-unfold-pagination.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>My <a href="https://github.com/Xion/ezomyte">most recent Rust crate</a>
is an <span class="caps">API</span> client for <a href="https://www.pathofexile.com/developer/docs/api-resource-public-stash-tabs">the Path of Exile&#8217;s public stash tabs</a>.
One problem that I had to solve while writing it was to turn a sequence of <em>paginated</em> items
(in this case, player stash tabs) into a single, asynchronous <code>Stream</code>.</p>
<p>In this post, I&#8217;ll explain how to use
<a href="https://docs.rs/futures/0.1.17/futures/stream/trait.Stream.html">the <code>Stream</code> interface</a>,
along with functions from <a href="https://docs.rs/futures">the <code>futures</code> crate</a>,
to create a single <code>Stream</code> from multiple batches of&nbsp;entities.</p>
<h4>Pagination&nbsp;101</h4>
<p>To divide a long list of items into <em>pages</em>
is a very common pattern in many <span class="caps">HTTP</span>-based&nbsp;APIs.</p>
<p>If the client requests a sequence of entities
that would be too large to serve as a single response,
there has to be some way to split it over multiple <span class="caps">HTTP</span> roundtrips.
To accomplish that, <span class="caps">API</span> servers will often return a constant number of items at first (like 50),
followed by some form of <em>continuation token</em>:</p>
<div class="highlight"><pre>$ curl http://api.example.com/items
{
    &quot;items&quot;: [
        {...},
        {...},
        {...}
    ],
    &quot;continuationToken&quot;: &quot;e53c68db0ee412ac239173db147a02a0&quot;
}
</pre></div>


<p>Such token is preferably an opaque sequence of bytes,
though sometimes it can be an explicit offset (index) into the list of results<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>.
Regardless of its exact nature, clients need to pass the token with their next request
in order to obtain another batch of&nbsp;results:</p>
<div class="highlight"><pre>$ curl &#39;http://api.example.com/items?after=e53c68db0ee412ac239173db147a02a0&#39;
{
    &quot;items&quot;: [
        {...},
        {...}
    ],
    &quot;continuationToken&quot;: &quot;4e3986e4c7f591b8cb17cf14addd40a6&quot;
}
</pre></div>


<p>Repeat this procedure for as long as the response contains a continuation token,
and you will eventually go through the entire sequence.
If it&#8217;s really, <em>really</em> long (e.g. it&#8217;s a Twitter firehose for a popular hashtag),
then you may of course hit some problems due to the sheer number of requests.
For many datasets, however, this pagination scheme is absolutely sufficient
while remaining relatively simple for clients to&nbsp;implement.</p>
<h4>Stream it in&nbsp;Rust</h4>
<p>What the client code would typically do, however,
is to hide the pagination details completely
and present only the final, unified sequence of items.
Such abstraction is useful even for end-user applications,
but it&#8217;s definitely expected from any shared library that wraps the third-party <span class="caps">API</span>.</p>
<p>Depending on your programming language of choice,
this abstraction layer may be very simple to implement.
Here&#8217;s how it could be done in Python,
whose concepts of <em>iterables</em> and <em>generators</em> are a perfect fit for this task<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">requests</span>

<span class="k">def</span> <span class="nf">iter_items</span><span class="p">(</span><span class="n">after</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Yield items from an example API.</span>
<span class="sd">    :param after: Optional continuation token</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">url</span> <span class="o">=</span> <span class="s">&quot;http://api.example.com/items&quot;</span>
        <span class="k">if</span> <span class="n">after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">url</span> <span class="o">+=</span> <span class="s">&quot;?after=</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">after</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()[</span><span class="s">&#39;items&#39;</span><span class="p">]:</span>
            <span class="k">yield</span> <span class="n">item</span>
        <span class="n">after</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;continuationToken&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">after</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">break</span>

<span class="c"># consumer</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">iter_items</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</pre></div>


<p>In Rust, you can find their analogues in the <code>Iterator</code> and <code>Stream</code> traits,
so we&#8217;re off to a pretty good start.
What&#8217;s missing, however, is the equivalent of <code>yield</code>:
something to tell the consumer &#8220;Here, have the next item!&#8221;,
and then <em>go back</em> to the exact same place in the producer&nbsp;function.</p>
<p>This ability to jump back and forth between two (or more) functions
involves having a language support for <em>coroutines</em>.
Not many mainstream languages pass this requirement,
although Python and C# would readily come to mind.
In case of Rust, there have been some nightly
<a href="https://github.com/rust-lang/rfcs/blob/master/text/2033-experimental-coroutines.md">proposals</a>
and <a href="https://docs.rs/futures-await">experiments</a>,
but nothing seems to be stabilizing anytime&nbsp;soon.</p>
<h4><span class="caps">DIY</span>&nbsp;streaming</h4>
<p>But of course, if you do want a <code>Stream</code> of paginated items,
there is at least one straightforward solution:
just implement the <code>Stream</code> trait&nbsp;directly.</p>
<p>This is actually quite a viable approach, very similar to rolling out a custom <code>Iterator</code>.
Some minor differences stem mostly from a more complicated state management in <code>Stream::poll</code>
compared to <code>Iterator::next</code>.
While an iterator is either exhausted or not,
a stream can also be <a href="https://docs.rs/futures/0.1.17/futures/enum.Async.html">waiting</a>
for the next item to &#8220;arrive&#8221; (<code>Ok(Async::NotReady)</code>),
or have errored out permanently (<code>Err(e)</code>).
As a consequence, the return value of <code>Stream::poll</code> is
<a href="https://docs.rs/futures/0.1.17/futures/type.Poll.html">slightly more complex</a>
than just plain <code>Option</code>, but nevertheless quite&nbsp;manageable.</p>
<p>Irrespective of difficulty,
writing a custom <code>Stream</code> from scratch would inevitably involve a lot of boilerplate.
You may find it necessary in more complicated applications, of course,
but for something that&#8217;s basically a glorified <code>while</code> loop,
it doesn&#8217;t seem like a big ask to have a more concise&nbsp;solution.</p>
<h4>The stream&nbsp;unfolds</h4>
<p>Fortunately there is one!
Its crucial element is the standalone
<a href="https://docs.rs/futures/0.1.17/futures/stream/fn.unfold.html"><code>stream::unfold</code> function</a>
from the <code>futures</code> crate.</p>
<p>Reading through the signature of this function can be a little intimidating at first.
Part of it is Rust&#8217;s verbose syntax for anything
that involves both trait bounds and closures<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>,
making <code>stream::unfold</code> seem more complicated than it actually is.
Indeed, if you&#8217;ve ever used <code>Iterator</code> adapters like <code>.filter_map</code> or <code>.fold</code>,
the <code>unfold</code> function will be pretty easy to understand.
(And if you haven&#8217;t, don&#8217;t worry! It&#8217;s really quite simple&nbsp;:))</p>
<p>If you look closely, you&#8217;ll see that <code>stream::unfold</code> takes the following two&nbsp;arguments:</p>
<ul>
<li>first one is essentially an arbitrary initial value, called a <em>seed</em></li>
<li>second one is a <em>closure</em> that receives the seed and returns an optional <em>pair</em> of&nbsp;values</li>
</ul>
<p>What are those values?&#8230;
Well, the entire purpose of the <code>unfold</code> function is to create a <code>Stream</code>,
and a stream should inevitably produce some <em>items</em>.
Consequently, the first value in the returned pair will be the next item in the&nbsp;stream.</p>
<p>And what about the second value? That&#8217;s just the <em>next state</em> of the seed!
It will be received by the very same closure
when someone asks the <code>Stream</code> to produce its next item.
By passing around a useful value &#8212; say, a continuation token &#8212;
you can create something that&#8217;s effectively a <code>while</code> loop from the Python example&nbsp;above.</p>
<p><div class="graphviz" style="text-align: center;"><img src="data:image/png;base64,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xjpKL774YpyUjAorASo0YW05yk0CJEACJJA2ARgJY68xjNJgg1pspOzWk0o7M54QKAJUaALVHBSGBEiABEgg3wRgGAy7mnHjxukWFNgLjxuq5pt6/vOnQpN/xiyBBEiABEgggASwCjz2pqotq3HDDV4WVQyglBTJLwEqNH5JMR0JkAAJkEDREahevbqRleXVrRvbT/To0cN4t+wpugoXcYWo0BRx47JqJEACJEACqQlg7yjsJYW9oLBP1JFHHqn7uKU+kymCRIAKTZBag7KQAAmQAAkUjECHDh3M7NmzdZNjbHaJncwZwkOACk142oqSkgAJkAAJ5JkAdpDHTvNYWV42WTVTpkzJc4nMPlcEqNDkiiTzIQESIAESKAoC2DcKdjXHHXecLsZHY+FwNGuZ2vogHE1CKUmABEiABApNABvFPv300wab18JYeNmyZZGNiwstG8uPT4AKTXwujCUBEiABEijjBLBtwqBBg3RH9J49e5r169ebgQMHlnEqwa0+FZrgtg0lIwESIAESCACBCy+80FSpUsWcc8455vfff9cNLgMgFkWIIRBXoVmyZAl3I40BFeSfc+bMMS1btgyyiCllO/XUUw3ehhjKJoG5c+fq0H5Ya491S2A8yl2c/bXgTz/95C9hgFJ16dLFYBrqjDPOMBs2bDD33Xcf71kBah+IUkKh2WeffUyLFi0CJibFSUYAlviNGzdOliSwx3bZZRfTsWPHwMpHwUqHwIEHHmgaNWpUOoXluJS1a9fqarOFXozts88+M3///bfZc889c1zD3GfXtm1b06BBg9xnnOccO3XqZDbffHNVXNHe2OySL2J5hp5G9ptYCWmkZ1ISIAESIAEPgX79+umS+W+//bapU6eO50jpfsUoLQxYsUcRQ34JvPLKK7qx5fnnn2/uvvvu/BbG3H0ToNu2b1RMSAIkQAIlCdx4443m3XffLagyA6mwCFxYR7lKUg12DNy54QGFaadrrrkm2MKWIelKTDmVobqzqiRAAiSQNYEKFSro5oZZZ5RFBr/88otZsWKFadiwYRa58NR0CJx88sk65QRD4a222sr07ds3ndOZNg8EqNDkASqzJAESIIHSJOCW6OcITWlSN7o+DWyoLr74YlVqunfvXroCsLQoAlRoonDwBwmQAAmEjwAUGqxuu9NOO4VP+JBL3Lt3b7N69WrdpXvnnXc2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"></div></p>
<p>The last important bits about this pair of values is the&nbsp;wrapping.</p>
<p>First, it is actually a <code>Future</code>, allowing your stream to yield objects
that it doesn&#8217;t quite have yet &#8212;
for example, those which ultimately come from an <span class="caps">HTTP</span>&nbsp;response.</p>
<p>Secondly, its outermost layer is an <code>Option</code>.
This enables you to <em>terminate</em> the stream when the underlying source is exhausted
by simply returning <code>None</code>.
Until then, however, you should return <code>Some</code> with the (future of) aforementioned pair of&nbsp;values.</p>
<h4>Paginate!&nbsp;Paginate!</h4>
<p>If you have doubts about how all those pieces of <code>stream::unfold</code> fit in,
then looking at <a href="https://docs.rs/futures/0.1.17/futures/stream/fn.unfold.html#example">the usage example in the docs</a>
may give you <em>some</em> idea of what it enables you to do.
It&#8217;s a very artificial example, though:
the resulting <code>Stream</code> isn&#8217;t waiting for any asynchronous <code>Future</code>s,
which is the very reason you&#8217;d use a <code>Stream</code> over an <code>Iterator</code> in the first place<sup id="fnref:4"><a class="footnote-ref" href="#fn:4" rel="footnote">4</a></sup>.</p>
<p>We can find a more natural application for <code>unfold</code>
if we go back to our original problem.
To reiterate, we want to repeatedly query an <span class="caps">HTTP</span> <span class="caps">API</span> for a long list of items,
giving our callers a <code>Stream</code> of such items they can process at their leisure.
At the same time, all details about pagination and handling of continuation tokens or offsets
should be completely hidden from the&nbsp;user.</p>
<p>To use <code>stream::unfold</code> for this task, we need the initial seed and an appropriate closure.
I have hinted already at using the continuation token as our seed,
or the state that we pass around from one closure invocation to another.
What remains is mostly making the actual <span class="caps">HTTP</span> request and interpreting the <span class="caps">JSON</span> response,
for which we&#8217;ll use the <em>defacto</em> standard Rust crates:
<a href="https://docs.rs/hyper"><code>hyper</code></a>, <a href="https://serde.rs">Serde</a>,
and <a href="https://docs.rs/serde_json"><code>serde_json</code></a>:</p>
<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">Error</span><span class="p">;</span><span class="w"></span>

<span class="kn">use</span><span class="w"> </span><span class="n">futures</span><span class="o">::</span><span class="p">{</span><span class="n">future</span><span class="p">,</span><span class="w"> </span><span class="n">Future</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">Stream</span><span class="p">};</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">hyper</span><span class="o">::</span><span class="p">{</span><span class="n">Client</span><span class="p">,</span><span class="w"> </span><span class="n">Method</span><span class="p">};</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">hyper</span><span class="o">::</span><span class="n">client</span><span class="o">::</span><span class="n">Request</span><span class="p">;</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">serde_json</span><span class="p">;</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">tokio_core</span><span class="o">::</span><span class="n">reactor</span><span class="o">::</span><span class="n">Handle</span><span class="p">;</span><span class="w"></span>

<span class="kr">const</span><span class="w"> </span><span class="n">URL</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;http://api.example.com/items&quot;</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">items</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">handle</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Handle</span><span class="p">,</span><span class="w"> </span><span class="n">after</span><span class="o">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Stream</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">=</span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Client</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">stream</span><span class="o">::</span><span class="n">unfold</span><span class="p">(</span><span class="n">after</span><span class="p">,</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">cont_token</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">cont_token</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}?after={}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">URL</span><span class="p">,</span><span class="w"> </span><span class="n">ct</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">req</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Request</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">Method</span><span class="o">::</span><span class="n">Get</span><span class="p">,</span><span class="w"> </span><span class="n">url</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">client</span><span class="p">.</span><span class="n">request</span><span class="p">(</span><span class="n">req</span><span class="p">).</span><span class="n">from_err</span><span class="p">().</span><span class="n">and_then</span><span class="p">(</span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">resp</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">resp</span><span class="p">.</span><span class="n">status</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="n">resp</span><span class="p">.</span><span class="n">body</span><span class="p">().</span><span class="n">concat2</span><span class="p">().</span><span class="n">from_err</span><span class="p">().</span><span class="n">and_then</span><span class="p">(</span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">body</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">status</span><span class="p">.</span><span class="n">is_success</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">serde_json</span><span class="o">::</span><span class="n">from_slice</span><span class="o">::&lt;</span><span class="n">ItemsResponse</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">body</span><span class="p">)</span><span class="w"></span>
<span class="w">                        </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="n">Box</span><span class="o">::&lt;</span><span class="n">Error</span><span class="o">&gt;::</span><span class="n">from</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="nb">Err</span><span class="p">(</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;HTTP status: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">status</span><span class="p">).</span><span class="n">into</span><span class="p">())</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">})</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">items_resp</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="n">stream</span><span class="o">::</span><span class="n">iter_ok</span><span class="p">(</span><span class="n">items_resp</span><span class="p">.</span><span class="n">items</span><span class="p">),</span><span class="w"> </span><span class="n">items_resp</span><span class="p">.</span><span class="n">continuation_token</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">})</span><span class="w"></span>
<span class="w">        </span><span class="p">}))</span><span class="w"></span>
<span class="w">    </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">flatten</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[derive(Deserialize)]</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="n">ItemsResponse</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">items</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[serde(rename = </span><span class="s">&quot;continuationToken&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="n">continuation_token</span><span class="o">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>While <a href="https://play.rust-lang.org/?gist=556ff0d112272b3c2da36c3d03aac52e&amp;version=stable">this code</a>
may be a little challenging to decipher at first,
it&#8217;s not out of line compared to how working with <code>Future</code>s and <code>Stream</code>s looks like in general.
In either case, you can expect a lot of <code>.and_then</code> callbacks&nbsp;:)</p>
<p>There is one detail here that I haven&#8217;t mentioned previously, though.
It relates to the <code>stream::iter_ok</code> and <code>Stream::flatten</code> calls
which you may have already noticed.<br>
The issue with <code>stream::unfold</code> is that it only allows to yield an item <em>once</em> per closure invocation.
For us, this is too limiting: a single batch response from the <span class="caps">API</span> will contain many such items,
but we have no way of &#8220;splitting&#8221;&nbsp;them.</p>
<p>What we can do instead is to produce a <code>Stream</code> of entire <em>batches</em> of items,
at least at first, and then <code>flatten</code> it.
What <code>Stream::flatten</code> does here is to turn a nested <code>Stream&lt;Stream&lt;Item&gt;&gt;</code>
into a flat <code>Stream&lt;Item&gt;</code>. The latter is what we eventually want to return,
so all we need now is to create this nested <em>stream of streams</em>.</p>
<p>How? Well, that&#8217;s actually pretty&nbsp;easy.</p>
<p>We can already deserialize a <code>Vec&lt;Item&gt;</code>
from the <span class="caps">JSON</span> response &#8212; that&#8217;s our item batch! &#8212;
which is essentially an <em>iterable</em> of <code>Item</code>s<sup id="fnref:5"><a class="footnote-ref" href="#fn:5" rel="footnote">5</a></sup>.
Another utility function from the <code>stream</code> module,
namely <a href="https://docs.rs/futures/*/futures/stream/fn.iter_ok.html"><code>stream::iter_ok</code></a>,
can readily turn such iterable into a &#8220;immediate&#8221; <code>Stream</code>.
Such <code>Stream</code> won&#8217;t be asynchronous at all
&#8212; its items will have been ready from the very beginning &#8212;
but it will still conform to the <code>Stream</code> interface,
enabling it to be <code>flatten</code>ed as we&nbsp;request.</p>
<h4>But wait! There is a&nbsp;bug!</h4>
<p>So in the end, is this the solution we&#8217;re looking&nbsp;for?&#8230;</p>
<p>Well, almost. First, here&#8217;s the expected usage of the function we just&nbsp;wrote:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">core</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokio_core</span><span class="o">::</span><span class="n">reactor</span><span class="o">::</span><span class="n">Core</span><span class="o">::</span><span class="n">new</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="n">core</span><span class="p">.</span><span class="n">run</span><span class="p">({</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">continuation_token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span><span class="w">  </span><span class="c1">// start from the beginning</span>
<span class="w">    </span><span class="n">items</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core</span><span class="p">.</span><span class="n">handle</span><span class="p">(),</span><span class="w"> </span><span class="n">continuation_token</span><span class="p">).</span><span class="n">for_each</span><span class="p">(</span><span class="o">|</span><span class="n">item</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="w">    </span><span class="p">})</span><span class="w"></span>
<span class="p">}).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
</pre></div>


<p>While this is more complicated than the plain <code>for</code> loop in Python,
most of it is just Tokio boilerplate.
The notable part is the invocation of <code>items()</code>,
where we pass <code>None</code> as a continuation token to indicate that
we want the entire sequence, right from its&nbsp;beginning.</p>
<p>And since we&#8217;re talking about fetching long sequences,
we would indeed expect a <em>lot</em> of items.
So it is probably quite surprising to hear
that the stream we&#8217;ve created here will be completely <em>empty</em>.</p>
<p>&#8230;What?&nbsp;How?!</p>
<p>If you look again at the source code of <code>items()</code>,
the direct reason should be pretty easy to find.
The culprit lies in the <code>return None</code> branch of the first <code>match</code>.
If we don&#8217;t pass <code>Some(continuation_token)</code> as a parameter to <code>items()</code>,
this branch will be hit <em>immediately</em>,
terminating the stream before it had a chance to produce&nbsp;anything.</p>
<p>It may not be very clear how to fix this problem.
After all, the purpose of the <code>match</code> was to detect the <em>end</em> of the sequence,
but it apparently prevents us from <em>starting</em> it in the first&nbsp;place!</p>
<p>Looking at the problem from another angle,
we can see we&#8217;ve conflated two distinct states of our stream
&#8212; &#8220;before it has started&#8221; and &#8220;after it&#8217;s ended&#8221; &#8212; into a single one (&#8220;no continuation token&#8221;).
Since we obviously don&#8217;t want to make the <code>after</code> parameter mandatory
&#8212; users should be able to say &#8220;Give me everything!&#8221; &#8212;
we need another way of telling those two states&nbsp;apart.</p>
<p>In terms of Rust types, it seems that <code>Option&lt;String&gt;</code> is no longer sufficient
for encoding all possible states of our <code>Stream</code>.
Although we could try to fix that in some ad-hoc way (e.g. by adding another <code>bool</code> flag),
it feels cleaner to just define a new, dedicated type.
For one, this allows us to designate a name for each of the states in question,
improving the readability and maintainability of our&nbsp;code:</p>
<div class="highlight"><pre><span class="k">enum</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Start</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">Next</span><span class="p">(</span><span class="n">String</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">End</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Note that we can put this definition directly inside the <code>items()</code> function,
without cluttering the module namespace.
All the relevant details of our <code>Stream</code> are thus nicely contained
<a href="https://play.rust-lang.org/?gist=42af60531f18509e181c4e30a46eb077&amp;version=stable">within a single function</a>:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">items</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">handle</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Handle</span><span class="p">,</span><span class="w"> </span><span class="n">after</span><span class="o">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Stream</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">=</span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// (definition of State enum can go here)</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Client</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">stream</span><span class="o">::</span><span class="n">unfold</span><span class="p">(</span><span class="n">State</span><span class="o">::</span><span class="n">Start</span><span class="p">(</span><span class="n">after</span><span class="p">),</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">state</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">cont_token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">State</span><span class="o">::</span><span class="n">Start</span><span class="p">(</span><span class="n">opt_ct</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">opt_ct</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">State</span><span class="o">::</span><span class="n">Next</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">ct</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="n">State</span><span class="o">::</span><span class="n">End</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">cont_token</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}?after={}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">URL</span><span class="p">,</span><span class="w"> </span><span class="n">ct</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">URL</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">req</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Request</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">Method</span><span class="o">::</span><span class="n">Get</span><span class="p">,</span><span class="w"> </span><span class="n">url</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">client</span><span class="p">.</span><span class="n">request</span><span class="p">(</span><span class="n">req</span><span class="p">).</span><span class="n">from_err</span><span class="p">().</span><span class="n">and_then</span><span class="p">(</span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">resp</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">resp</span><span class="p">.</span><span class="n">status</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="n">resp</span><span class="p">.</span><span class="n">body</span><span class="p">().</span><span class="n">concat2</span><span class="p">().</span><span class="n">from_err</span><span class="p">().</span><span class="n">and_then</span><span class="p">(</span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">body</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">status</span><span class="p">.</span><span class="n">is_success</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">serde_json</span><span class="o">::</span><span class="n">from_slice</span><span class="o">::&lt;</span><span class="n">ItemsResponse</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">body</span><span class="p">)</span><span class="w"></span>
<span class="w">                        </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="n">Box</span><span class="o">::&lt;</span><span class="n">Error</span><span class="o">&gt;::</span><span class="n">from</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="nb">Err</span><span class="p">(</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;HTTP status: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">status</span><span class="p">).</span><span class="n">into</span><span class="p">())</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">})</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">items_resp</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">next_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">items_resp</span><span class="p">.</span><span class="n">continuation_token</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="nb">Some</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">State</span><span class="o">::</span><span class="n">Next</span><span class="p">(</span><span class="n">ct</span><span class="p">),</span><span class="w"></span>
<span class="w">                    </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">State</span><span class="o">::</span><span class="n">End</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="p">};</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="n">stream</span><span class="o">::</span><span class="n">iter_ok</span><span class="p">(</span><span class="n">items_resp</span><span class="p">.</span><span class="n">items</span><span class="p">),</span><span class="w"> </span><span class="n">next_state</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">})</span><span class="w"></span>
<span class="w">        </span><span class="p">}))</span><span class="w"></span>
<span class="w">    </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">flatten</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Sure, there is a little more bookkeeping required now,
but at least all the items are being emitted by the <code>Stream</code> as&nbsp;intended.</p>
<hr />
<p>You can see the complete source in
<a href="https://play.rust-lang.org/?gist=42af60531f18509e181c4e30a46eb077&amp;version=stable">the playground here</a>.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Furthermore, the token doesn&#8217;t have to come as part of the <span class="caps">HTTP</span> response body.
Some <span class="caps">API</span> providers (such as GitHub) may use the <code>Link:</code> header
to point directly to the next <span class="caps">URL</span> to query.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>This example uses &#8220;traditional&#8221;, synchronous Python code.
However, it should be easy to convert it to the asynchronous equivalent
that works in Python 3.5 and above,
provided you can replace <code>requests</code> with some async <span class="caps">HTTP</span> library.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>If you are curious whether other languages could express it better,
you can check the
<a href="https://hackage.haskell.org/package/conduit-1.2.13/docs/Data-Conduit-List.html#v:unfold"><code>Data.Conduit.List.unfold</code> function</a>
from the Haskell&#8217;s <a href="https://hackage.haskell.org/package/conduit"><code>conduit</code> package</a>.
For most intents and purposes, it is their equivalent of <code>stream::unfold</code>.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>Coincidentally, you can create iterators in the very same manner
through the <a href="https://docs.rs/itertools/0.7.6/itertools/fn.unfold.html"><code>itertools::unfold</code> function</a>
from the <a href="https://docs.rs/itertools/"><code>itertools</code> crate</a>.&#160;<a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:5">
<p>In more technical Rust terms, it means <code>Vec</code> implements the <code>IntoIterator</code> trait,
allowing anyone to get an <code>Iterator</code> from it.&#160;<a class="footnote-backref" href="#fnref:5" rev="footnote" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/rust-unfold-pagination.html#rust-unfold-pagination">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-stream-terminate.html#rust-stream-terminate">Terminating a Stream in&nbsp;Rust</a></h2>
    <p>
      Posted on Sat 16 December 2017 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/streams.html">streams</a>,      <a href="http://xion.io/tag/tokio.html">Tokio</a>,      <a href="http://xion.io/tag/async.html">async</a>      &#8226; <a href="http://xion.io/post/code/rust-stream-terminate.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>Here&#8217;s a little trick that may be useful in dealing with
<a href="https://docs.rs/futures/0.1.17/futures/stream/trait.Stream.html">asynchronous <code>Stream</code>s</a> in&nbsp;Rust.</p>
<p>When you consume a <code>Stream</code> using
<a href="https://docs.rs/futures/0.1.17/futures/stream/trait.Stream.html#method.for_each">the <code>for_each</code> method</a>,
its default behavior is to finish early should an error be produced by the&nbsp;stream:</p>
<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">futures</span><span class="o">::</span><span class="n">prelude</span><span class="o">::*</span><span class="p">;</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">futures</span><span class="o">::</span><span class="n">stream</span><span class="p">;</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">tokio_core</span><span class="o">::</span><span class="n">reactor</span><span class="o">::</span><span class="n">Core</span><span class="p">;</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stream</span><span class="o">::</span><span class="n">iter_result</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="nb">Ok</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="kc">false</span><span class="p">),</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">3</span><span class="p">)]);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">fut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">for_each</span><span class="p">(</span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>
</pre></div>


<p>In more precise terms, it means that
<a href="https://docs.rs/futures/0.1.17/futures/future/trait.Future.html">the <code>Future</code></a>
returned by <code>for_each</code> will resolve with the first error
from the underlying&nbsp;stream:</p>
<div class="highlight"><pre><span class="c1">// Prints 1, 2, and then panics with &quot;false&quot;.</span>
<span class="n">Core</span><span class="o">::</span><span class="n">new</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">run</span><span class="p">(</span><span class="n">fut</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
</pre></div>


<p>For most purposes, this is perfectly alright;
errors are generally meant to propagate, after&nbsp;all.</p>
<p>Certain <em>kinds</em> of errors, however, are better off silenced.
Perhaps they are expected to pop up during normal program operation,
or maybe their occurrence should merely <em>affect</em> program execution in a particular way,
and not halt it outright.
In a simple case like above, you can of course check what <code>for_each</code> itself has returned,
but that doesn&#8217;t scale to building larger <code>Stream</code> pipelines.</p>
<p>I encountered a situation like this myself when using
<a href="https://docs.rs/crate/hubcaps/0.4.2">the <em>hubcaps</em> library</a>.
The code I was writing was meant to
<a href="https://docs.rs/hubcaps/0.4.2/hubcaps/search/struct.SearchIssues.html#method.iter">search for GitHub issues</a>
within a specific repository.
In GitHub <span class="caps">API</span>, this is accomplished by sending a search query like <code>repo:$OWNER/$NAME</code>,
which may result in a rather obscure <span class="caps">HTTP</span> error (<a href="https://httpstatuses.com/422">422 Unprocessable Entity</a>)
if the given repository doesn&#8217;t actually exist.
But I didn&#8217;t care about this error; should it occur, I&#8217;d simply return an empty stream,
because doing so was more convenient for the larger bit of logic that was consuming&nbsp;it.</p>
<p>Unfortunately, the <code>Stream</code> trait offers no interface that&#8217;d target this use case.
There are only a few methods that even allow to look at errors mid-stream,
and even fewer that can end it prematurely.
On the flip side, at least we don&#8217;t have to consider <em>too</em> many combinations
when looking for the solution&nbsp;;)</p>
<p>Indeed, it seems there are only two <code>Stream</code> methods that are worthy of our&nbsp;attention:</p>
<ul>
<li><a href="https://docs.rs/futures/0.1.17/futures/stream/trait.Stream.html#method.then"><code>Stream::then</code></a>,
  because it allows for a closure to receive all stream values (items <em>and</em>&nbsp;errors)</li>
<li><a href="https://docs.rs/futures/0.1.17/futures/stream/trait.Stream.html#method.take_while"><code>Stream::take_while</code></a>,
  because it accepts a closure that can end the stream early (but only based on items, not&nbsp;errors)</li>
</ul>
<p>Combining them both, we arrive at the following&nbsp;recipe:</p>
<ul>
<li>
<p>Inside a <code>.then</code> closure, look for <code>Err</code>ors that you consider non-fatal
  and replace them with a special item value.
  The natural choice for such a value is <code>None</code>.
  As a side effect, this forces us to convert the regular (&#8220;successful&#8221;) <code>item</code>s into <code>Some(item)</code>,
  effectively transforming a <code>Stream&lt;Item=T&gt;</code> into <code>Stream&lt;Item=Option&lt;T&gt;&gt;</code>.</p>
</li>
<li>
<p>Looks for the special value (i.e. <code>None</code>) in the <code>.take_while</code> closure
  and terminate the stream when it&#8217;s been&nbsp;found.</p>
</li>
<li>
<p>Finally, convert the wrapped items back into their original form using <code>.map</code>,
  thus giving us back a <code>Stream</code> of <code>T</code><span class="quo">&#8216;</span>s.</p>
</li>
</ul>
<p>Applying this technique to our initial example,
we get something that looks like&nbsp;this:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stream</span><span class="o">::</span><span class="n">iter_result</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="nb">Ok</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="kc">false</span><span class="p">),</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="o">|</span><span class="n">r</span><span class="o">|</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">r</span><span class="p">)),</span><span class="w">  </span><span class="c1">// no-op passthrough of items</span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span><span class="w"> </span><span class="c1">// non-fatal error, terminate the stream</span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="w">      </span><span class="c1">// no-op passthrough of other errors</span>
<span class="w">    </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">take_while</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">future</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">is_some</span><span class="p">()))</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="nb">Option</span><span class="o">::</span><span class="n">unwrap</span><span class="p">);</span><span class="w"></span>
</pre></div>


<p>If we now try to consume this stream like&nbsp;before:</p>
<div class="highlight"><pre><span class="n">Core</span><span class="o">::</span><span class="n">new</span><span class="p">().</span><span class="n">run</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">for_each</span><span class="p">(</span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
</pre></div>


<p>it will still end after the first two items,
but without producing any errors&nbsp;afterwards.</p>
<hr />
<p>For a more reusable version of the trick, you can check
<a href="https://play.rust-lang.org/?gist=1bf2199460258be6674c9c7a7a157f50&amp;version=stable">this gist</a>;
it adds a <code>Stream::take_while_err</code> method through an <a href="http://xion.io/post/code/rust-extension-traits.html">extension trait</a>.</p>
<p>This isn&#8217;t a perfect solution, however, because it requires <code>Box</code>ing even on nightly Rust<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>.
We can fix that by introducing a dedicated <code>TakeWhileErr</code> stream type,
similarly to what native <code>Stream</code> methods do.
I leave that as an exercise for the reader&nbsp;;-)</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>This is due to a limitation in <a href="https://github.com/rust-lang/rust/issues/34511">the <code>impl Trait</code> feature</a>
which prevents it from being used as a return type of trait methods.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/rust-stream-terminate.html#rust-stream-terminate">Continue reading</a>
  </div>
</article>

  <div class="pagination">
  </div>

    <footer>
<p>
  &copy; Karol Kuczmarski 2018 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-27379564-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Karol Kuczmarski's Blog ",
  "url" : "http://xion.io",
  "image": "http://xion.io/logo.jpeg",
  "description": ""
}
</script><script type="text/javascript">
    var disqus_shortname = 'xionblog';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>