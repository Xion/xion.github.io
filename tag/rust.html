<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/font-awesome.min.css">

    <link href="http://xion.io/style.css" rel="stylesheet">




  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

    <meta name="author" content="Karol Kuczmarski" />
    <meta name="description" content="" />
<meta property="og:site_name" content="Karol Kuczmarski's Blog"/>
<meta property="og:type" content="blog"/>
<meta property="og:title" content="Karol Kuczmarski's Blog"/>
<meta property="og:description" content=""/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://xion.io"/>
<meta property="og:image" content="http://xion.io/logo.jpeg">

  <title>Karol Kuczmarski's Blog &ndash; Tag: Rust</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://xion.io">
        <img src="http://xion.io/logo.jpeg" alt="Karol Kuczmarski" title="Karol Kuczmarski">
      </a>
      <h1><a href="http://xion.io">Karol Kuczmarski</a></h1>
      <p>fn(Tea) -> Code</p>
      <nav>
        <ul class="list">
          <li><a href="http://xion.io/page/about.html#about">About</a></li>
          <li><a href="http://xion.io/page/projects.html#projects">Projects</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-github" href="http://github.com/Xion" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-stack-overflow" href="http://stackoverflow.com/users/434799/xion" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
        <li><a class="sc-twitter" href="http://twitter.com/Xion__" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-google" href="https://plus.google.com/+KarolKuczmarski" target="_blank"><i class="fa fa-google"></i></a></li>
        <li><a class="sc-rss" href="/feeds/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="http://xion.io">Home</a>
      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>
      <a href="http://xion.org.pl/">Old blog</a>
    </nav>

<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-unit-test-placement.html#rust-unit-test-placement">Better location for unit tests in&nbsp;Rust</a></h2>
    <p>
      Posted on Fri 06 January 2017 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/unit-tests.html">unit tests</a>,      <a href="http://xion.io/tag/testing.html">testing</a>,      <a href="http://xion.io/tag/modules.html">modules</a>      &#8226; <a href="http://xion.io/post/code/rust-unit-test-placement.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>For a unit test to be comprehensive,
it must often access some private symbols from the module it&nbsp;checks.</p>
<p>In Rust, this is permitted for submodules:
they can freely refer to anything defined &#8220;upwards&#8221; in the module hierarchy.
The only requirement is that they import it explicitly by name,
using statements such as <code>use super::foo</code>.</p>
<p>To illustrate this,
here&#8217;s an <a href="https://is.gd/xTgUEd">example</a>
of a ridiculously well-factored <a href="http://wiki.c2.com/?FizzBuzzTest">FizzBuzz</a>
along with its accompanying unit&nbsp;test:</p>
<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">borrow</span><span class="o">::</span><span class="n">Cow</span><span class="p">;</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">fizzbuzz</span><span class="p">(</span><span class="n">n</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">1.</span><span class="p">.</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fizzbuzz_string</span><span class="p">(</span><span class="n">i</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">fizzbuzz_string</span><span class="p">(</span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Cow</span><span class="o">&lt;</span><span class="nl">&#39;static</span><span class="p">,</span><span class="w"> </span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">by3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">by5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">by3</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">by5</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;FizzBuzz&quot;</span><span class="p">.</span><span class="n">into</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">by3</span><span class="w">   </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;Fizz&quot;</span><span class="p">.</span><span class="n">into</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">by5</span><span class="w">   </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;Buzz&quot;</span><span class="p">.</span><span class="n">into</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w">          </span><span class="p">{</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">).</span><span class="n">into</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="kn">mod</span><span class="w"> </span><span class="n">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kn">use</span><span class="w"> </span><span class="n">super</span><span class="o">::</span><span class="n">fizzbuzz_string</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">single_numbers</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fizzbuzz_string</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;2&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fizzbuzz_string</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Fizz&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fizzbuzz_string</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Buzz&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fizzbuzz_string</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;7&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fizzbuzz_string</span><span class="p">(</span><span class="mi">7</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Fizz&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fizzbuzz_string</span><span class="p">(</span><span class="mi">9</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Buzz&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fizzbuzz_string</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;FizzBuzz&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fizzbuzz_string</span><span class="p">(</span><span class="mi">15</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="n">etc</span><span class="p">.</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>The internal function, as shown above, can be imported and verified independently
of the <code>pub</code>lic one.
This is done through a <code>#[test]</code> procedure in an inline&nbsp;submodule.</p>
<p>Such factorization and granular testing is commonplace,
especially when the public <span class="caps">API</span> may cause unwanted side effects,
such as printing stuff to stdout&nbsp;here.</p>
<h4>The issue of&nbsp;length</h4>
<p>But if you are like me and prefer your modules to be short and sweet,
you may feel justifiably concerned about this <em>inline</em> submodule&nbsp;business.</p>
<p>In the toy example above,
tests have already taken at least as many lines as the actual code.
Real world usually <a href="https://github.com/Geal/nom/blob/80a1deab58d1faf41c05a5d741d9e3f51bde3a55/src/nom.rs#L599">matches</a> this ratio.
A module with a couple hundred lines of regular code starts
to be measured in <a href="https://en.wikipedia.org/wiki/Source_lines_of_code#Related_terms">KLOCs</a>
if we also include its&nbsp;tests.</p>
<p>While this could be taken as a strong hint to split things up,
it can just as easily disincentivize testing&nbsp;instead.</p>
<p>The obvious solution is to move those tests somewhere else.
What is not so evident is how to preserve this crucial module-submodule relation,
enabling us to write comprehensive tests in the first&nbsp;place.</p>
<h4>Looking for&nbsp;inspiration</h4>
<p>I must quickly disappoint anyone who would like to round up all their unit tests
and sequester them in some distant <em>tests/</em> directory.
Such layout is reserved for
<a href="https://doc.rust-lang.org/book/testing.html#the-tests-directory">crate-level</a> (&#8220;integration&#8221;) tests.
Unit tests, on the other hand, are predestined to live among production code<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>.</p>
<p>So let&#8217;s at least relocate them to separate&nbsp;files.</p>
<p>To make this goal more concrete,
we will try to emulate the project layout described in
<a href="https://google.github.io/styleguide/cppguide.html#File_Names">Google&#8217;s C++ style guide</a>.
By this convention, a conceptual &#8220;module&#8221; or &#8220;unit&#8221; consists of the following&nbsp;files:</p>
<ul>
<li><em>foo.h</em></li>
<li><em>foo.cc</em></li>
<li><em>foo_test.cc</em></li>
</ul>
<p>Translating this to Rust, we&nbsp;get:</p>
<ul>
<li><em>foo.rs</em></li>
<li><em>foo_test.rs</em></li>
</ul>
<p>The first one is obviously our production code.
The second file, <em>foo_test.rs</em>,
contains all the tests we would previously put in the <code>mod tests { }</code> construct.</p>
<p>Seems pretty clean and straightforward, right?
Unfortunately, Rust will not accept this setup without some&nbsp;convincing.</p>
<h4>Family&nbsp;problems</h4>
<p>To understand why,
recall that the mere presence of some <em>.rs</em> files
is not enough for the Rust compiler to care.
If we want them picked up and included in the project,
we also need to add some <em>module declarations</em>&nbsp;first.</p>
<p>In other words, there must also be a <em>mod.rs</em> file in this directory,
containing at the very least the following&nbsp;content:</p>
<div class="highlight"><pre><span class="c1">// (mod.rs)</span>

<span class="kn">mod</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"></span>
<span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="kn">mod</span><span class="w"> </span><span class="n">foo_test</span><span class="p">;</span><span class="w"></span>
</pre></div>


<p>Now it should be clearer that something is&nbsp;wrong.</p>
<p>We got two modules here, but they are <em>siblings</em>.
Both <code>foo</code> and <code>foo_test</code> are on the same level,
children of whatever parent module contains them both.
More to the point, it&#8217;s <code>foo_test</code> that&#8217;s not a child module of <code>foo</code>,
meaning it can only see the <code>pub</code>lic symbols of the&nbsp;latter.</p>
<p>This is not quite enough to write a proper unit test.
It definitely isn&#8217;t for our initial FizzBuzz example,
because the <code>fizzbuzz_string</code> function cannot even be&nbsp;imported!</p>
<h4>Existential&nbsp;crises</h4>
<p>Okay, so how about we move the <code>mod foo_test;</code> declaration to <em>foo.rs</em>?
This should be enough to establish the proper hierarchy.
After all, this is how the module tree is
<a href="https://doc.rust-lang.org/book/crates-and-modules.html#defining-modules">normally reconstructed</a>:
from the appropriate placement of the <code>mod</code> statements.</p>
<p>So, here we&nbsp;go:</p>
<div class="highlight"><pre><span class="c1">// (foo.rs)</span>

<span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="kn">mod</span><span class="w"> </span><span class="n">foo_test</span><span class="p">;</span><span class="w"></span>
</pre></div>


<!-- -->

<div class="highlight"><pre>error: cannot declare a new module at this location
  --&gt; src/parent/foo.rs:4:5
   |
 4 | mod foo_test;
</pre></div>


<p>&#8230;Really?</p>
<p>Well, yes. A declaration like this simply isn&#8217;t allowed.
The reason for this is actually much less arbitrary than the error message would&nbsp;indicate.</p>
<p>To put it bluntly, <code>foo_test</code> simply cannot <em>exist</em> if it&#8217;s introduced there.
To deliver on its declaration promise,
the submodule would have to reside <em>within <code>foo</code> itself</em>.
But of course, <em>foo.rs</em> is just a file, so this setup is evidently&nbsp;impossible.</p>
<p>All in all, Rust seems to be looking for our module in all the wrong&nbsp;places.</p>
<p>Perhaps we can just <em>tell it</em> where it should be going&nbsp;instead?&#8230;</p>
<h4>The right&nbsp;path</h4>
<p>Enter the <code>#[path]</code> attribute,
which fulfills this exact&nbsp;purpose:</p>
<div class="highlight"><pre><span class="c1">// (foo.rs)</span>

<span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="cp">#[path = </span><span class="s">&quot;./foo_test.rs&quot;</span><span class="cp">]</span><span class="w"></span>
<span class="kn">mod</span><span class="w"> </span><span class="n">foo_test</span><span class="p">;</span><span class="w"></span>
</pre></div>


<p><code>#[path]</code> tells the Rust compiler where to look for the <code>mod</code>ule it is attached to.
Its argument is relative to the location of the outer module (like <code>foo</code> here),
and can be either a single file, or a directory with <em>mod.rs</em>.</p>
<p>Conceptually, this is similar to a custom <code>ClassLoader</code> in Java,
or the common <a href="http://xion.org.pl/2012/05/06/hacking-python-imports/"><code>sys.path</code> hacks</a> in Python.
Unlike those two languages, however,
the <code>#[path]</code> attribute is only relevant at compile&nbsp;time.</p>
<p>Additionally, and somewhat <a href="https://github.com/rust-lang/rust/issues/13156">confusingly</a>,
<code>#[path]</code> can also be applied <em>retroactively</em>
to a module that the compiler has already located.
In such case, it will affect <a href="https://doc.rust-lang.org/reference.html#modules">the lookup of any child modules</a>
by making <code>rustc</code> search for them in the new&nbsp;location.</p>
<hr />
<p>With <code>#[path]</code> handy,
it is therefore possible to implement custom layouts
of regular source modules and test&nbsp;files.</p>
<p>But like with every tool that can be used to defy conventions,
it should be used with the appropriate care.
While a straightforward and self-documenting approach described here
is unlikely to raise any eyebrows,
rewriting module paths willy-nilly is most certainly a bad&nbsp;idea.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Okay, technically it <em>is</em> possible to completely isolate them,
essentially by abusing the approach I describe later in this post.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/rust-unit-test-placement.html#rust-unit-test-placement">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/programming/rust-nightly-vs-stable.html#rust-nightly-vs-stable">A tale of two&nbsp;Rusts</a></h2>
    <p>
      Posted on Sat 24 December 2016 in <a href="http://xion.io/category/programming.html">Programming</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/nightly-rust.html">nightly Rust</a>,      <a href="http://xion.io/tag/stable-rust.html">stable Rust</a>,      <a href="http://xion.io/tag/rocketrs.html">Rocket.rs</a>      &#8226; <a href="http://xion.io/post/programming/rust-nightly-vs-stable.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>The writing has been on the wall for many months now,
but I think the time has come when we can officially declare&nbsp;it.</p>
<blockquote>
<p>Stable Rust is dead. Nightly Rust is the only&nbsp;Rust.</p>
</blockquote>
<h3>Say&nbsp;what?</h3>
<p>If you&#8217;re out of the loop,
<a href="http://rust-lang.org/">Rust</a> is this newfangled system programming language.
Rust is meant to fit in the niches normally occupied by C,
so its domain includes performance-sensitive and safety-critical applications.
Embedded programming, <span class="caps">OS</span> kernels, databases, servers,
and similar low-level pieces of computing and networking infrastructure
are all within its&nbsp;purview.</p>
<p>Of course, this &#8220;replacing C&#8221; thing is still an ambition that&#8217;s years or decades away.
But in theory, there is nothing preventing it from happening.
The main thing Rust would need here is <em>time</em>: time to buy trust of developers
by having been used in real-world, production scenarios without&nbsp;issues.</p>
<p>To facilitate this (and for other reasons),
Rust has been using <a href="https://doc.rust-lang.org/stable/book/release-channels.html">three <em>release channels</em></a>
with varying frequency of updates.
There are the <em>stable</em>, <em>beta</em>, and <em>nightly</em> Rust.
Of those, beta is pretty much an
<a href="https://en.wikipedia.org/wiki/Software_release_life_cycle#Release_candidate"><span class="caps">RC</span></a>
for a future stable release,
so there aren&#8217;t many differences at all between the first two&nbsp;channels.</p>
<h4>Nightly&nbsp;perks</h4>
<p>This cannot be said about&nbsp;nightly.</p>
<p>In fact, nightly Rust is essentially <em>its own language</em>.</p>
<p>First, there is a number of exclusive language features that are only available on nightly.
They are all guarded by numerous <code>#![feature(...)]</code> gates
which are required to activate them.
Because stable Rust doesn&#8217;t accept any such directive,
trying to compile code that uses them will fail on a non-nightly&nbsp;compiler.</p>
<p>This has been justified as a necessary step for testing out new features
in real scenarios, or at least those that resemble (stable) reality as close as possible.
Indeed, many features <em>did</em> eventually land in stable Rust by going through this route
&#8212; a recent example would be <a href="https://m4rw3r.github.io/rust-questionmark-operator">the <code>?</code> operator</a>,
an error-handling measure analogous to the <code>try!</code> macro.</p>
<p>But some features take a lot of time to stabilize.
And few (like <code>zero_one</code> which guards the numeric traits
<a href="https://doc.rust-lang.org/std/num/trait.Zero.html"><code>Zero</code></a>
and <a href="https://doc.rust-lang.org/std/num/trait.One.html"><code>One</code></a>) may even be deprecated
without ever getting out of the nightly&nbsp;channel.</p>
<h4>Unplugged</h4>
<p>Secondly, and most importantly, there is at least one feature
that won&#8217;t get stabilized <strong>ever</strong>:</p>
<div class="highlight"><pre><span class="cp">#![feature(plugin)]</span><span class="w"></span>
</pre></div>


<p>And it&#8217;s all by&nbsp;design.</p>
<p>This <code>plugin</code> switch is what&#8217;s necessary to include <code>#![plugin(...)]</code> directives.
Those in turn activate <em>compiler plugins</em>:
user-provided additions to the compiler itself.
Plugins operate against the <span class="caps">API</span> provided directly by <code>rustc</code>
and enhance its capabilities beyond what the language normally&nbsp;provides.</p>
<p>Although it sounds rather ominous,
the vast majority of plugins in the wild serve a singular purpose: <em>code generation</em>.
They are written with the sole purpose of combating Rust&#8217;s rigidity,
including the (perfectly expected) lack of dynamic runtime capabilities
and the (disappointingly) stiff limits of its wanting macro&nbsp;system.</p>
<p>This is how they are utilized by <a href="http://diesel.rs/">Diesel</a>, for example,
a popular <span class="caps">ORM</span> and <span class="caps">SQL</span> query interface;
or <a href="https://serde.rs/">Serde</a>, a serialization&nbsp;framework.</p>
<p>Why compiler plugins can never be stable, though?
It&#8217;s because the internal <span class="caps">API</span> they are coded against
goes too deep into the compiler bowels to ever get stabilized.
If it were, it would severely limit the ability to further develop the language
without significant breakage of the established&nbsp;plugins.</p>
<h4>Pseudo-stable</h4>
<p><span class="dquo">&#8220;</span>Wait,&#8221; you may ask, &#8220;how do we even talk about «established» compiler plugins?
Shouldn&#8217;t they be, by their very definition, <em>unstable</em>?&#8221;</p>
<p>Well&#8230; yes. They definitely should. And therein lies the crux of the&nbsp;problem.</p>
<p>Turns out, plugins <span class="amp">&amp;</span> nightly Rust are only <em>mostly</em> treated as&nbsp;unstable.</p>
<p>In reality, the comfort and convenience provided by nightly versions of many libraries
&#8212; all of which rely on compiler plugins &#8212; is difficult to overstate.
While their stable approximations are available, they at best require rather complicated&nbsp;setup.</p>
<p>What&#8217;s always involved is a custom build step,
and usually a separate file for the relevant code symbols and declarations.
In the end, we get a bunch of autogenerated modules
whose prior non-existence during development may also confuse IDEs and autocompletion&nbsp;tools.</p>
<p>For all those reasons and more,
an ecosystem has developed where several popular libraries are &#8220;nightly but pseudo-stable&#8221;.
This includes some key components in many serious applications,
like the aforementioned <span class="caps">ORM</span> <span class="amp">&amp;</span> serialization&nbsp;crates.</p>
<h4>The&nbsp;precedent</h4>
<p>And so has been the state of affairs until very recently.
The nightly Rust has been offering some extremely enticing features,
but the stable channel was at least paid a lip service to.
However, the mentality among library authors that &#8220;nightly-first&#8221; is an acceptable policy
had been strong for a long time&nbsp;now.</p>
<p>No wonder it has finally shifted towards&nbsp;&#8220;nightly-only&#8221;.</p>
<p>Meet <a href="http://rocket.rs">Rocket</a>,
the latest contestant in the already rich lineup of <a href="http://www.arewewebyet.org/topics/frameworks/">Rust web frameworks</a>.
Everything about it is really slick:
a flashy designer website; approachable and comprehensive documentation;
and concise, <a href="http://flask.pocoo.org/">Flask</a>-like <span class="caps">API</span> for
<a href="https://rocket.rs/overview/#anatomy-of-a-rocket-application">routing</a>
and response handling.
Predictably, it&#8217;s been making quite a
<a href="https://www.reddit.com/r/rust/comments/5jxv6u/rocket_web_framework_for_rust/">buzz</a> on
<a href="https://www.reddit.com/r/programming/comments/5jy64x/rocket_a_web_framework_for_rust/">Reddit</a>
and <a href="https://news.ycombinator.com/item?id=13245475">elsewhere</a>.</p>
<p>There is just an itty bitty little problem: Rocket <em>only works on nightly</em>.
No alternatives, no codegen shims&#8230;
and no prospects of any change in the foreseeable future.
Yet, there doesn&#8217;t seem to be many people concerned about this,
so clearly this is (a new?)&nbsp;norm.</p>
<h4>The Rusts&nbsp;split</h4>
<p>In essence, Rust is now two separate&nbsp;languages.</p>
<p>The stable-nightly divide has essentially evolved into something that closely resembles
the early stages of the <a href="https://wiki.python.org/moin/Python2orPython3">2.x vs. 3.x</a> split in the Python world.
The people still &#8220;stuck&#8221; on 2.7 (i.e. stable) were &#8220;holdouts&#8221;,
and the future was with 3.x (nightly).
Sure, there have been some pithy backports (feature stabilizations),
but the interesting stuff has been happening on the other&nbsp;side.</p>
<p>It&#8217;s astonishing that Rust managed to replicate this phenomenon
without any major version bumps, and with no backwards-incompatible releases.
Technically, everything is still version 1.x..
Not even <a href="http://crates.io">Cargo</a>, the Rust package manager, recognizes the stable-nightly&nbsp;distinction.</p>
<p>But that&#8217;s hardly any consolation when you try to install a nightly-only crate on stable Rust.
You will download it just fine, and get all the way to compiling its code,
only to have it error out due to unsupported <code>#![feature(...)]</code> declarations.</p>
<h4>What&nbsp;now?</h4>
<p>The natural question is, can this situation be effectively&nbsp;addressed?</p>
<p>I hope it&#8217;s obvious why stable Rust cannot suddenly start supporting compiler plugins.
Given that they rely on <code>rustc</code> internals which aren&#8217;t standardized,
doing so would be contrary to the very definition of a &#8220;stable&#8221; release&nbsp;channel.</p>
<p>The other option is to fully embrace nightly as <em>de facto</em> recommended toolchain.
This has been informally happening already,
despite the <a href="https://doc.rust-lang.org/stable/book/release-channels.html#choosing-a-version">contrary recommendations</a>
in the official&nbsp;docs.</p>
<p>The downsides are obvious here, though: nightly Rust is not a misnomer at all.
The compiler is in active development and its build <a href="https://travis-ci.org/rust-lang/rust/builds">breaks often</a>.
Some of those breakages make it into nightly releases with unsatisfying&nbsp;regularity.</p>
<p>Of course, there was also another option:
stick to the intended purpose of release channels and don&#8217;t build castles on the sand
by publishing nightly-first or nightly-only crates.
This ship seems to have sailed by now, as the community has collectively decided&nbsp;otherwise.</p>
<p>Oh&nbsp;well.</p>
<p>It&#8217;s just a little ironic that in a language that is so focused on safety,
everyone is perfectly happy with an <em>unstable compiler</em>.</p>
      <a class="btn" href="http://xion.io/post/programming/rust-nightly-vs-stable.html#rust-nightly-vs-stable">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-iife.html#rust-iife">Simulating exceptions in Rust with <span class="caps">IIFE</span></a></h2>
    <p>
      Posted on Sat 17 December 2016 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/iife.html">IIFE</a>,      <a href="http://xion.io/tag/error-handling.html">error handling</a>,      <a href="http://xion.io/tag/exceptions.html">exceptions</a>,      <a href="http://xion.io/tag/closures.html">closures</a>,      <a href="http://xion.io/tag/lambdas.html">lambdas</a>      &#8226; <a href="http://xion.io/post/code/rust-iife.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>While many languages use exceptions for handling errors,
Rust prefers a slightly different, yet very classical approach: <em>return values</em>.</p>
<p>Now, they aren&#8217;t exactly the same thing as in C,
where the error is indicated by a special value within the same return type.
In Rust, <a href="https://doc.rust-lang.org/std/result/">the <code>Result</code> enum</a> can neatly separate the two,
in similar vein to how ad-hoc tuples in Go do<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>.
But unlike Go, Rust also offers additional facilities for <em>error propagation</em>,
including the <a href="https://doc.rust-lang.org/std/macro.try.html"><code>try!</code> macro</a>
and <a href="https://m4rw3r.github.io/rust-questionmark-operator">the recently stabilized <code>?</code> operator</a>.
And finally,
the <code>Result</code> wrappings can be straightforwardly <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap">unpacked</a>,
possibly by <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or">defaulting</a> to a known safe&nbsp;value.</p>
<p>Some conveniences of exceptions may be hard to pass up, though.
The <code>try</code>-<code>catch</code> construct is evidently one of them,
and Rust might eventually get it in
<a href="https://github.com/rust-lang/rfcs/blob/master/text/0243-trait-based-exception-handling.md">one form</a>
or another.
Before that happens, however, there is a trick that can often work as an acceptable&nbsp;substitute.</p>
<h4>Many <code>let</code>s</h4>
<p>Here&#8217;s an example where it can be very&nbsp;useful.</p>
<p>Have a look at the following function.
Its purpose is to retrieve a GitHub login of a user who owns a specific <em>gist</em>
&#8212; a small sample of code posted to the <em>gists.github.com</em> website<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>.</p>
<p>Let&#8217;s assume we have already talked to GitHub <span class="caps">API</span>
and received the following <span class="caps">JSON</span> response from its relevant&nbsp;endpoint:</p>
<div class="highlight"><pre><span class="p">{</span>
    <span class="nt">&quot;id&quot;</span><span class="p">:</span> <span class="s2">&quot;12345678&quot;</span><span class="p">,</span>
    <span class="nt">&quot;owner&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;login&quot;</span><span class="p">:</span> <span class="s2">&quot;Octocat&quot;</span><span class="p">,</span>
        <span class="err">...</span>
    <span class="p">}</span>
    <span class="err">...</span>
<span class="p">}</span>
</pre></div>


<p>Parsing it is easy: we can do it with
the <a href="https://crates.io/crates/rustc-serialize"><em>rustc_serialize</em> crate</a>,
among other options.
What proves a little more involved is to dig through the <span class="caps">JSON</span> tree
in order to reach the interesting&nbsp;value:</p>
<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">rustc_serialize</span><span class="o">::</span><span class="n">json</span><span class="o">::</span><span class="n">Json</span><span class="p">;</span><span class="w"></span>


<span class="c-Doc">/// Retrieve the gist owner from a JSON received from</span>
<span class="c-Doc">/// the /gists/$ID endpoint of the GitHub API.</span>
<span class="c-Doc">///</span>
<span class="c-Doc">/// If the gist is anonymous, &quot;anonymous&quot; is returned.</span>
<span class="k">fn</span><span class="w"> </span><span class="n">gist_owner_from_info</span><span class="p">(</span><span class="n">info</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Json</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">as_object</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">owner</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;owner&quot;</span><span class="p">).</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">o</span><span class="o">|</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="n">as_object</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">owner</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;login&quot;</span><span class="p">).</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">l</span><span class="o">|</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">as_string</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">to_owned</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="s">&quot;anonymous&quot;</span><span class="p">.</span><span class="n">into</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Whew! I guess we&#8217;re lucky we don&#8217;t need to go <em>too</em> deep into that <span class="caps">JSON</span>.
The code is clearly exhibiting a rightward slant,
which some people refer to as <a href="https://blog.codinghorror.com/flattening-arrow-code/">the &#8220;arrow code&#8221;</a>,
Unsurprisingly, it is generally considered bad for&nbsp;readability.</p>
<p>There are few other ways of writing this, of course,
including a style reminiscent of JavaScript promises &#8212;
that is, relying completely on
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.and_then">the <code>and_then</code> method</a>.
Neither seem very satisfying, though, especially if you compare it with something like&nbsp;this:</p>
<div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s">&quot;owner&quot;</span><span class="p">][</span><span class="s">&quot;login&quot;</span><span class="p">])</span>
<span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">&quot;anonymous&quot;</span>
</pre></div>


<p>Yes, exceptions are quite useful&nbsp;sometimes.</p>
<p>So, how can we get something like this in&nbsp;Rust?</p>
<h4>JavaScript for the&nbsp;rescue</h4>
<p>Succor comes from an unexpected direction.
To emulate exceptions &#8212; specifically, the <code>try</code>-<code>catch</code> exception blocks &#8212;
we can utilize a technique that is most popular in&#8230;&nbsp;JavaScript.</p>
<p>At least until <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let">recently</a>,
JavaScript did not have a block local scope.
Since every <code>var</code>iable declaration within a function is <em>hoisted</em> to the top of that function,
it essentially makes function scope the only usable one (besides global, of&nbsp;course).</p>
<p>As a result, a variety of JavaScript idioms rely on introducing &#8220;superfluous&#8221; <code>function</code>s,
solely for the purpose of creating a nested scope.
Many times, those functions are neither named nor stored in any variable;
rather, they are <em>immediately invoked</em>.</p>
<blockquote>
<p>This is what is commonly understood as Immediately Invoked Function Expression,
or <span class="caps">IIFE</span> for&nbsp;short.</p>
</blockquote>
<p>An oft-cited example involves an <span class="caps">IIFE</span> which itself returns another&nbsp;function:</p>
<div class="highlight"><pre><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">$para</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s2">&quot;p#&quot;</span> <span class="o">+</span> <span class="nx">i</span><span class="p">);</span>  <span class="c1">// &lt;p id=&quot;0&quot;&gt;, &lt;p id=&quot;1&quot;&gt;, etc.</span>
    <span class="kd">var</span> <span class="nx">clickHandler</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// IIFE!</span>
        <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;Clicked element no. &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
        <span class="p">};</span>
    <span class="p">})(</span><span class="nx">i</span><span class="p">);</span>
    <span class="nx">$para</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="nx">clickHandler</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>The function expression is necessary here,
because it allows to control what exactly goes into the <em>closure</em> of the inner function.
If the <code>clickHandler</code>s were assigned the <code>function() { alert(...) }</code> expression directly,
they would all close over the same loop counter variable.
All would then display the exact same&nbsp;message.</p>
<p>We don&#8217;t need to employ those workarounds in Rust.
Thanks to local scoping,
a simple pair of <code>{</code> braces <code>}</code> would work exactly the same.
You can imagine a direct rewrite of the above example, though,
where an anonymous closure is used to similar&nbsp;effect:</p>
<div class="highlight"><pre><span class="c1">// WARNING: Not idiomatic! (Also not a real DOM library).</span>

<span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mf">0.</span><span class="p">.</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">para</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dom</span><span class="p">.</span><span class="n">find_element_by_id</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="n">to_string</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">click_handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">:</span><span class="w"> </span><span class="n">Event</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">dom</span><span class="p">.</span><span class="n">exec_js</span><span class="p">(</span><span class="o">&amp;</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="s">&quot;alert(&#39;Clicked element no. #{}&#39;);&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">para</span><span class="p">.</span><span class="n">add_event_listener</span><span class="p">(</span><span class="n">Event</span><span class="o">::</span><span class="n">Click</span><span class="p">,</span><span class="w"> </span><span class="n">click_handler</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>In other words, Rust supports IIFEs just&nbsp;fine.</p>
<h4>Just put a function on&nbsp;it</h4>
<p>Okay, this is quite amusing and probably pretty neat.
But does it help us with the error handling story&nbsp;exactly?&#8230;</p>
<p>Let&#8217;s take another stab at rewriting the <code>gist_owner_from_info</code> routine.
This time, we&#8217;ll extract the meaty part into a separate function.
We will also take advantage of one trivial,
but very useful <a href="https://crates.io/crates/try_opt"><em>try_opt</em> crate</a>
which is essentially an equivalent of the <code>try!</code> macro for <code>Option</code>s:</p>
<div class="highlight"><pre><span class="cp">#[macro_use]</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="n">crate</span><span class="w"> </span><span class="n">try_opt</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">gist_owner_from_info</span><span class="p">(</span><span class="n">info</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Json</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gist_owner_from_info_internal</span><span class="p">(</span><span class="n">info</span><span class="p">).</span><span class="n">unwrap_or</span><span class="p">(</span><span class="s">&quot;anonymous&quot;</span><span class="p">.</span><span class="n">into</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">gist_owner_from_info_internal</span><span class="p">(</span><span class="n">info</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Json</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_opt</span><span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">as_object</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_opt</span><span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;owner&quot;</span><span class="p">).</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">o</span><span class="o">|</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="n">as_object</span><span class="p">()));</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">login</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_opt</span><span class="o">!</span><span class="p">(</span><span class="n">owner</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;login&quot;</span><span class="p">).</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">l</span><span class="o">|</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">as_string</span><span class="p">()));</span><span class="w"></span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">login</span><span class="p">.</span><span class="n">to_owned</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Now this should be a little easier on the eyes.
(And if you want, you can eschew <code>and_then</code> completely in favor of more <code>try_opt!</code>).</p>
<p>The downside is that we now have this <code>_internal</code> function
that&#8217;s awkwardly sticking out.
We could pull it in, and turn it into an <em>inner</em> function, but why stop half-way?
Let&#8217;s just make it an <span class="caps">IIFE</span>&nbsp;already:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">gist_owner_from_info</span><span class="p">(</span><span class="n">info</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Json</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">||</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_opt</span><span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">as_object</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_opt</span><span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;owner&quot;</span><span class="p">).</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">o</span><span class="o">|</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="n">as_object</span><span class="p">()));</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">login</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_opt</span><span class="o">!</span><span class="p">(</span><span class="n">owner</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;login&quot;</span><span class="p">).</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">l</span><span class="o">|</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">as_string</span><span class="p">()));</span><span class="w"></span>
<span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">login</span><span class="p">.</span><span class="n">to_owned</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="p">}().</span><span class="n">unwrap_or</span><span class="p">(</span><span class="s">&quot;anonymous&quot;</span><span class="p">.</span><span class="n">into</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Not bad, eh? The analogies with exception handling should be pretty evident, too<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>:</p>
<ul>
<li>The closure itself works as a <code>try</code> block, with closure&#8217;s body containing the &#8220;guarded&#8221;&nbsp;code.</li>
<li>The <code>unwrap</code> family of methods (especially <code>unwrap_or_else</code>) dubs for a <code>catch</code>/<code>except</code> section.</li>
</ul>
<p>Sure, we do need <code>try!</code> (or <code>try_opt!</code>) macros to mark instructions
that may &#8220;throw an exception&#8221;, but with the <code>?</code>-based syntax it shouldn&#8217;t be too big of a deal.
And when the time comes, this code will be very easy to port to a
<a href="https://github.com/rust-lang/rfcs/blob/master/text/0243-trait-based-exception-handling.md">trait-based exception handling</a>
solution that&#8217;s currently in the&nbsp;works.</p>
<p>Oh, and the best part? Both Rust and the underlying <span class="caps">LLVM</span> are very adept at
<a href="https://ruudvanasseldonk.com/2016/11/30/zero-cost-abstractions">inlining closures</a>,
so everything here should compile to optimal&nbsp;code.</p>
<h4>Bonus: a lifetime&nbsp;conundrum</h4>
<p>Well, <em>almost</em> optimal.
There is one more thing left to do before we can call this a truly <em>zero-cost</em>&nbsp;abstraction.</p>
<p>We need to stop allocating so damn&nbsp;much!</p>
<p>It should be pretty obvious that
the function doesn&#8217;t need to create a brand new <code>String</code> every time it&#8217;s called.
The text is in the input <code>Json</code>, and we take that <code>Json</code> by reference already.
It&#8217;s only fair we stop creating <code>String</code>s and simply return a <code>&amp;str</code> reference&nbsp;instead.</p>
<p>In fact, this should be as easy as removing the <code>to_owned</code>/<code>into</code> calls,&nbsp;right?</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">gist_owner_from_info</span><span class="p">(</span><span class="n">info</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Json</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">||</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_opt</span><span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">as_object</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_opt</span><span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;owner&quot;</span><span class="p">).</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">o</span><span class="o">|</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="n">as_object</span><span class="p">()));</span><span class="w"></span>
<span class="w">        </span><span class="n">owner</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;login&quot;</span><span class="p">).</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">l</span><span class="o">|</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">as_string</span><span class="p">()))</span><span class="w"></span>
<span class="w">    </span><span class="p">}().</span><span class="n">unwrap_or</span><span class="p">(</span><span class="s">&quot;anonymous&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Wrong, apparently. If you present this code to the compiler,
it will serve you quite a mouthful of an error,
including helpful tidbits in the vein of &#8220;expected A, found&nbsp;A&#8221;:</p>
<div class="highlight"><pre>error[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements
   --&gt; src/github.rs:3:34
    |
  3 |         let info = try_opt!(info.as_object());
    |                                  ^^^^^^^^^
    |
note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the block at 1:45...
   --&gt; src/github.rs:1:46
    |
  1 | fn gist_owner_from_info(info: &amp;Json) -&gt; &amp;str {
    |                                              ^
note: ...so that reference does not outlive borrowed content
   --&gt; src/github.rs:3:29
    |
  3 |         let info = try_opt!(info.as_object());
    |                             ^^^^
note: but, the lifetime must be valid for the anonymous lifetime #1 defined on the block at 2:23...
   --&gt; src/github.rs:2:24
    |
  2 |     || -&gt; Option&lt;&amp;str&gt; {
    |                        ^
note: ...so that expression is assignable (expected std::option::Option&lt;&amp;str&gt;, found std::option::Option&lt;&amp;str&gt;)
   --&gt; src/github.rs:5:9
    |
  5 |         owner.get(&quot;login&quot;).and_then(|l| l.as_string())
    |
</pre></div>


<p>The crux of this verbiage is that the Rust compiler is unable to reconcile the lifetime
of the closure&#8217;s return value, the input, and final result of the&nbsp;function.</p>
<p>It shouldn&#8217;t really be trying very hard, though, for the lifetime is obvious.
It&#8217;s the same as the one implicitly attached to the input <code>&amp;Json</code>.
Seems like in this case, we need to be a little more helpful and label it&nbsp;explicitly:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">gist_owner_from_info</span><span class="o">&lt;</span><span class="nl">&#39;i</span><span class="o">&gt;</span><span class="p">(</span><span class="n">info</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;i</span><span class="w"> </span><span class="n">Json</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">&#39;i</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">||</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">&#39;i</span><span class="w"> </span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="c1">// (rest as before)</span>
</pre></div>


<p>Voila, this should now compile without any&nbsp;issues.</p>
<p>Once again, &#8220;Keep calm and add more <code>'lifetimes</code>&#8221; proves to be an effective approach&nbsp;;)</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Technically, they aren&#8217;t called tuples there but
&#8220;<a href="https://golang.org/doc/effective_go.html#multiple-returns">multiple return values</a>&#8220;.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>This is something I needed to do when rewriting
<a href="https://github.com/Xion/gisht.py">this Python project of mine</a> to Rust.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>This is also the closest Rust can currently get to a <code>do</code> notation from Haskell,
at least without any macro-based hacks.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/rust-iife.html#rust-iife">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-optional-args.html#rust-optional-args">Optional arguments in Rust&nbsp;1.12</a></h2>
    <p>
      Posted on Thu 29 September 2016 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/arguments.html">arguments</a>,      <a href="http://xion.io/tag/parameters.html">parameters</a>,      <a href="http://xion.io/tag/functions.html">functions</a>      &#8226; <a href="http://xion.io/post/code/rust-optional-args.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>Today&#8217;s <a href="https://blog.rust-lang.org/2016/09/29/Rust-1.12.html">announcement of Rust 1.12</a> contains,
among other things, this innocous little&nbsp;tidbit:</p>
<blockquote>
<p><code>Option</code> implements <code>From</code> for its contained&nbsp;type</p>
</blockquote>
<p>If you&#8217;re not very familiar with it,
<code>From</code> is a basic <a href="https://doc.rust-lang.org/std/convert/trait.From.html">converstion trait</a>
which any Rust type can implement.
By doing so, it defines how to create its values <em>from</em> some other type &#8212; hence its&nbsp;name.</p>
<p>Perhaps the most widespread application of this trait (and its <code>from</code> method)
is allocating owned <code>String</code> objects from literal <code>str</code> values:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;Hello, world!&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>


<p>What the change above means is that we can do similar thing with the <code>Option</code> type:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">maybe_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Option</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span><span class="w"></span>
</pre></div>


<p>At a first glance, this doesn&#8217;t look like a big deal at all.
For one, this syntax is much more wordy than the traditional <code>Some(42)</code>,
so it&#8217;s not very clear what benefits it&nbsp;offers.</p>
<p>But this first impression is rather deceptive.
In many cases, this change can actually <em>reduce</em> the number of times we have to type <code>Some(x)</code>,
allowing us to replace it with just <code>x</code>.
That&#8217;s because this new <code>impl</code> brings Rust quite a bit closer to having <em>optional function arguments</em>
as a first class feature in the&nbsp;language.</p>
<p>Until now, a function defined like&nbsp;this:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">maybe_plus_5</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="p">.</span><span class="n">unwrap_or</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>was the closest Rust had to default argument values.
While this works perfectly &#8212; and is bolstered by compile-time checks! &#8212;
callers are unfortunately required to build the <code>Option</code> objects&nbsp;manually:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maybe_plus_5</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span><span class="w">  </span><span class="c1">// OK</span>
<span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maybe_plus_5</span><span class="p">(</span><span class="nb">None</span><span class="p">);</span><span class="w">      </span><span class="c1">// OK</span>
<span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maybe_plus_5</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span><span class="w">        </span><span class="c1">// error!</span>
</pre></div>


<p>After <code>Option&lt;T&gt;</code> implements <code>From&lt;T&gt;</code>, however, this can change for the better.
<em>Much</em> better, in fact, for the last line above can be made valid.
All that is necessary is to take advantage of this new <code>impl</code> in the function&nbsp;definition:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">maybe_plus_5</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;:</span><span class="w"> </span><span class="n">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Option</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="n">unwrap_or</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Unfortunately, this results in quite a bit of complexity,
up to and including the <code>where</code> clause: a telltale sign of convoluted, generic code.
Still, this trade-off may be well worth it,
as a function defined once can be called many times throughout the code base,
and possibly across multiple crates if it&#8217;s a part of the public <span class="caps">API</span>.</p>
<p>But we can do better than this.
Indeed, using the <code>From</code> trait to constrain argument types is just complicating things for no good reason.
What we should so instead is use the symmetrical trait, <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>,
and take advantage of its standard <code>impl</code>:</p>
<div class="highlight"><pre><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Into</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">U</span><span class="o">:</span><span class="w"> </span><span class="n">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
</pre></div>


<p>Once we translate it to the <code>Option</code> case (now that <code>Option&lt;T&gt;</code> implements <code>From&lt;T&gt;</code>),
we can switch the trait bounds around and get rid of the <code>where</code> clause&nbsp;completely:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">maybe_plus_5</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="n">Into</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="p">.</span><span class="n">into</span><span class="p">().</span><span class="n">unwrap_or</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>As a small bonus, the function body has also gotten a little&nbsp;simpler.</p>
<hr />
<p>So, should you go wild and change all your functions taking <code>Option</code>als to look like this?&#8230;
Well, technically you can, although the benefits may not outweigh the downsides
for small, private functions that are called&nbsp;infrequently.</p>
<p>On the other hand, if you can afford to only support Rust 1.12 and up,
this technique can make it much more pleasant to use the external <span class="caps">API</span> of your&nbsp;crates.</p>
<p>What&#8217;s best is the <em>full backward compatibility</em> with any callers that still pass <code>Some(x)</code>:
for them, the old syntax will continue to work exactly like before.
Also note that the Rust compiler is smart about eliding the no-op conversion calls like the <code>Into::into</code> above,
so you shouldn&#8217;t observe any changes in the performance department&nbsp;either.</p>
<p>And who knows, maybe at some point Rust makes the final leap, and allows skipping the <code>None</code>s?&#8230;</p>
      <a class="btn" href="http://xion.io/post/code/rust-optional-args.html#rust-optional-args">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-for-loop.html#rust-for-loop">for loops in&nbsp;Rust</a></h2>
    <p>
      Posted on Tue 26 July 2016 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/loops.html">loops</a>,      <a href="http://xion.io/tag/iterators.html">iterators</a>      &#8226; <a href="http://xion.io/post/code/rust-for-loop.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>In this post, I&#8217;m going to talk about the <code>for</code> loop construct in <a href="https://rust-lang.org">Rust</a>,
as well as the related concepts of <em>iterators</em> and&nbsp;&#8220;iterables&#8221;.</p>
<p>Depending on your programming language background,
they may seem somewhat familiar in terms of syntax <span class="amp">&amp;</span> semantics,
or rather mysterious and surprising.
Their closest analogues exist in Python,
but programmers of Java, C#, or (modern) C++ should recognize many relevant features and ideas as&nbsp;well.</p>
<h4>Basics</h4>
<p>The syntax of a <code>for</code> loop is so modest it&#8217;s almost spartan<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="s">&quot;1&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;3&quot;</span><span class="p">];</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>As you would expect, <a href="https://is.gd/qtxqLD">this prints three lines</a> with <code>1</code>, <code>2</code>, <code>3</code>.
What is probably not as obvious is that
over the course of this loop the <code>v</code> vector was <em>expended</em>.
Trying to <a href="https://is.gd/1mv7RV">use it</a> after the iteration,
we&#8217;ll get a borrow checker&nbsp;error:</p>
<div class="highlight"><pre>&lt;anon&gt;:6:22: 6:23 error: use of moved value: `v` [E0382]
&lt;anon&gt;:4         println!(&quot;{}&quot;, x);
&lt;anon&gt;:5     }
&lt;anon&gt;:6     println!(&quot;{:?}&quot;, v);
                              ^
</pre></div>


<p>In Rust jargon, the vector has been <strong>moved</strong> into the loop.
Its ownership &#8212; and that of its individual elements &#8212; has been transfered there permanently.
While definitely surprising when compared to other languages,
this behavior is consistent with Rust&#8217;s ubiquitous policy of moving values by&nbsp;default.</p>
<p>Still, you may not expect it here
because moving ownership is mostly seen at the function call boundaries.
For most intents and purposes, however,
you can picture a <code>for_each</code> function like this to be the equivalent of the <code>for</code> loop&nbsp;above:</p>
<div class="highlight"><pre><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">));</span><span class="w"></span>
</pre></div>


<p>This also gives us a hint on how we could prevent the move from happening.
Rather than taking the vector itself,
the function could accept only a reference to&nbsp;it:</p>
<div class="highlight"><pre><span class="n">for_each_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">));</span><span class="w"></span>
</pre></div>


<p>After we translate this <a href="https://is.gd/Zrq0JL">back to the looping syntax</a>:</p>
<div class="highlight"><pre><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
</pre></div>


<p>we won&#8217;t get any more objections from the&nbsp;compiler.</p>
<h4>Iterators and &#8220;iterables&#8221; in&nbsp;Rust</h4>
<p>It is important to emphasize that this new ampersand symbol (<code>&amp;</code>)
is by no means a part of the syntax of the <code>for</code> loop itself.
We have actually changed <em>what object</em> we&#8217;re iterating here.
It is no longer <code>Vec&lt;T&gt;</code> &#8212; a vector itself &#8212; but <code>&amp;Vec&lt;T&gt;</code>, an immutable reference to it.
As a consequence, <code>x</code> is not a <code>T</code> (the element type) anymore,
but a <code>&amp;T</code> &#8212; a <em>reference</em> to an element<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>.</p>
<p>So it seems that in Rust, both <code>Vec&lt;T&gt;</code> and <code>&amp;Vec&lt;T&gt;</code> are what we would call &#8220;iterables&#8221;:
collections (or other objects) that we can get iterate over.
The usual way this is implemented in various programming languages
is by introducing an <em>iterator</em>&nbsp;object.</p>
<p>The iterator keeps track of what element it&#8217;s currently pointing to
and supports at least the following basic&nbsp;operations:</p>
<ul>
<li>getting the current&nbsp;element</li>
<li>advancing to the next&nbsp;element</li>
<li>signaling when no more elements are&nbsp;available</li>
</ul>
<p>Some languages provide separate iterator methods for each of those tasks,
but Rust chooses to combine them all into one.
You can see that when looking at the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code> trait</a>:
<code>next</code> is the only method to be provided by its&nbsp;implementations.</p>
<h4>Desugaring with&nbsp;into-iterators</h4>
<p>How is the iterator object created,&nbsp;though?</p>
<p>In a typical Rust manner, this job is delegated to another trait.
This one is called <code>IntoIterator</code>,
and it roughly corresponds to the &#8220;iterable&#8221; concept I&#8217;ve alluded to&nbsp;earlier:</p>
<div class="highlight"><pre><span class="c1">// (simplified)</span>
<span class="k">trait</span><span class="w"> </span><span class="n">IntoIterator</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">into_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>What is uniquely Rusty is the fact that <code>into_iter</code> &#8212; the sole method of this trait &#8212;
doesn&#8217;t just create a new iterator for the collection.
Instead, it effectively <em>consumes</em> the whole thing,
leaving the new iterator as its only remnant and the only way to access the items<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>.</p>
<p>This, of course, is a direct manifestation of the Rust&#8217;s move-by-default policy.
In this case, it protects us from the common problem of <strong>iterator invalidation</strong>
which is probably all-too-familiar to C++ programmers.
Because the collection is essentially &#8220;converted&#8221; to an iterator here, it is&nbsp;impossible:</p>
<ul>
<li>for more than one iterator to exist at a&nbsp;time</li>
<li>to modify the collection while any iterators are in&nbsp;scope</li>
</ul>
<p>Doesn&#8217;t all this &#8220;moving&#8221; and &#8220;consuming&#8221; sound familiar, by the way?
I&#8217;ve mentioned earlier that when we iterate over a vector with a <code>for</code> loop,
we essentially move it &#8220;into the&nbsp;loop&#8221;.</p>
<p>As you can probably deduce by now,
what really happens is that <code>IntoIterator::into_iter</code> is invoked on the vector.
Its result &#8212; the iterator object &#8212; is then repeatedly <code>next</code><span class="quo">&#8216;</span>ed until it returns <code>None</code>.</p>
<p>In a way, a <code>for</code> loop like&nbsp;this:</p>
<div class="highlight"><pre><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// body</span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>is therefore nothing else but a syntactic sugar for the following expanded&nbsp;version:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IntoIterator</span><span class="o">::</span><span class="n">into_iter</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// body</span>
<span class="w">        </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">break</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>You can see quite clearly that <code>v</code> is unusable not only after the loop ends,
but before it even <em>begins</em>.
This is because it has been moved into <code>iter</code> &#8212; into an iterator &#8212;
through an <code>into_iter</code> method&#8230; of <code>IntoIterator</code>!</p>
<p>Simple, huh?&nbsp;:)</p>
<blockquote>
<p><code>for</code> loop is just a syntactic sugar for an <code>IntoIterator::into_iter</code> invocation,
followed by repeated calling of <code>Iterator::next</code>.</p>
</blockquote>
<h4>The&nbsp;ampersand</h4>
<p>On a more serious note, this move isn&#8217;t something that we&#8217;d always want to happen.
Fortunately, we know a way to prevent it.
Rather than iterating over the vector itself, use a <em>reference</em> to&nbsp;it:</p>
<div class="highlight"><pre><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// body</span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>The great thing about this syntax is that everything said above still applies,
up to and including the desugaring procedure.
The <code>into_iter</code> method is still being invoked,
except that this time it is done on the <em>reference to the collection</em> &#8212;
<code>&amp;Vec&lt;T&gt;</code> rather than <code>Vec&lt;T&gt;</code>:</p>
<div class="highlight"><pre><span class="c1">// (simplified)</span>
<span class="k">impl</span><span class="w"> </span><span class="n">IntoIterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">into_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=&amp;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>The result is therefore an iterator that yields <em>references</em> to the elements (<code>&amp;T</code>),
rather than elements themselves (<code>T</code>).
And because <code>self</code> above is also a reference,
the collection isn&#8217;t really moved anywhere,
which is why we can freely access it after the loop&nbsp;ends.</p>
<p>The exact same thing happens when looping over a <em>mutable</em>&nbsp;reference:</p>
<div class="highlight"><pre><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// body</span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>except that this time <code>into_iter</code> is called for <code>&amp;mut Vec&lt;T&gt;</code>.
Result is therefore of type <code>Iterator&lt;Item=&amp;mut T&gt;</code>,
enabling us to modify the elements as we go through&nbsp;them.</p>
<p>No further compiler machinery is required to support those two cases,
because everything is already handled by the same&nbsp;trait.</p>
<blockquote>
<p>The <code>IntoIterator</code> desugaring works the same way for collections
<em>and</em> both immutable and mutable references to&nbsp;them.</p>
</blockquote>
<h4>What about the iter()&nbsp;method?</h4>
<p>So far, we&#8217;ve talked about regular <code>for</code> loops,
and the very imperative style of computation they&nbsp;represent.</p>
<p>If you are more inclined towards functional programming, though,
you may have seen and written rather different constructs,
combining various &#8220;fluent&#8221; methods into expressions such as this&nbsp;one:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">doubled_odds</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numbers</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
</pre></div>


<p>Methods like <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map"><code>map</code></a>
and <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter"><code>filter</code></a> here
are called <em>iterator adapters</em>,
and they are all defined on the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code> trait</a>.
Not only are they very powerful and numerous,
but they can also be supplemented through several <a href="https://crates.io/crates/itertools">third-party crates</a>.</p>
<p>In order to take advantage of the adapters, however,
we need to obtain an iterator for our collection first.
We know that <code>into_iter</code> is the way loops normally do it,
so in principle we could follow the same approach&nbsp;here:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">doubled_odds</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IntoIterator</span><span class="o">::</span><span class="n">into_iter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numbers</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
</pre></div>


<p>To spare us the verbosity of this explicit syntax,
collections normally offer an <code>iter</code> method which is exactly equivalent<sup id="fnref:4"><a class="footnote-ref" href="#fn:4" rel="footnote">4</a></sup>.
This method is what you will normally see in chained expressions like the one&nbsp;above.</p>
<blockquote>
<p><code>v.iter()</code> is just a shorthand for <code>IntoIterator::into_iter(&amp;v)</code>.</p>
</blockquote>
<h4>Why not&nbsp;both?</h4>
<p>The last thing to note is that Rust mandates neither loops nor iterator adapters
when writing code that operates on collections of elements.
When optimizations are turned on in the <a href="http://doc.crates.io/manifest.html#the-profile-sections">release mode</a>,
both versions should compile to equally efficient machine code,
with closures inlined and loops unrolled where&nbsp;necessary.</p>
<p>Choosing one style over the other is therefore a matter of convention and style.
Sometimes the right choice may actually be a <em>mix</em> of both approaches,
and Rust allows it without any&nbsp;complaints:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">print_prime_numbers_upto</span><span class="p">(</span><span class="n">n</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Prime numbers lower than {}:&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mf">2.</span><span class="p">.</span><span class="n">n</span><span class="p">).</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="n">is_prime</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Like before, this is possible through the same <code>for</code> loop desugaring
that involves the <code>IntoIterator</code> trait.
In this case, Rust will simply use a
<a href="https://github.com/rust-lang/rust/blob/bbfcb471db0799a7d92d62e66cf44bbd68051675/src/libcore/iter/traits.rs#L253">no-op implementation</a>
of this trait, &#8220;converting&#8221; any existing <code>Iterator</code> <span class="dquo">&#8220;</span>into&#8221;&nbsp;itself.</p>
<blockquote>
<p>Iterators themselves are also &#8220;iterables&#8221;,
implementing <code>IntoIterator::into_iter</code> as a&nbsp;pass-through.</p>
</blockquote>
<h4>Looping&nbsp;around</h4>
<p>If you want to know even more about iterators and loops in Rust,
the best source at this point is probably just
<a href="http://doc.rust-lang.org/std/iter/index.html#for-loops-and-intoiterator">the official documentation</a>.
And although mastering all the iterator adapters is of course not necessary to write effective Rust code,
taking a careful look at least at
<a href="http://doc.rust-lang.org/std/iter/index.html#for-loops-and-intoiterator">the <code>collect</code> method</a>
(and the associated <a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code>FromIterator</code> trait</a>)
is definitely&nbsp;helpful.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>The &#8220;two-semicolon&#8221; variant of the <code>for</code> loop doesn&#8217;t exist in Rust. Just like in Python, the equivalent is
iterating over a <a href="http://rustbyexample.com/flow_control/for.html">range object</a>, or using a regular <code>while</code> loop
for more complex cases.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>This shift is completely transparent in the loop&#8217;s body. The way it works is based on Rust&#8217;s special mechanism
called <a href="https://doc.rust-lang.org/book/deref-coercions.html">the <code>Deref</code> coercions</a>.
Without going into too much detail (as it is way out of scope for this post),
this feature allows us to treat references to objects (<code>&amp;T</code>) as if they were the objects themselves (<code>T</code>).
The compiler will perform the necessary <em>derefencing</em> where possible,
or signal an error in case of a (rare) ambiguity.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>How do we know that? It&#8217;s because <code>into_iter</code> takes <code>self</code> (rather than <code>&amp;self</code> or <code>&amp;mut self</code>)
as its first parameter. It means that the entire object for which this method is called is moved <em>into</em> its body
(hence the method&#8217;s name).&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>Curiously enough, this equivalence isn&#8217;t encoded in the type system in any way,
making it technically just a convention. It is followed consistently at least in the standard library, though.&#160;<a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/rust-for-loop.html#rust-for-loop">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-patterns-ref.html#rust-patterns-ref">& vs. ref in Rust&nbsp;patterns</a></h2>
    <p>
      Posted on Thu 02 June 2016 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/pattern-matching.html">pattern matching</a>,      <a href="http://xion.io/tag/borrowing.html">borrowing</a>,      <a href="http://xion.io/tag/references.html">references</a>      &#8226; <a href="http://xion.io/post/code/rust-patterns-ref.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>Rust is one of those nice languages with <em>pattern matching</em>.
If you don&#8217;t know, it can be thought of as a generalization of the <code>switch</code> statement:
comparing objects not just by value (or overloaded equality operator, etc.)
but by <em>structure</em>:</p>
<div class="highlight"><pre><span class="k">match</span><span class="w"> </span><span class="n">hashmap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">do_something_with</span><span class="p">(</span><span class="n">value</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Oh noes!&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>It doesn&#8217;t end here. As you can see above, objects can also be
<em>destructured</em> during the match (<code>Some(value)</code>),
their parts assigned to <em>bindings</em> (<code>value</code>),
and those bindings can subsequently be used in the <code>match</code> branch.</p>
<p>Neat? Definitely.
In Rust, pattern matching is bread-and-butter of not only the <code>match</code> statement,
but also <code>for</code>, (<code>if</code>)<code>let</code>, and even ordinary function&nbsp;arguments.</p>
<h4>Mixing in Rust&nbsp;semantics</h4>
<p>For a long time, however, I was somewhat confused as to what happens
when references and borrowing is involved in matching.
The two &#8220;operators&#8221; that often occur there are <code>&amp;</code> (ampersand) and <code>ref</code>.</p>
<p>You should readily recognize the first one,
as it is used pervasively in Rust to create references (and reference types).
The second one quite obviously hints towards references as well.
Yet those two constructs serve <em>very</em> different purposes when used within a&nbsp;pattern.</p>
<p>To add to the confusion, they are quite often encountered&nbsp;together:</p>
<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">hyper</span><span class="o">::</span><span class="n">Url</span><span class="p">;</span><span class="w"></span>

<span class="c1">// print query string params of some URL</span>
<span class="kd">let</span><span class="w"> </span><span class="n">url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Url</span><span class="o">::</span><span class="n">parse</span><span class="p">(</span><span class="n">some_url</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">query_params</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">url</span><span class="p">.</span><span class="n">query_pairs</span><span class="p">().</span><span class="n">unwrap_or</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[]);</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">query_params</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}={}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Lack of one or the other will be (at best) pointed out to you by the compiler,
along with a suggestion where to add it.
But addressing problems in this manner can only go so far.
So how about we delve deeper and see what it&#8217;s really&nbsp;about?</p>
<h4>Part of the reference, part of the&nbsp;pattern</h4>
<p>Rust is very flexible as to what value can be a subject of pattern matching.
You would be very hard pressed to find anything that <em>cannot</em> be used within a <code>match</code> statement, really.
Both actual objects and references to objects are perfectly&nbsp;allowed:</p>
<div class="highlight"><pre><span class="k">struct</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="kt">i32</span><span class="p">);</span><span class="w"></span>
<span class="c1">// ...</span>
<span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Foo</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span><span class="w"></span>
<span class="k">match</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Matched!&quot;</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>In the latter case, however, we aren&#8217;t typically interested in the reference itself (like above).
Instead, we want to determine some facts about the object it <em>points</em>&nbsp;to:</p>
<div class="highlight"><pre><span class="k">match</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">Foo</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Matched with number {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>As you can see, this is where the ampersand comes into play.
Just like a type constructor (<code>Some</code>, <code>Ok</code>, or <code>Foo</code> above),
the <code>&amp;</code> operator informs the Rust compiler what kind of value we&#8217;re expecting from the match.
When it sees the ampersand, it knows we&#8217;re looking for <em>references</em> to certain objects,
and not for the objects&nbsp;themselves.</p>
<p>Why is the distinction between an object and its reference important, though?
In many other places, Rust is perfectly happy to blur the gap between references and actual objects<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup> &#8212;
for example when calling most of their&nbsp;methods.</p>
<p>Pattern matching, however,
due to its ability to unpack values into their constituent parts,
is a <em>destructive</em> operation. Anything we apply <code>match</code> (or similar construct) to
will be <em>moved</em> into the block by&nbsp;default:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">maybe_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;Alice&quot;</span><span class="p">));</span><span class="w"></span>
<span class="c1">// ...</span>
<span class="k">match</span><span class="w"> </span><span class="n">maybe_name</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Hello, {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{},</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">do_something_with</span><span class="p">(</span><span class="n">maybe_name</span><span class="p">)</span><span class="w"></span>
</pre></div>


<p>Following the typical <a href="https://doc.rust-lang.org/book/ownership.html">ownership semantics</a>,
this will prevent any subsequent moves and essentially consume the&nbsp;value:</p>
<div class="highlight"><pre>error: use of partially moved value: `maybe_name` [E0382]
    do_something_with(maybe_name);
                      ^~~~~~~~~~
</pre></div>


<p>So just like the aforementioned type constructors (<code>Some</code>, etc.),
the ampersand operator is simply <em>part of the pattern</em> that we match against.
And just like with <code>Some</code> and friends, there is an obvious symmetry here:
if <code>&amp;</code> was used to create the value, it needs to be used when unpacking&nbsp;it.</p>
<blockquote>
<p>The syntax used in a pattern that destructures an object
is analogous to one used by the expression which created&nbsp;it.</p>
</blockquote>
<h4>Preventing the&nbsp;move</h4>
<p>Errors like the one above often contain helpful&nbsp;notes:</p>
<div class="highlight"><pre>note: `(maybe_name:core::option::Option::Some).0` moved here because it has type `collections::string::String`, which is moved by default
         Some(n) =&gt; println!(&quot;Hello, {}&quot;, n),
              ^
</pre></div>


<p>as well as hints for resolving&nbsp;them:</p>
<div class="highlight"><pre>help: if you would like to borrow the value instead, use a `ref` binding as shown:
        Some(ref n) =&gt; println!(&quot;Hello, {}&quot;, n),
</pre></div>


<p>Here&#8217;s where <code>ref</code> enters the&nbsp;scene.</p>
<p>The message tells us that if we add a <code>ref</code> keyword in the suggested spot,
we will switch from moving to <em>borrowing</em> for the <code>match</code> binding that follows (here, <code>n</code>).
It will still capture its value exactly as before,
but it will no longer assume <em>ownership</em> of&nbsp;it.</p>
<p>This is the crucial&nbsp;difference.</p>
<p>Unlike the ampersand, <code>ref</code> is <strong>not</strong> something we match against.
It doesn&#8217;t affect what values match the pattern it&#8217;s in, and what values don&#8217;t<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>.</p>
<p>The only thing it changes is how parts of the matched value
are <em>captured</em> by the pattern&#8217;s&nbsp;bindings:</p>
<ul>
<li>by default, without <code>ref</code>, they are <em>moved</em> into the <code>match</code> arms</li>
<li>with <code>ref</code>, they are <em>borrowed</em> instead and represented as&nbsp;references</li>
</ul>
<p>Looking at our example, the <code>n</code> binding in <code>Some(n)</code> is of type <code>String</code>:
the actual field type from the matched structure.
By contrast, the other <code>n</code> in <code>Some(ref n)</code> is a <code>&amp;String</code> &#8212;
that is, a <em>reference</em> to the&nbsp;field.</p>
<p>One is a move, the other one is a&nbsp;borrow.</p>
<blockquote>
<p><code>ref</code> annotates pattern bindings to make them borrow rather than move.
It is <em>not</em> a part of the pattern as far as matching is&nbsp;concerned.</p>
</blockquote>
<h4>Used&nbsp;together</h4>
<p>To finish off, let&#8217;s untangle the confusing example from the beginning of this&nbsp;post:</p>
<div class="highlight"><pre><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">query_params</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}={}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Since we know <code>ref</code> doesn&#8217;t affect whether or not the pattern matches,
we could just as well have something like <code>&amp;(a, b)</code>.
And this should be quite a bit easier to read:
it clearly denotes we expect a reference to a 2-tuple of simple objects.
Not coincidentally,
such tuples are items from the vector we&#8217;re iterating&nbsp;over.</p>
<p>Problem is,
without the <code>ref</code>s we will attempt to <em>move</em> those items into the loop scope.
But due to the way the vector is iterated over (<code>&amp;query_params</code>),
we&#8217;re only <em>borrowing</em> each item, so this is actually impossible.
In fact, it would be a classic attempt to move out of a borrowed&nbsp;context.</p>
<p>It is also wholly unnecessary.
The only thing this loop does is printing the items out,
so accessing them through references is perfectly&nbsp;fine.</p>
<p>And this is exactly what the <code>ref</code> operator gives us.
Adding the keyword back,
we will switch from moving the values to just borrowing them&nbsp;instead.</p>
<h4>To sum&nbsp;up</h4>
<ul>
<li>
<p><code>&amp;</code> denotes that your pattern <strong>expects a reference</strong> to an object.
Hence <code>&amp;</code> is a part of said pattern:
<code>&amp;Foo</code> matches <em>different</em> objects than <code>Foo</code> does.</p>
</li>
<li>
<p><code>ref</code> indicates that you want a <strong>reference to an unpacked value</strong>.
It is <em>not</em> matched against:
<code>Foo(ref foo)</code> matches <em>the same</em> objects as <code>Foo(foo)</code>. </p>
</li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>The technical term for this is
a <a href="https://doc.rust-lang.org/book/deref-coercions.html"><em><code>Deref</code> coercion</em></a>.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>We can say that it doesn&#8217;t affect the <em>satisfiability</em>
(or conversely, <em>refutability</em>) of the pattern.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/rust-patterns-ref.html#rust-patterns-ref">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-borrowchk-tricks.html#rust-borrowchk-tricks">Tricks with ownership in&nbsp;Rust</a></h2>
    <p>
      Posted on Mon 07 March 2016 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/borrow-checker.html">borrow checker</a>,      <a href="http://xion.io/tag/reference-counting.html">reference counting</a>,      <a href="http://xion.io/tag/traits.html">traits</a>      &#8226; <a href="http://xion.io/post/code/rust-borrowchk-tricks.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p><em>&#8230;or how I learned to stop worrying and love the borrow&nbsp;checker.</em></p>
<p>Having no equivalents in other languages, the <a href="https://doc.rust-lang.org/book/ownership.html">borrow checker</a>
is arguably the most difficult thing to come to terms with when learning Rust. It&#8217;s easy to understand why it&#8217;s immensely
useful, especially if you recall
<a href="https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html">the various vulnerabities</a>
stemming from memory mismanagement. But that knowledge doesn&#8217;t exactly help when the compiler is whining about what
seems like a perfectly correct&nbsp;code.</p>
<p>Let&#8217;s face it: it will take some time to become productive writing efficient and safe code. It&#8217;s not entirely unlike
adjusting to a different paradigm such as functional programming when you&#8217;ve been writing mostly imperative code.
Before that happens, though, you can use some tricks to make the transition a little&nbsp;easier.</p>
<h4>Just <code>clone</code> it</h4>
<p>Ideally, we&#8217;d want our code to be both correct <em>and</em> fast. But if we cannot quite get to the &#8220;correctness&#8221; part yet &#8212;
because our program doesn&#8217;t, you know, <em>compile</em> &#8212; then how about paying for it with a small (and refundable)
performance&nbsp;hit?</p>
<p>This is where the <code>clone</code> method comes in handy. Many problems with the borrow checker stem from trying to spread
object ownership too thin. It is a precious resource and it&#8217;s not very cheap to &#8220;produce&#8221;, which is why good Rust code
often deals with just immutable or mutable&nbsp;references.</p>
<p>But if that proves difficult, then &#8220;making more objects&#8221; is a great intermediate solution. Incidentally, this is what
higher level languages are doing all the time, and often transparently. To ease the transition to Rust from
those languages, we can start off by replicating their&nbsp;behavior.</p>
<p>As an example, consider a function that tries to convert some value to <code>String</code>:</p>
<div class="highlight"><pre><span class="k">struct</span><span class="w"> </span><span class="n">Error</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">maybe_to_string</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// omitted</span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>If we attempt to build upon it and create a <code>Vec</code>tor&nbsp;version:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">maybe_all_to_string</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">results</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">maybe_to_string</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">results</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">find</span><span class="p">(</span><span class="o">|</span><span class="n">r</span><span class="o">|</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">is_err</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">Error</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">r</span><span class="o">|</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">ok</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()).</span><span class="n">collect</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>then we&#8217;ll be unpleasantly surprised by a borrow checker&nbsp;error:</p>
<div class="highlight"><pre>error: cannot move out of borrowed content [E0507]
    Ok(results.iter().map(|r| r.ok().unwrap()).collect())
                              ^
</pre></div>


<p>Much head scratching will ensue, and we may eventually find an idiomatic and efficient solution.
However, a simple stepping stone in the shape of additional <code>clone()</code> call can help move things forward just
a little&nbsp;quicker:</p>
<div class="highlight"><pre><span class="cp">#[derive(Clone)]</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="n">Error</span><span class="p">;</span><span class="w"></span>

<span class="c1">// ...</span>
<span class="nb">Ok</span><span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">r</span><span class="o">|</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">clone</span><span class="p">().</span><span class="n">ok</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()).</span><span class="n">collect</span><span class="p">())</span><span class="w"></span>
</pre></div>


<p>The performance tradeoff is explicit, and easy to find later on with a simple <code>grep clone\(\)</code> or similar.
When you learn to do things the Rusty way, it won&#8217;t be hard to go back to your &#8220;hack&#8221; and fix it&nbsp;properly.</p>
<h4>Refcounting to the&nbsp;rescue</h4>
<p>Adding <code>clone()</code> willy-nilly to make the code compile is a valid workaround when we&#8217;re just learning. Sometimes, however,
even some gratuitous cloning doesn&#8217;t <em>quite</em> solve the problem, because the <code>clone()</code> itself can become an&nbsp;issue.</p>
<p>For one, it requires our objects to implement the <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code> trait</a>.
This was apparent even in our previous example, since we had to add a <code>#[derive(Clone)]</code> attribute to the <code>struct Error</code>
in order to make it <code>clone</code>-able.</p>
<p>Fortunately, in the vast majority of cases this will be all that&#8217;s necessary, as most built-in types in Rust implement
<code>Clone</code> already. One notable exception are <em>function traits</em> (<code>FnOnce</code>, <code>Fn</code>, and <code>FnMut</code>) which are used to store
and refer to <em>closures</em><sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>. Structures and other custom types that contain them (or those which <em>may</em> contain them)
cannot therefore implement <code>Clone</code> through a simple <code>#[derive]</code> annotation:</p>
<div class="highlight"><pre><span class="c-Doc">/// A value that&#39;s either there already</span>
<span class="c-Doc">/// or can be obtained by calling a function.</span>
<span class="cp">#[derive(Clone)]</span><span class="w"></span>
<span class="k">enum</span><span class="w"> </span><span class="n">LazyValue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="nb">Clone</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Immediate</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">Deferred</span><span class="p">(</span><span class="n">Fn</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<!-- -->

<div class="highlight"><pre>error: the trait `core::marker::Sized` is not implemented for the type `core::ops::Fn() -&gt; T + &#39;static` [E0277]
    #[derive(Clone)]
             ^~~~~
</pre></div>


<p>What can we do in this case, then? Well, there is yet another kind of performance concessions we can make,
and this one will likely sound familiar if you&#8217;ve ever worked with a higher level language before. Instead of actually
cloning an object, you can merely increment its <em>reference counter</em>. As the most rudimentary kind of garbage collection,
this allows to safely share the object between multiple &#8220;owners&#8221;, where each can behave as if it had
its own copy of&nbsp;it.</p>
<p>Rust&#8217;s pointer type that provides reference counting capabilities is called <code>std::rc::Rc</code>. Conceptually, it is analogous
to <code>std::shared_ptr</code> from C++, and it similarly keeps the refcount updated when the pointer is &#8220;acquired&#8221; (<code>clone</code>-ed)
and &#8220;released&#8221; (<code>drop</code>-ed). Because no data is moved around during either of those two operations, <code>Rc</code> can refer even
to types whose size isn&#8217;t known at compilation time, like abstract&nbsp;closures:</p>
<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">rc</span><span class="o">::</span><span class="n">Rc</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[derive(Clone)]</span><span class="w"></span>
<span class="k">enum</span><span class="w"> </span><span class="n">LazyValue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="nb">Clone</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Immediate</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">Deferred</span><span class="p">(</span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">Fn</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Wrapping them in <code>Rc</code> therefore makes them &#8220;cloneable&#8221;. They aren&#8217;t actually cloned, of course, but because of
the inherent immutability of Rust types they will appear so to any outside observer<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>.</p>
<h4>Move&nbsp;it!</h4>
<p>Ultimately, most problems with the borrow checker boil down to unskillful mixing of the two ways you handle data in Rust.
There is <em>ownership</em>, which is passed around by moving the values; and there is <em>borrowing</em>, which means operating
on them through&nbsp;references.</p>
<p>When you try to switch from one to the other, some friction is bound to occur. Code that uses references, for example,
has to be copiously sprinkled with <code>&amp;</code> and <code>&amp;mut</code>, and may sometimes require explicit lifetime annotations. All these
have to be added or removed, and changes like that tend to propagate quite readily to the upper layers
of the program&#8217;s&nbsp;logic.</p>
<p>Therefore it is generally preferable, if at all possible, to deal with data directly
and not through references. To maintain efficiency, however, we need to learn how to move the objects through the various
stages of our algorithms. It turns out it&#8217;s surprisingly easy to inadvertently borrow something, hindering the possibility
of producing a moved&nbsp;value.</p>
<p>Take our first example. The intuitively named <code>Vec::iter</code> method produces an iterator that we can <code>map</code> over, but does
it really go over the actual <em>items</em> in the vector? Nope! It gives us a <em>reference</em> to each one &#8212; a borrow, if you will
&#8212; which is exactly why we originally had to use <code>clone</code> to get out of this&nbsp;bind.</p>
<p>Instead, why not just get the elements themselves, by moving them out of the vector? <code>Vec::into_iter</code> allows to do exactly&nbsp;this:</p>
<div class="highlight"><pre><span class="nb">Ok</span><span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">r</span><span class="o">|</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">ok</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()).</span><span class="n">collect</span><span class="p">())</span><span class="w"></span>
</pre></div>


<p>and enables us to remove the <code>clone()</code> call. The family of similar <code>into_X</code> (or even just <code>into</code>) methods can be reliably counted
on at least in the standard library. They are also part of a more-or-less official
<a href="https://aturon.github.io/style/naming.html#conversions">naming convention</a> that you should also follow in your own&nbsp;code.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Note how this is different from function <em>types</em>, i.e. <code>fn(A, B, C, ...) -&gt; Ret</code>. It is because plain functions
do not carry their closure environments along with them. This makes them little more than just pointers to some code,
and those can be freely <code>Clone</code>-d (or even <code>Copy</code>-ed).&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>If you want both shared ownership (&#8220;fake cloneability&#8221;) <em>and</em> the ability to mutate the shared value,
take a look at the <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code> type</a> and how it can be
<a href="http://doc.rust-lang.org/nightly/book/choosing-your-guarantees.html#composition">wrapped in <code>Rc</code></a> to achieve both.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/rust-borrowchk-tricks.html#rust-borrowchk-tricks">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-move-out-of-container.html#rust-move-out-of-container">Moving out of a container in&nbsp;Rust</a></h2>
    <p>
      Posted on Fri 05 February 2016 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/vector.html">vector</a>,      <a href="http://xion.io/tag/borrow-checker.html">borrow checker</a>,      <a href="http://xion.io/tag/references.html">references</a>      &#8226; <a href="http://xion.io/post/code/rust-move-out-of-container.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>To prevent the kind of memory errors that plagues many C programs,
the <a href="https://doc.rust-lang.org/book/ownership.html"><em>borrow checker</em> in Rust</a> tracks how data is moved between variables,
or accessed via references. This is all done at compile time, with zero runtime overhead, and is a sizeable part
of Rust&#8217;s value&nbsp;offering.</p>
<p>Like all rigid and automated systems, however, it is necessarily constrained and cannot handle all situations perfectly.
One of its limitations is treating all objects as <em>atomic</em>. It&#8217;s impossible for a variable to own a part of some bigger
structure, neither is it possible to maintain mutable references to two or more elements of a&nbsp;collection.</p>
<p>If we nonetheless <a href="http://is.gd/yWCYmJ">try</a>:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">get_name</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="s">&quot;John&quot;</span><span class="p">.</span><span class="n">to_owned</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;Smith&quot;</span><span class="p">.</span><span class="n">to_owned</span><span class="p">()];</span><span class="w"></span>
<span class="w">    </span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">names</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">join</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="n">String</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>we&#8217;ll be served with a classic borrow checker&nbsp;error:</p>
<div class="highlight"><pre>&lt;anon&gt;:3:25: 3:33 error: cannot move out of indexed content [E0507]
&lt;anon&gt;:3     let fullname = join(names[0], names[1]);
                                 ^~~~~~~~
</pre></div>


<p>Behind its rather cryptic verbiage, it informs us that we tried to move a <em>part</em> of the <code>names</code> vector &#8212; its first
element &#8212; to a new variable (here, a function parameter). This isn&#8217;t allowed, because in principle it would
render the vector invalid from the standpoint of strict memory safety. Rust would no longer guarantee <code>names[0]</code> to be
a legal <code>String</code>: its internal pointer could&#8217;ve been invalidated by the code which the element moved to
(the <code>join</code> function)<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>.</p>
<p>But while commendable, this guarantee isn&#8217;t exactly <em>useful</em> here. Even though <code>names[0]</code> would technically be invalid,
there isn&#8217;t anyone to actually notice this fact. The <code>names</code> vector is inaccessible outside of the function
it&#8217;s defined in, and even the function itself doesn&#8217;t look at it after the move. In its present form,
the program <del>is inarguably correct</del><sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup> could&#8217;ve been accepted if partial moves from <code>Vec</code> were allowed
by the borrow&nbsp;checker.</p>
<h4>Pointers to the&nbsp;rescue?</h4>
<p>Vectors wouldn&#8217;t be very useful or efficient, though, if we could only obtain <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">copies</a> or <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">clones</a> of their elements.
As this is an inherent limitation of Rust&#8217;s memory model, and applies to <em>all</em> compound types
(structs, hashmaps, etc.), it&#8217;s been recognized and countermeasures are&nbsp;available.</p>
<p>However, the <a href="http://is.gd/o3GRnw">idiomatic practice</a> is to actually leave the elements be and access them
solely through&nbsp;references:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">get_name</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="s">&quot;John&quot;</span><span class="p">.</span><span class="n">to_owned</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;Smith&quot;</span><span class="p">.</span><span class="n">to_owned</span><span class="p">()];</span><span class="w"></span>
<span class="w">    </span><span class="n">join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">names</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">join</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">String</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>The obvious downside of this approach is that it requires an interface change to <code>join</code>: it now has to accept
pointers instead of actual objects<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>. And since the result is a completely new <code>String</code>, we have to either bite
the bullet and <code>clone</code>, or write a more awkward <code>join_into(a: &amp;mut String, b: &amp;String)</code> function.<br/>
In general, making an <span class="caps">API</span> switch from actual objects to references has an annoying tendency to percolate up
the call stacks and abstraction&nbsp;layers.</p>
<h4>Vector&nbsp;solution</h4>
<p>If we still insist on moving the elements out, at least in case of vector we aren&#8217;t <em>completely</em> out of luck.
The <code>Vec</code> type offers several specialized methods that can slice, dice, and splice the collection in various ways.
Those&nbsp;include:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.split_first"><code>split_first</code></a> (and <code>split_first_mut</code>)
for cutting right after the first&nbsp;element</li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.split_last"><code>split_last</code></a> (and <code>split_last_mut</code>)
for a similar cut right before the last&nbsp;element</li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.split_at"><code>split_at</code></a> (and <code>split_at_mut</code>),
generalized versions of the above&nbsp;methods</li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.split_off"><code>split_off</code></a>, a partially-in-place version
of <code>split_at_mut</code></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.drain"><code>drain</code></a> for moving all elements from a specified&nbsp;range</li>
</ul>
<p>Other types may offer different methods, depending on their particular data layout, though <code>drain</code> should be available
on any data structure that can be iterated&nbsp;over.</p>
<h4>Structural&nbsp;advantage</h4>
<p>What about user-defined types, such as <code>struct</code>s?</p>
<p>Fortunately, these are covered by the compiler itself. Since accessing <code>struct</code> fields is a fully compile-time
operation, it is possible to track the ownership of each individual object that makes up the structure.
Thus there are no obstacles to simply <a href="http://is.gd/ZUI2Mn">moving all the fields</a>:</p>
<div class="highlight"><pre><span class="k">struct</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">first_name</span><span class="o">:</span><span class="w"> </span><span class="n">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">last_name</span><span class="o">:</span><span class="w"> </span><span class="n">String</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">get_name</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Person</span><span class="p">{</span><span class="n">first_name</span><span class="o">:</span><span class="w"> </span><span class="s">&quot;John&quot;</span><span class="p">.</span><span class="n">to_owned</span><span class="p">(),</span><span class="w"></span>
<span class="w">                   </span><span class="n">last_name</span><span class="o">:</span><span class="w"> </span><span class="s">&quot;Smith&quot;</span><span class="p">.</span><span class="n">to_owned</span><span class="p">()};</span><span class="w"></span>
<span class="w">    </span><span class="n">join</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first_name</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">last_name</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<h4>If all else&nbsp;fails&#8230;</h4>
<p>This leaves us with some rare cases when the container&#8217;s interface doesn&#8217;t <em>quite</em> support the exact subset of elements
we want to move out. If we don&#8217;t want to <code>drain</code> them all and inspect every item for potential preservation,
it may be time to skirt around the more dangerous areas of the&nbsp;language.</p>
<p>But I don&#8217;t necessarily mean going all out with <code>unsafe</code> blocks, pointers, and (let&#8217;s be honest) segfaults.
Instead, we can look at the gray zone between them and the regular, borrow-checked Rust&nbsp;code.</p>
<p>Some of the functions inside the <a href="https://doc.rust-lang.org/std/mem/index.html"><code>std::mem</code> module</a> can be said
to fall into this category. Most notably, <a href="https://doc.rust-lang.org/std/mem/fn.swap.html"><code>mem::swap</code></a> and
<a href="https://doc.rust-lang.org/std/mem/fn.replace.html"><code>mem::replace</code></a> allow us to operate directly on the memory blocks
that back every Rust object, albeit without the dangerous ability to freely modify&nbsp;them.</p>
<p>What those functions enable is a small sleight of hand &#8212; a quick exchange of two variables or objects
while the borrow checker &#8220;isn&#8217;t looking&#8221;. Possessing such an ability, we can smuggle any item out of a container
as long as we&#8217;re able to provide a suitable&nbsp;replacement:</p>
<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">mem</span><span class="p">;</span><span class="w"></span>

<span class="c-Doc">/// Pick only the items under indices that are powers of two.</span>
<span class="k">fn</span><span class="w"> </span><span class="n">pick_powers_of_2</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="nb">Default</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vec</span><span class="o">::</span><span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mem</span><span class="o">::</span><span class="n">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">T</span><span class="o">::</span><span class="n">default</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="n">result</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">result</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p style="text-align: center">
    <img src="http://xion.io/images/indyswap.jpg" alt="Swap!"></br>
    <small>Pictured: implementation of <code>mem::replace</code>.</small>
</p>

<p><a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default">The <code>Default</code> value</a>,
if available, is usually a great choice here. Alternately, a <code>Copy</code> or <code>Clone</code> of some other element can also work
if it&#8217;s cheap to&nbsp;obtain.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>In Rust jargon, it is sometimes said that the object has been &#8220;consumed&#8221; there.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>As <a href="https://www.reddit.com/r/rust/comments/4cbc4u/moving_out_of_a_container_in_rust/d1gx9tb">/u/Gankro points out</a>
on <a href="https://reddit.com/r/rust">/r/rust</a>, since <code>Vec</code> isn&#8217;t a part of the language itself,
it doesn&#8217;t get to bend the borrow checking rules. Therefore speaking of counterfactual correctness
is a bit too far-fetched in this case.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>For <code>String</code>s specifically, the usual practice is to require a more generic <code>&amp;str</code> type (string slice)
instead of <code>&amp;String</code>.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/rust-move-out-of-container.html#rust-move-out-of-container">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-first-impressions.html#rust-first-impressions">Rust: first&nbsp;impressions</a></h2>
    <p>
      Posted on Thu 10 December 2015 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/pointers.html">pointers</a>,      <a href="http://xion.io/tag/types.html">types</a>,      <a href="http://xion.io/tag/fp.html">FP</a>,      <a href="http://xion.io/tag/oop.html">OOP</a>,      <a href="http://xion.io/tag/traits.html">traits</a>      &#8226; <a href="http://xion.io/post/code/rust-first-impressions.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>Having recently been writing some C++ code at work, I had once again experienced the kind of exasperation that this
cumbersome language evokes on regular basis. When I was working in it less sporadically, I was shrugging it off
and telling myself it&#8217;s all because of the low level it operates on. Superior performance was the other side of the deal,
and it was supposed to make all the trade-offs&nbsp;worthwhile.</p>
<p>Now, however, I realized that running close to the metal by no means excuses the sort of clunkiness that C++ permits.
For example, there really is no reason why the archaically asinine separation of header <span class="amp">&amp;</span> source files &#8212;
with its inevitable redundancy of declarations and definitions, worked around with Java-esque contraptions such as
<a href="http://c2.com/cgi/wiki?PimplIdiom">pimpl</a> &#8212; is still the bread and butter of C++ programs.<br/>
Same goes for the lack of sane dependency management, or a universal, portable build system. None of those would be
at odds with native compilation to machine code, or runtime speeds that are adequate for real-time&nbsp;programs.</p>
<p>Rather than dwelling on those gripes, I thought it&#8217;d be more productive to look around and see what&#8217;s
the modern offerring in the domain of lower level, <em>really</em> fast languages. The search wasn&#8217;t long at all, because
right now it seems there is just one viable contender: Rust<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>.</p>
<h4>Rusty&nbsp;systems</h4>
<p><a href="https://www.rust-lang.org">Rust</a> introduces itself as a
<a href="https://en.wikipedia.org/wiki/System_programming_language">&#8220;systems programming language&#8221;</a>, which is quite a bold claim.
What followed the last time this phrase has been applied to an emerging language &#8212; Go &#8212; was a kind of
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">word twisting</a>
that&#8217;s more indicative of politics, not computer&nbsp;science.</p>
<p>But Rust&#8217;s pretense to the system level is well justified. It clearly provides the requisite toolkit for working
directly with the hardware, be it <a href="https://github.com/miselin/rustic">embedded controllers</a> or
<a href="http://www.redox-os.org/">fully featured computers</a>. It offers compilation to native machine code;
direct memory access; running time guarantees thanks to the lack of <span class="caps">GC</span>-incuded stops;
and great interoperability through static and dynamic&nbsp;linkage.</p>
<p>In short, with Rust you can wreak havoc against the <span class="caps">RAM</span> and twiddle bits to your heart&#8217;s&nbsp;content.</p>
<h4>Safe and&nbsp;sound</h4>
<p>To be fair, though, the &#8220;havoc&#8221; part is not entirely accurate. Despite its focus on the low level, efficient computing,
Rust aims to be a very safe language. Unlike C, it actively tries to prevent the programmer from shooting themselves
in the foot &#8212; though it will hand you the gun if you but ask for&nbsp;it.</p>
<p>The safety guarantees provided by Rust apply to resource management, with the specific emphasis on memory
and pointers to it. The way that most contemporary languages deal with memory is by introducing a <em>garbage collector</em>
which mostly (though not wholly) relieves the programmer from thinking about allocations and deallocations.
However, the kind of global, stop-the-world garbage collections
(e.g. <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Na.C3.AFve_mark-and-sweep">mark-and-sweep</a>)
is costly and unpredictable, ruling it out as a mechanism for real-time&nbsp;systems.</p>
<p>For this reason, Rust doesn&#8217;t mandate a <span class="caps">GC</span> of this kind<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>. And although it offers mechanisms that are similar to
smart pointers from C++ (e.g. <code>std::shared_ptr</code>), it is actually preferable and <em>safer</em> to use regular, &#8220;naked&#8221; pointers:
<code>&amp;Foo</code> versus <code>Cell&lt;Foo&gt;</code> or <code>RefCell&lt;Foo&gt;</code> (which are some of the Rust&#8217;s &#8220;smart pointer&#8221;&nbsp;types).</p>
<p>The trick is in the clever compiler. As long as we use regular pointers, it is capable of detecting potential memory
bugs at <em>compilation time</em>. They are referred to as &#8220;data races&#8221; in Rust&#8217;s terminology, and include
<a href="https://doc.rust-lang.org/stable/book/references-and-borrowing.html#issues-borrowing-prevents">perennial problems</a>
that will segfault any C code which wasn&#8217;t written with utmost&nbsp;care.</p>
<p>Part of those safety guarantees is also the <em>default immutability</em> of references (pointers). The simplest reference
of type <code>&amp;Foo</code> in Rust translates to something like <code>const Foo * const</code> in C<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>. You have to explicitly request
mutability with the <code>mut</code> keyword, and Rust ensures there is always at most one mutable reference to any value,
thus preventing problems caused by <a href="https://en.wikipedia.org/wiki/Pointer_aliasing">pointer aliasing</a>.</p>
<p>But what if you really must sling raw pointers, and access arbitrary memory locations? Maybe you are programming
a microcontroller where I/O is done through a special memory region. For those occasions, Rust has got you covered
with the <code>unsafe</code> keyword:</p>
<div class="highlight"><pre><span class="c1">// Read the state of a diode in some imaginary uC.</span>
<span class="k">fn</span><span class="w"> </span><span class="n">get_led_state</span><span class="p">(</span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="n">isize</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;There are FOUR lights!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="o">:</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1234</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w">  </span><span class="c1">// known memory location</span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Its usage, like in the above example, can be <em>very</em> localized, limited only to those places where it&#8217;s truly necessary
and guarded by the appropriate checks. As a result, the interface exposed by the above function
can be considered safe. The unrestricted memory access can be contained to where it&#8217;s really&nbsp;inevitable.</p>
<h4>Typing&nbsp;counts</h4>
<p>Ensuring memory safety is not the only way in which Rust differentiates itself from C.
What separates those two languages is also a few decades of practice and research into programming semantics.
It&#8217;s only natural to expect Rust to take advantage of this&nbsp;progress.</p>
<p>And advantage it takes. Although Rust&#8217;s type system isn&#8217;t nearly as advanced and complex like &#8212; say &#8212; Scala&#8217;s,
it exhibits several interesting properties that are indicative of its relatively modern&nbsp;origin.</p>
<p>First, it mixes the two most popular programming paradigms &#8212; functional and object-oriented &#8212; in roughly equal
concentrations, as opposed to being biased towards the latter. Rust doesn&#8217;t have interfaces or classes: it has <em>traits</em>
and their <em>implementations</em>. Even though they often fulfill similar purposes of abstraction and encapsulation,
these constructs are closer to the concepts of <a href="https://en.wikipedia.org/wiki/Type_class">type classes</a>
and their instances, which are found for example in&nbsp;Haskell.</p>
<p>Still, the more familiar notions of <span class="caps">OOP</span> aren&#8217;t too far off. Most of the key functionality of classes, for example,
can be simulated by implementing &#8220;default&#8221; traits for user-defined&nbsp;types:</p>
<div class="highlight"><pre><span class="k">struct</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">first_name</span><span class="o">:</span><span class="w"> </span><span class="n">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">last_name</span><span class="o">:</span><span class="w"> </span><span class="n">String</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">new</span><span class="p">(</span><span class="n">first_name</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">last_name</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Person</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">first_name</span><span class="o">:</span><span class="w"> </span><span class="n">first_name</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"></span>
<span class="w">            </span><span class="n">last_name</span><span class="o">:</span><span class="w"> </span><span class="n">last_name</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">greet</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Hello, {}!&quot;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">first_name</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// usage</span>
<span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Person</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="s">&quot;John&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Doe&quot;</span><span class="p">);</span><span class="w"></span>
<span class="n">p</span><span class="p">.</span><span class="n">greet</span><span class="p">();</span><span class="w"></span>
</pre></div>


<p>The second aspect of Rust&#8217;s type system that we would come to expect from a new language is its expressive power.
<em>Type inference</em> is nowadays a staple, and above we can observe the simplest form of it. But it extends further,
to generic parameters, closure arguments, and closure return&nbsp;values.</p>
<p>Generics, by the way, are quite nice as well. Besides their applicability to structs, type aliases, functions,
traits, trait implementations, etc., they allow for constraining their arguments with traits. This is similar to
the abandoned-and-not-quite-revived-yet idea of <a href="https://en.wikipedia.org/wiki/Concepts_%28C%2B%2B%29">concepts in C++</a>,
or to an analogous mechanism from&nbsp;C#.</p>
<p>The third common trend in contemporary language design is the use of type system to solve common tasks.
Rust doesn&#8217;t go full Haskell and opt for monads for everything, but its <code>Option</code> and <code>Result</code> types are evidently
the functional approach to error handling<sup id="fnref:4"><a class="footnote-ref" href="#fn:4" rel="footnote">4</a></sup>. To facilitate their use, a powerful
<a href="https://doc.rust-lang.org/stable/book/patterns.html"><em>pattern matching</em> facility</a> is also present in&nbsp;Rust.</p>
<h4>Unexpectedly&nbsp;pythonic</h4>
<p>If your general go-to language is Python, you will find Rust a very nice complement and possibly a valuable instrument
in your coding arsenal. Interoperability between Python and Rust is
<a href="https://doc.rust-lang.org/stable/book/rust-inside-other-languages.html#python">stupidly easy</a>,
thanks to both the <a href="https://docs.python.org/3.5/library/ctypes.html"><code>ctypes</code> module</a> and the extreme simplicity
of creating portable,
<a href="https://doc.rust-lang.org/stable/book/rust-inside-other-languages.html#a-rust-library">shared libraries</a> in Rust.
Offloading some expensive, <a href="https://wiki.python.org/moin/GlobalInterpreterLock"><span class="caps">GIL</span></a>-bypassing computation to a fast,
native code written in Rust can thus be a relatively painless way of speeding up crucial parts of a Python&nbsp;program.</p>
<p>But somewhat more surprisingly, Rust has quite a few bits that seem to be directly inspired by Python semantics.
Granted, those two languages are conceptually pretty far apart in general, but the analogies are&nbsp;there:</p>
<ul>
<li>
<p>The concept of <a href="https://doc.rust-lang.org/stable/book/iterators.html">iterators</a> in Rust is very similar to
<a href="https://docs.python.org/2/glossary.html#term-iterable">iterables</a> in Python. Even the <code>for</code> loop is basically identical:
rather than manually increment a counter, both in <a href="https://doc.rust-lang.org/stable/book/loops.html#for">Rust</a>
and <a href="https://wiki.python.org/moin/ForLoop">Python</a> you iterate over a <em>range of numbers</em>.<br/>
Oh, and both languages have an <code>enumerate</code> <a href="https://doc.rust-lang.org/stable/book/loops.html#enumerate">method</a>/
<a href="https://docs.python.org/2/library/functions.html#enumerate">function</a> that yields pairs of <code>(index, element)</code>.</p>
</li>
<li>
<p>Syntax for <a href="https://doc.rust-lang.org/stable/book/method-syntax.html#method-calls">method definition</a>
in Rust uses the <code>self</code> keyword as first argument to distinguish between instance methods and &#8220;class&#8221;/&#8221;static&#8221; methods
(or <em>associated functions</em> in Rust&#8217;s parlance).
This is even more pythonic than in actual Python, where <code>self</code> is technically just a convention,
albeit an extremely strong&nbsp;one.</p>
</li>
<li>
<p>In either language, overloading operators doesn&#8217;t use any new keywords or special syntax,
like it does in C++, C#, and others. Python accomplishes it through <code>__magic__</code> methods, whereas Rust
has very similarly named <a href="https://doc.rust-lang.org/stable/book/operators-and-overloading.html">operator traits</a>.</p>
</li>
<li>
<p>Rust basically <a href="https://doc.rust-lang.org/stable/book/documentation.html#documentation-as-tests">has <code>doctest</code></a>.
If you don&#8217;t know, the <a href="https://docs.python.org/2/library/doctest.html"><code>doctest</code> module</a> is a standard Python testing
utility that can run usage examples found in documentation comments and verify their correctness. Rust version (<code>rustdoc</code>)
is even more powerful and flexible, allowing for example to mark additional boilerplate lines that should be run
when testing examples, but <em>not</em> included in the generated&nbsp;documentation.</p>
</li>
</ul>
<p>I&#8217;m sure the list doesn&#8217;t end here and will grow over time. As of this writing, for example, nightly builds of Rust
already offer <a href="https://doc.rust-lang.org/stable/book/slice-patterns.html">advanced slice pattern matching</a> which are
very similar to the <a href="https://www.python.org/dev/peps/pep-3132/">extended iterable unpacking</a> from Python&nbsp;3.</p>
<h4>Is it worth&nbsp;it?</h4>
<p>Depending on your background and the programming domain you are working in, you may be wondering if Rust
is a language that&#8217;s worth looking into now, or in the near&nbsp;future.</p>
<p>Firstly, let me emphasize that it&#8217;s still in its early stages. Although the stable version 1.0 has been released
<a href="http://blog.rust-lang.org/2015/05/15/Rust-1.0.html">a good couple of months ago</a>, the ecosystem isn&#8217;t nearly as diverse
and abundant as in some of the other new&nbsp;languages.</p>
<p>If you are specifically looking to deploying Rust-written <span class="caps">API</span> servers, backends, and other &#8212; shall I use the word
&#8212; microservices, then right now you&#8217;ll probably be better served by more established solutions,
like Java with <a href="http://docs.paralleluniverse.co/quasar/">fibers</a>, asynchronous Python on PyPy, Erlang,
Go, node.js, or similar.
I predict Rust catching up here in the coming months, though, because the prospect of writing native speed <span class="caps">JSON</span> slingers
with relative ease is just too compelling to&nbsp;pass.</p>
<p>The other interesting area for Rust is <em>game programming</em>, because it&#8217;s one of the few languages capable of supporting
even the most demanding <span class="caps">AAA</span>+ productions. The good news is that portable, open source
<a href="http://www.piston.rs/">game engines</a> are already here. The bad news is that most of the existing knowledge
about designing and coding high performance games is geared towards writing (stripped down) C++. The community
is also rather <del>stubborn</del> reluctant to adopt anything that may carry even a <em>hint</em> of potentially unknown
performance implications. Although some inroads have been made (here&#8217;s, for example,
an <a href="https://github.com/HeroesGrave/ecs-rs">entity component system</a> written in Rust), and I wouldn&#8217;t be surprised
to see indie games written in Rust, it probably won&#8217;t take over the industry anytime&nbsp;soon.</p>
<p>When it comes to hardware, though, Rust may already have the upper hand. It is obviously much easier language to program in
than pure C. Along with its toolchain&#8217;s ability to produce
<a href="https://doc.rust-lang.org/stable/book/no-stdlib.html">minimal executables</a>, it makes for a compelling language for
programming microcontrollers and other embedded&nbsp;devices.</p>
<p>So in short, Rust is pretty nice. And if you have read that far, I think you should just go ahead
and <a href="https://www.rust-lang.org/">have a look</a> for yourself&nbsp;:)</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Because as much as we&#8217;d like for <a href="http://dlang.org/">D</a> to finally get <em>somewhere</em>, at this point
we may have better luck waiting for the Year of Linux on Desktop to dawn&#8230;&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Of course, nobody has stopped the community from <a href="https://github.com/Manishearth/rust-gc">implementing it</a>.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>Strictly speaking, it&#8217;s the binding such as <code>let x = &amp;foo;</code> that translates to it. Unadorned C pointer type
<code>Foo*</code> would correspond to mutable binding to a mutable reference in Rust, i.e. <code>let mut x = &amp;mut foo;</code>.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>Their Haskell equivalents are <code>Maybe</code> and <code>Either</code> type classes, respectively.&#160;<a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/rust-first-impressions.html#rust-first-impressions">Continue reading</a>
  </div>
</article>

  <div class="pagination">
  </div>

    <footer>
<p>
  &copy; Karol Kuczmarski 2017 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-27379564-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Karol Kuczmarski's Blog ",
  "url" : "http://xion.io",
  "image": "http://xion.io/logo.jpeg",
  "description": ""
}
</script><script type="text/javascript">
    var disqus_shortname = 'xionblog';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>