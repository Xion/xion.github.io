<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/font-awesome.min.css">

    <link href="http://xion.io/style.css" rel="stylesheet">




  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

    <meta name="author" content="Karol Kuczmarski" />
    <meta name="description" content="" />
<meta property="og:site_name" content="Karol Kuczmarski's Blog"/>
<meta property="og:type" content="blog"/>
<meta property="og:title" content="Karol Kuczmarski's Blog"/>
<meta property="og:description" content=""/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://xion.io"/>
<meta property="og:image" content="http://xion.io/logo.jpeg">

  <title>Karol Kuczmarski's Blog &ndash; Tag: monads</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://xion.io">
        <img src="http://xion.io/logo.jpeg" alt="Karol Kuczmarski" title="Karol Kuczmarski">
      </a>
      <h1><a href="http://xion.io">Karol Kuczmarski</a></h1>
      <p>fn(Tea) -> Code</p>
      <nav>
        <ul class="list">
          <li><a href="http://xion.io/page/about.html#about">About</a></li>
          <li><a href="http://xion.io/page/projects.html#projects">Projects</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-github" href="http://github.com/Xion" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-stack-overflow" href="http://stackoverflow.com/users/434799/xion" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
        <li><a class="sc-twitter" href="http://twitter.com/Xion__" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-google" href="https://plus.google.com/+KarolKuczmarski" target="_blank"><i class="fa fa-google"></i></a></li>
        <li><a class="sc-rss" href="/feeds/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="http://xion.io">Home</a>
      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>
      <a href="http://xion.org.pl/">Old blog</a>
    </nav>

<article>
  <header>
    <h2><a href="http://xion.io/post/code/haskell-printer-monad.html#haskell-printer-monad">The Printer Monad in&nbsp;Haskell</a></h2>
    <p>
      Posted on Fri 04 August 2017 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/haskell.html">Haskell</a>,      <a href="http://xion.io/tag/writer.html">Writer</a>,      <a href="http://xion.io/tag/monads.html">monads</a>,      <a href="http://xion.io/tag/monad-transformers.html">monad transformers</a>,      <a href="http://xion.io/tag/writert.html">WriterT</a>      &#8226; <a href="http://xion.io/post/code/haskell-printer-monad.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>Quite recently, I have encountered an interesting case of monad-based refactoring in&nbsp;Haskell.</p>
<p>Suppose you have a <code>ComplicatedRecord</code>
that holds the results of some lengthy and important process in your program.
You want to present that data to the user in a nicely formatted way,
so you write a function which begins somewhat like&nbsp;this:</p>
<div class="highlight"><pre><span class="cm">{-# LANGUAGE RecordWildcards #-}</span>

<span class="c1">-- | Pretty-print the content of the record.</span>
<span class="nf">ppRecord</span> <span class="ow">::</span> <span class="kt">ComplicatedRecord</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">ppRecord</span> <span class="kt">ComplicatedRecord</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="c1">-- ...</span>
</pre></div>


<p>Inside, there is plenty of <code>putStrLn</code> calls, likely hidden inside more specific subfunctions
that format all the numerous parts of <code>ComplicatedRecord</code>.
But the <code>IO</code> monad isn&#8217;t there just for printing:
because the code went through multiple iterations,
some of this logic actually takes advantage of it by making additional system <span class="amp">&amp;</span> network&nbsp;calls.</p>
<p>So yeah, it&#8217;s not particularly&nbsp;pretty.</p>
<p>Now, however, we find out that the output we&#8217;re printing here
shouldn&#8217;t <em>always</em> go directly to stdout.
In some cases, unsurprisingly, we actually want it back as a single string,
without having it sent to the standard output at&nbsp;all.</p>
<h4>Just $ return .&nbsp;it</h4>
<p>Your first instinct here may be to simply give back the final string (well, <code>Text</code>)
as the function result<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>:</p>
<div class="highlight"><pre><span class="nf">ppRecord</span> <span class="ow">::</span> <span class="kt">ComplicatedRecord</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Text</span>
</pre></div>


<p>However, this turns out to be rather awkward.
While in most other languages
we would simply accumulate output by progressively adding more data to a mutable result,
this would be much more inconvenient (and somewhat weird) to do in&nbsp;Haskell.</p>
<p>This is where the stdout-based approach seems cleaner;
instead of straightforward, sequential code like&nbsp;this:</p>
<div class="highlight"><pre><span class="cm">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kr">import</span> <span class="nn">Control.Monad.Extra</span> <span class="p">(</span><span class="nf">whenJust</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Text.IO</span>
<span class="kr">import</span> <span class="nn">TextShow</span>

<span class="nf">ppOrder</span> <span class="kt">Order</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;Order #&quot;</span> <span class="o">&lt;&gt;</span> <span class="n">ordNumber</span>
    <span class="n">ppAddress</span> <span class="n">ordDeliveryAddress</span>
    <span class="n">forM_</span> <span class="p">(</span><span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="n">ordItems</span><span class="p">)</span> <span class="o">$</span> <span class="nf">\</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="kt">Item</span><span class="p">{</span><span class="o">..</span><span class="p">})</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">showt</span> <span class="p">(</span><span class="n">i</span><span class="ow">::</span><span class="kt">Int</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="s">&quot;. &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">itName</span> <span class="o">&lt;&gt;</span> <span class="s">&quot; x&quot;</span> <span class="o">&lt;&gt;</span> <span class="n">showt</span> <span class="n">itQuantity</span>
    <span class="n">whenJust</span> <span class="n">ordBillingAddress</span> <span class="n">ppAddress</span>

<span class="nf">ppAddress</span> <span class="kt">Address</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">addrFirstName</span> <span class="o">&lt;&gt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">addrLastName</span>
    <span class="n">putStrLn</span> <span class="n">addrLine1</span>
    <span class="n">whenJust</span> <span class="n">addrLine2</span> <span class="n">putStrLn</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">addrCity</span> <span class="o">&lt;&gt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">addrPostalCode</span>
</pre></div>


<p>we have to overhaul each function and turn it into a much less pleasant &#8220;<code>mappend</code>age&#8221;:</p>
<div class="highlight"><pre><span class="nf">ppOrder</span> <span class="kt">Order</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="n">unlines</span> <span class="o">$</span> <span class="n">mconcat</span>
    <span class="p">[</span> <span class="s">&quot;Order #&quot;</span> <span class="o">&lt;&gt;</span> <span class="n">ordNumber</span>
    <span class="p">,</span> <span class="n">ppAddress</span> <span class="n">ordDeliveryAddress</span>
    <span class="p">,</span> <span class="n">ppItems</span> <span class="n">ordItems</span>
    <span class="p">]</span> <span class="o">+</span> <span class="n">maybe</span> <span class="kt">[]</span> <span class="p">(</span><span class="nf">\</span><span class="n">addr</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">ppAddress</span> <span class="n">addr</span><span class="p">])</span> <span class="n">ordBillingAddress</span>
    <span class="kr">where</span>
    <span class="n">ppItems</span> <span class="ow">=</span> <span class="n">mconcat</span> <span class="o">.</span> <span class="n">map</span> <span class="p">(</span><span class="n">uncurry</span> <span class="n">ppItem</span><span class="p">)</span> <span class="o">.</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
    <span class="n">ppItem</span> <span class="n">i</span> <span class="kt">Item</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="n">showt</span> <span class="n">i</span> <span class="o">&lt;&gt;</span> <span class="s">&quot;. &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">itName</span> <span class="o">&lt;&gt;</span> <span class="s">&quot; x&quot;</span> <span class="o">&lt;&gt;</span> <span class="n">itQuantity</span>
</pre></div>


<p>One may argue that this is, in fact, the more idiomatic approach,
but I&#8217;m not very fond of all those commas.
Plus, it shows rather clearly that any conditional logic (like with <code>ordBillingAddress</code> here)
is going to get pretty&nbsp;cumbersome.</p>
<h4>Along comes the <code>Writer</code></h4>
<p>What I&#8217;m saying here is that even in pure code,
it is sometimes very desirable to have a <code>do</code> notation.
For that, however, we need a suitable <code>Monad</code><sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup> to provide the meaning of &#8220;invisible semicolon&#8221; in a <code>do</code> block.</p>
<p>And <code>Text</code>, obviously, isn&#8217;t one.
Neither is <code>[Text]</code> (lines of text),
nor any other type we&#8217;d use to represent the final output of formatting <span class="amp">&amp;</span> printing.
They are unsuitable, because they cannot encode the <em>computation</em> that eventually produces said output &#8212;
either the top-level one (<code>ppRecord</code>) or any of its building blocks (like the <code>ppOrder</code> or <code>ppAddress</code>),
down to a most elementary <code>putStrLn</code>.
The only thing they can stand for is the result&nbsp;itself.</p>
<p>Fortunately, the pattern of executing code and occassionally producing some &#8220;additional&#8221; output
has been abstracted over in the Haskell standard library.
This is exactly the use case for the <code>Writer</code> monad!</p>
<p>The definition of <code>Writer</code> is roughly equivalent to the&nbsp;following:</p>
<div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">Writer</span> <span class="n">w</span> <span class="n">a</span> <span class="ow">=</span> <span class="o">...</span> <span class="c1">-- omitted</span>
</pre></div>


<p>Of the two type parameters it takes, the <code>w</code> one signifies what output it can produce &#8220;on the side&#8221;.
This is contrasted with <code>a</code> which is the regular result of a monadic expression or function.
In our case, <code>a</code> will basically always be <code>()</code> (unit/&#8221;empty&#8221; type),
but it is nonetheless necessary for the <code>Writer</code> to behave as a&nbsp;monad.</p>
<p>To complement the above definition, <code>Writer</code> comes with several useful functions.
Among those, the most interesting one is <code>tell</code>:</p>
<div class="highlight"><pre><span class="nf">tell</span> <span class="ow">::</span> <span class="n">w</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="n">w</span> <span class="nb">()</span>
</pre></div>


<p><code>write</code> would&#8217;ve probably been a better name for it,
as it&#8217;s definitely the main and defining operation of <code>Writer</code>.</p>
<p>Looking at its signature, we can see it takes a bit of the <code>Writer</code><span class="quo">&#8216;</span>s output (<code>w</code>)
and results in a <code>Writer</code> action.
Internally, it will simply add the argument to the already accumulated output of the writer<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>.</p>
<p>To make everything more concrete,
here&#8217;s a literal &#8220;Hello world&#8221; example coded very verbosly as a <code>Writer</code> action:</p>
<div class="highlight"><pre><span class="kr">import</span> <span class="nn">Control.Monad.Writer</span>

<span class="nf">hello</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">hello</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">tell</span> <span class="s">&quot;Hello&quot;</span>
    <span class="n">tell</span> <span class="s">&quot; &quot;</span>
    <span class="n">tell</span> <span class="s">&quot;world&quot;</span>

<span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="n">greeting</span><span class="p">)</span> <span class="ow">=</span> <span class="n">runWriter</span> <span class="n">hello</span>
    <span class="kt">Text</span><span class="o">.</span><span class="n">putStrLn</span> <span class="n">greeting</span>
</pre></div>


<p>It also contains the last element of the <code>Writer</code> puzzle:</p>
<div class="highlight"><pre><span class="nf">runWriter</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="n">w</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>


<p>Like its name suggests, this function will &#8220;run&#8221; any <code>Writer</code> action that we give it,
returning both the &#8220;regular&#8221; result (<code>a</code>) plus any output passed in <code>tell</code>s (<code>w</code>).<sup id="fnref:4"><a class="footnote-ref" href="#fn:4" rel="footnote">4</a></sup></p>
<h4>My little monad: transformers are&nbsp;magic</h4>
<p>The last example may be very simple,
but it contains all the building blocks for many of the printing functions we need.
If we define a convenience wrapper for <code>tell</code>:</p>
<div class="highlight"><pre><span class="nf">putLn</span> <span class="ow">::</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">putLn</span> <span class="n">line</span> <span class="ow">=</span> <span class="n">tell</span> <span class="o">$</span> <span class="n">line</span> <span class="o">&lt;&gt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
</pre></div>


<p>then both <code>ppAddress</code> and <code>ppOrder</code> can be translated
through a mere mechanical substitution of <code>putStrLn</code> with <code>putLn</code>:</p>
<div class="highlight"><pre><span class="nf">ppAddress</span> <span class="kt">Address</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">putLn</span> <span class="o">$</span> <span class="n">addrFirstName</span> <span class="o">&lt;&gt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">addrLastName</span>
    <span class="n">putLn</span> <span class="n">addrLine1</span>
    <span class="n">whenJust</span> <span class="n">addrLine2</span> <span class="n">putLn</span>
    <span class="n">putLn</span> <span class="o">$</span> <span class="n">addrCity</span> <span class="o">&lt;&gt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">addrPostalCode</span>

<span class="c1">-- ppOrder omitted</span>
</pre></div>


<p>Unfortunately, a bare <code>Writer</code> like this can only work for pure code,
which isn&#8217;t a luxury we can expect in every situtation.
In my case, some of the printing logic was tied pretty strongly to <code>IO</code>,
and it would be difficult and time consuming to decouple&nbsp;it.</p>
<p>Thankfully, the reliance on <code>IO</code> isn&#8217;t a complete deal breaker.
While we cannot ensure that nothing calls <code>putStrLn</code> anymore,
we can provide the <code>tell</code>/<code>putLn</code> capabilities alongside whatever <em>other</em> <code>IO</code> calls
our code has to make (for&nbsp;now).</p>
<p>To achieve that, we need to create a <em>monad stack</em> with <code>WriterT</code>:</p>
<div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">WriterT</span> <span class="n">w</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">=</span> <span class="o">...</span> <span class="c1">-- omitted</span>
</pre></div>


<p><code>WriterT</code> is a <em>monad transformer</em>, one of those scary Haskell concepts
that are actually simpler than they appear on the surface.
This is because transfomers like <code>WriterT</code> are mere wrappers.
The only difference between it and a regular <code>Writer</code> is the additional <code>m</code> parameter,
which is the <em>inner monad</em> we&#8217;re packaging inside a new <code>Writer</code>.</p>
<p>Here (and in many other cases), <code>m</code> will be substituted with <code>IO</code>:</p>
<div class="highlight"><pre><span class="kr">type</span> <span class="kt">Printer</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">WriterT</span> <span class="kt">Text</span> <span class="kt">IO</span> <span class="n">a</span>  <span class="c1">-- w == Text, m == IO</span>
</pre></div>


<p>thus creating the titular <code>Printer</code> monad.
This hybrid beast can both output <code>Text</code> through the <code>Writer</code> <span class="caps">API</span>,
as well as perform any additional <code>IO</code> operations
that the code may (still)&nbsp;require.</p>
<p>Below is an example;
the <code>User</code> record requires an I/O call to get the size of its <code>$HOME</code> directory:</p>
<div class="highlight"><pre><span class="kr">import</span> <span class="nn">Control.Monad.IO.Class</span> <span class="p">(</span><span class="nf">liftIO</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">System.Directory</span> <span class="p">(</span><span class="nf">getFileSize</span><span class="p">)</span>

<span class="c1">-- To print this data type nicely, we sadly require I/O :(</span>
<span class="kr">data</span> <span class="kt">User</span> <span class="ow">=</span> <span class="kt">User</span> <span class="p">{</span> <span class="n">usrName</span> <span class="ow">::</span> <span class="kt">Text</span>
                 <span class="p">,</span> <span class="n">usrHomeDir</span> <span class="ow">::</span> <span class="kt">FilePath</span>
                 <span class="p">}</span>

<span class="nf">ppUser</span> <span class="ow">::</span> <span class="kt">User</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Text</span>
<span class="nf">ppUser</span> <span class="kt">User</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="n">snd</span> <span class="o">&lt;$&gt;</span> <span class="n">runWriterT</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">putLn</span> <span class="o">$</span> <span class="s">&quot;Name: &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">usrName</span>
    <span class="n">homeSize</span> <span class="ow">&lt;-</span> <span class="n">liftIO</span> <span class="o">$</span> <span class="n">getFileSize</span> <span class="n">usrHomeDir</span>
    <span class="n">putLn</span> <span class="o">$</span> <span class="s">&quot;$HOME: &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">showt</span> <span class="n">usrHomeDir</span> <span class="o">&lt;&gt;</span> <span class="s">&quot;(&quot;</span> <span class="o">&lt;&gt;</span> <span class="n">showt</span> <span class="n">homeSize</span> <span class="o">&lt;&gt;</span> <span class="s">&quot; bytes)&quot;</span>
</pre></div>


<p>As a bit of necessary cruft,
we have to use <code>liftIO</code> to &#8220;lift&#8221; (wrap) <code>IO</code> actions such as <code>getFileSize</code>
in a full <code>Printer</code> monad before executing them.
Besides everything else you can think of,
this is yet another argument for eventually getting rid of the <code>IO</code> :)</p>
<h4>Making the monads&nbsp;coexist</h4>
<p>But our job isn&#8217;t done yet.
Despite looking very reasonable, this version of <code>ppUser</code> doesn&#8217;t actually compile!
The actual type error may vary a little,
but it all boils down to a difference between <code>WriterT Text IO ()</code> (i.e. <code>Printer ()</code>)
and <code>Writer Text ()</code> at each call site of <code>putLn</code>.</p>
<p><span class="caps">GHC</span> is obviously correct.
However, the problem lies not in how we&#8217;re calling <code>putLn</code>,
but rather the way it&#8217;s been&nbsp;defined:</p>
<div class="highlight"><pre><span class="nf">putLn</span> <span class="ow">::</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Text</span> <span class="nb">()</span>
</pre></div>


<p>This type can only produce a specific, <em>pure</em> <code>Writer</code> action.
But to fit inside the <code>do</code> block of our compound monad,
we need the <code>Writer</code> + <code>IO</code> combo from <code>WriterT Text IO</code> (i.e. <code>Printer</code>).</p>
<p>We can try to address the mismatch by changing the signature&nbsp;to:</p>
<div class="highlight"><pre><span class="nf">putLn</span> <span class="ow">::</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">WriterT</span> <span class="kt">Text</span> <span class="kt">IO</span> <span class="nb">()</span>  <span class="c1">-- or just: Printer ()</span>
</pre></div>


<p>but this will only result in the <em>opposite</em> problem.
Now, all the pure printers like <code>ppAddress</code> are facing the fact
that <code>putLn</code> is a (wrapped) <code>IO</code> action, despite not actually doing any I/O&nbsp;whatsoever.</p>
<p>The obvious question is, can we have something that fits <em>both</em>?</p>
<p>Earlier on, I&#8217;ve said that both vanilla <code>Writer</code> and the <code>IO</code>-spruced <code>Printer</code> support the &#8220;<code>Writer</code> <span class="caps">API</span>&#8221;,
most notably the <code>tell</code> function.
This notion of a &#8220;monadic interface&#8221; isn&#8217;t just hand-waving, though,
and Haskell (obviously!) provides a way to express it&nbsp;programmatically.</p>
<p>Meet the <code>MonadWriter</code> typeclass:</p>
<div class="highlight"><pre><span class="kr">class</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">w</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MonadWriter</span> <span class="n">w</span> <span class="n">m</span>
</pre></div>


<p>Any monad that can work as a <code>Writer</code> will be an instance of it,
regardless of whether it wraps over <code>IO</code> or anything else.
Functions like <code>tell</code> are defined to be
<a href="http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Writer-Class.html#v:tell">polymorphic over it</a>,
enabling us to leverage the same technique they use when we define <code>putLn</code>:</p>
<div class="highlight"><pre><span class="cm">{-# LANGUAGE FlexibleContexts #-}</span>

<span class="kr">import</span> <span class="nn">Control.Monad.Writer.Class</span>

<span class="nf">putLn</span> <span class="ow">::</span> <span class="kt">MonadWriter</span> <span class="kt">Text</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>
<span class="nf">putLn</span> <span class="n">line</span> <span class="ow">=</span> <span class="n">tell</span> <span class="o">$</span> <span class="n">line</span> <span class="o">&lt;&gt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
</pre></div>


<p>If you aren&#8217;t very familiar with this syntax,
the part before <code>=&gt;</code> is a <em>typeclass constraint</em>, or <em>context</em>.
It defines the requirements to be satisfied by types
which are later used in the function&nbsp;signature.</p>
<p>Here, we request a <code>MonadWriter</code> instance &#8212; one where <code>Text</code> is the output
but <em>anything</em> can be the inner monad.
We refer to that unknown monad only as <code>m</code>, a type variable.
The compiler will figure out what to substitute for it <em>at every call site</em> of <code>putLn</code>.</p>
<p>As a result, both a pure <code>Writer</code> and the <code>IO</code>-bound <code>Printer</code> can now use it.
In the second case, the relevant instance of <code>MonadWriter</code> will,
naturally, have <code>IO</code> fill in the <code>m</code> position.</p>
<p>But curiously, the &#8220;pure&#8221; <code>Writer</code> also has
<a href="http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Functor-Identity.html#t:Identity">an inner monad</a>.
It just literally <em>does nothing</em> but wrap some other&nbsp;value:</p>
<div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">Identity</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Identity</span> <span class="p">{</span> <span class="n">runIdentity</span> <span class="ow">::</span> <span class="n">a</span> <span class="p">}</span>
</pre></div>


<p>In most cases, this fact is hidden behind
<a href="http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Writer-Lazy.html#t:Writer">the real definition of <code>Writer</code></a>,
though <code>runIdentity</code> may sometimes come handy for some on-the-spot type hacks<sup id="fnref:5"><a class="footnote-ref" href="#fn:5" rel="footnote">5</a></sup>.</p>
<h4>The&nbsp;wrap</h4>
<p>The many things we&#8217;ve talked about here could of course be a starting point
for even more advanced stuff, but obviously we have to stop somewhere!
But don&#8217;t worry: knowing about <code>MonadWriter</code> and other monad typeclasses like this
is enough to write quite idiomatic&nbsp;code&#8230;</p>
<p>&#8230;at least until you learn about
<a href="http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html">free monads</a>,
<a href="https://ocharles.org.uk/blog/posts/2013-12-04-24-days-of-hackage-extensible-effects.html">effects</a>,
and the like&nbsp;;-)</p>
<p>In any case, you can check <a href="https://gist.github.com/Xion/74c39b65c591ae9615b7cf81e88a5946">this gist</a>
for the complete code from this&nbsp;post.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p><code>IO</code> is still necessary due to ad-hoc network fetches and syscalls mentioned earlier.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Or at least an <code>Applicative</code>, via the <code>ApplicativeDo</code> <span class="caps">GHC</span> extension.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>The adding is done via <code>mappend</code>, requiring <code>w</code> to be a <code>Monoid</code>.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>There is also the <code>execWriter</code> variant which is actually more practical here
  as it only returns the accumulated output.&#160;<a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:5">
<p>We could, for example, use it alongside <code>mapWriterT</code> to &#8220;fix&#8221; the calls to <code>putLn</code>
  if we didn&#8217;t have control over its definition.&#160;<a class="footnote-backref" href="#fnref:5" rev="footnote" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/haskell-printer-monad.html#haskell-printer-monad">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/programming/rust-into-haskell.html#rust-into-haskell">Rust as a gateway drug to&nbsp;Haskell</a></h2>
    <p>
      Posted on Tue 13 June 2017 in <a href="http://xion.io/category/programming.html">Programming</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/haskell.html">Haskell</a>,      <a href="http://xion.io/tag/traits.html">traits</a>,      <a href="http://xion.io/tag/typeclasses.html">typeclasses</a>,      <a href="http://xion.io/tag/monads.html">monads</a>,      <a href="http://xion.io/tag/adts.html">ADTs</a>,      <a href="http://xion.io/tag/fp.html">FP</a>      &#8226; <a href="http://xion.io/post/programming/rust-into-haskell.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>For work-related reasons,
I had to recently get up to speed on programming in <a href="https://www.haskell.org/">Haskell</a>.</p>
<p>Before that, I had very little actual experience with the language,
clocking probably at less than a thousand lines of working code over a couple of years.
Nothing impressive either:
some <a href="https://gist.github.com/Xion/b8fdb6a896264915ad85">wrapper script</a> here,
some <a href="https://gist.github.com/Xion/1525222">experimental rewrite</a>&nbsp;there&#8230;</p>
<p>These days, I heard, there are a few resources for learning Haskell<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>
that don&#8217;t require having a PhD in category theory<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>.
They may be quite helpful when your exposure to the functional programming is limited.
In my case, however, the one thing that <em>really</em> enabled me to become (somewhat) productive
was not even related to Haskell at&nbsp;all.</p>
<p>It was <a href="http://rust-lang.org/">Rust</a>.</p>
<p>In theory, this shouldn&#8217;t really make much of a sense.
If you compare both languages by putting checkmarks in a feature chart,
you won&#8217;t find them to have much in&nbsp;common.</p>
<p>Some of the obvious differences&nbsp;include:</p>
<ul>
<li>predominantly functional vs. mostly&nbsp;imperative</li>
<li>garbage collection vs. explicit memory&nbsp;management</li>
<li>lazy vs. eager&nbsp;evaluation</li>
<li>rich runtime<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup> vs. almost no&nbsp;runtime</li>
<li>global vs. localized type&nbsp;inference</li>
<li>indentation vs.&nbsp;braces</li>
<li>two decades (!) vs. barely two years since&nbsp;release</li>
</ul>
<p>Setting aside syntax, most of those differences are pretty&nbsp;significant.</p>
<p>You probably wouldn&#8217;t use Haskell for embedded programming, for instance,
both for performance (<span class="caps">GC</span>) and memory usage reasons (laziness).
Similarly, Rust&#8217;s ownership system can be too much of a hassle for high level code
that isn&#8217;t subject to real time&nbsp;requirements.</p>
<p>But if you look a little deeper,
beyond just the surface descriptions of both languages,
you can find plenty of <em>concepts</em> they&nbsp;share.</p>
<h4>Traits: they are typeclasses,&nbsp;essentially</h4>
<p>Take Haskell&#8217;s typeclasses, for example &#8212;
the cornerstone of its rich and expressive type&nbsp;system.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Type_class"><em>typeclass</em></a> is, simply speaking,
a list of capabilities:
it defines what a type can <em>do</em>.
There exist analogs of typeclasses in most programming languages,
but they are normally called interfaces or protocols,
and remain closely tied to the object-oriented&nbsp;paradigm.</p>
<p>Not so in&nbsp;Haskell.</p>
<p>Or in Rust for that matter, where the equivalent concept exists under the name of <em>traits</em>.
What typeclasses and traits have in common is that
they&#8217;re used for <em>all kinds of polymorphism</em> in their respective&nbsp;languages.</p>
<h5>Generics</h5>
<p>For example, let&#8217;s consider <em>parametrized types</em>,
sometimes also referred to as templates (C++) or generics&nbsp;(C#).</p>
<p>In many cases, a generic function or type requires its type arguments
to exhibit certain characteristics.
In some languages (like the legacy C++), this is checked only implicitly:
as long as the template type-checks after its expansion, everything is&nbsp;okay:</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">min</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">b</span> <span class="p">:</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Foo</span> <span class="p">{};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1">// OK</span>
    <span class="n">min</span><span class="p">(</span><span class="n">Foo</span><span class="p">(),</span> <span class="n">Foo</span><span class="p">());</span>  <span class="c1">// ERROR, no operator `&gt;`</span>
<span class="p">}</span>
</pre></div>


<p>More advanced type systems, however, allow to specify the generic constraints <em>explicitly</em>.
This is the case in&nbsp;Rust:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">min</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>as well as in&nbsp;Haskell:</p>
<div class="highlight"><pre><span class="nf">min</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">min</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="kr">then</span> <span class="n">b</span> <span class="kr">else</span> <span class="n">a</span>
</pre></div>


<p>In both languages, the notion of a type supporting certain operations (like comparison/ordering)
is represented as its own, first-class concept:
a <em>trait</em> (Rust) or a <em>typeclass</em> (Haskell).
Since the compiler is aware of those constraints,
it can verify that the <code>min</code> function is used correctly even before
it tries to generate code for a specific substitution of <code>T</code>.</p>
<h5>Dynamic&nbsp;dispatch</h5>
<p>On the other hand, let&#8217;s look at <em>runtime polymorphism</em>:
the one that <span class="caps">OO</span> languages implement
through abstract base classes and virtual methods.
It&#8217;s the tool of choice if you need a container of objects of different types,
which nevertheless all expose the same&nbsp;interface.</p>
<p>To offer it, Rust has <a href="https://doc.rust-lang.org/book/first-edition/trait-objects.html"><em>trait objects</em></a>,
and they work pretty much exactly like base class pointers/references from Java, C++, or&nbsp;C#.</p>
<div class="highlight"><pre><span class="c1">// Trait definition</span>
<span class="k">trait</span><span class="w"> </span><span class="n">Draw</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Data type implementing the trait</span>
<span class="k">struct</span><span class="w"> </span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">radius</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="k">impl</span><span class="w"> </span><span class="n">Draw</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* omitted */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Usage</span>
<span class="k">fn</span><span class="w"> </span><span class="n">draw_all</span><span class="p">(</span><span class="n">objects</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Draw</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">obj</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">objects</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">obj</span><span class="p">.</span><span class="n">draw</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>The Haskell analogue is, in turn, based on typeclasses,
though the specifics can be a little bit&nbsp;trickier:</p>
<div class="highlight"><pre><span class="cm">{-# LANGUAGE ExistentialQuantification #-}</span>

<span class="c1">-- Typeclass definition</span>
<span class="kr">class</span> <span class="kt">Draw</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">draw</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>

<span class="c1">-- Polymorphic wrapper type</span>
<span class="kr">data</span> <span class="kt">Draw&#39;</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Draw</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Draw&#39;</span> <span class="n">a</span>
<span class="kr">instance</span> <span class="kt">Draw</span> <span class="kt">Draw&#39;</span> <span class="kr">where</span>
    <span class="n">draw</span> <span class="p">(</span><span class="kt">Draw&#39;</span> <span class="n">d</span><span class="p">)</span> <span class="ow">=</span> <span class="n">draw</span> <span class="n">d</span>

<span class="c1">-- Data types instantiating (&quot;implementing&quot;) the typeclass</span>
<span class="kr">data</span> <span class="kt">Circle</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="nb">()</span>
<span class="kr">instance</span> <span class="kt">Draw</span> <span class="kt">Circle</span> <span class="kr">where</span> <span class="n">draw</span> <span class="ow">=</span> <span class="n">undefined</span> <span class="c1">-- omitted</span>
<span class="kr">data</span> <span class="kt">Square</span> <span class="ow">=</span> <span class="kt">Square</span> <span class="nb">()</span>
<span class="kr">instance</span> <span class="kt">Draw</span> <span class="kt">Square</span> <span class="kr">where</span> <span class="n">draw</span> <span class="ow">=</span> <span class="n">undefined</span> <span class="c1">-- omitted</span>

<span class="c1">-- Usage</span>
<span class="nf">drawAll</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Draw</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">drawAll</span> <span class="n">ds</span> <span class="ow">=</span> <span class="n">mapM_</span> <span class="n">draw</span> <span class="n">ds</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="n">shapes</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Draw&#39;</span> <span class="kt">Circle</span> <span class="nb">()</span><span class="p">,</span> <span class="kt">Draw&#39;</span> <span class="kt">Square</span> <span class="nb">()</span><span class="p">]</span>
    <span class="n">drawAll</span> <span class="n">shapes</span>
</pre></div>


<p>Here, the generic function can use typeclass constraints directly (<code>(Draw a) =&gt; ...</code>),
but creating a container of different object types requires a polymorphic wrapper<sup id="fnref:4"><a class="footnote-ref" href="#fn:4" rel="footnote">4</a></sup>.</p>
<h5>Differences</h5>
<p>All those similarities do not mean that
Rust traits and Haskell typeclasses are one and the same.
There are, in fact, quite a few differences, owing mostly to the fact that
Haskell&#8217;s type system is more&nbsp;expressive:</p>
<ul>
<li>
<p>Rust lacks <a href="https://en.wikipedia.org/wiki/Kind_(type_theory)#Kinds_in_Haskell"><em>higher kinded types</em></a>,
  making certain abstractions impossible to encode as traits.
  It <em>is</em> possible, however, to implement a trait for infinitely many types at once
  if the <code>impl</code>ementation itself is generic
  (like <a href="https://github.com/Xion/rofld/blob/2a9e427707cc93c716e011e99b0127f19cd770a5/src/lib/resources/mod.rs#L45">here</a>).</p>
</li>
<li>
<p>When defining a trait in Rust, you can ask implementors to provide some auxiliary,
  <a href="https://doc.rust-lang.org/book/first-edition/associated-types.html">associated types</a>
  in addition to just methods<sup id="fnref:5"><a class="footnote-ref" href="#fn:5" rel="footnote">5</a></sup>.
  A similar mechanism in Haskell is expanded into <a href="https://wiki.haskell.org/GHC/Type_families">type families</a>,
  and requires enabling a <a href="https://ocharles.org.uk/blog/posts/2014-12-12-type-families.html"><span class="caps">GHC</span> extension</a>.</p>
</li>
<li>
<p>While typeclasses in Haskell can be implemented for multiple types simultaneously
  via a <a href="https://wiki.haskell.org/Multi-parameter_type_class"><span class="caps">GHC</span> extension</a>,
  Rust&#8217;s take on this feature is to make <em>traits themselves</em> generic (e.g. <code>trait Foo&lt;T&gt;</code>).
  The end result is roughly similar;
  however, the &#8220;main implementing type&#8221; (one after <code>for</code> in <code>impl ... for ...</code>)
  is still a method receiver (<code>self</code>), just like in <span class="caps">OO</span>&nbsp;languages.</p>
</li>
<li>
<p>Rust enforces <em>coherence rules</em> on trait implementations.
  The topic is actually
  <a href="http://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/">rather complicated</a>,
  but the gist is about local (current package) vs. remote (other packages / standard library)
  traits and types.<br>
  Without too much detail, coherence demands that there be a local type or trait
  somewhere in the <code>impl ... for ...</code> construct.
  Haskell doesn&#8217;t have this limitation,
  although it is recommended <a href="https://wiki.haskell.org/Orphan_instance">not to take advantage of this</a>.</p>
</li>
</ul>
<h4>The&nbsp;M-word</h4>
<p>Another area of overlap between Haskell and Rust exists
in the <em>data model</em> utilized by those languages.
Both are taking heavy advantage of <a href="https://en.wikipedia.org/wiki/Algebraic_data_type"><em>algebraic data types</em> (<span class="caps">ADT</span>)</a>,
including the ability to define both <em>product types</em> (&#8220;regular&#8221; structs and records)
as well as <em>sum types</em> (tagged&nbsp;unions).</p>
<h5><code>Maybe</code> you&#8217;d like <code>Some(T)</code>?</h5>
<p>Even more interestingly,
code in both languages makes extensive use of the two most basic&nbsp;ADTs:</p>
<ul>
<li><code>Option</code> (Rust) or <code>Maybe</code> (Haskell) &#8212;
  for denoting a presence or absence of a&nbsp;value</li>
<li><code>Result</code> (Rust) or <code>Either</code> (Haskell) &#8212;
  for representing the alternative of &#8220;correct&#8221; and &#8220;erroneous&#8221;&nbsp;value</li>
</ul>
<p>These aren&#8217;t just simple datatypes.
They are deeply interwoven into the basic semantics of both languages,
not to mention their standard libraries and community-provided&nbsp;packages.</p>
<p>The <code>Option</code>/<code>Maybe</code> type, for example,
is the alternative to <em>nullable references</em>:
something that&#8217;s been
<a href="https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/">heavily criticized</a>
for making programs prone to unexpected <code>NullReferenceException</code>s.
The idea behind both of those types is to make actual values impossible to confuse with <code>null</code>s
by encoding the potential nullability into the type&nbsp;system:</p>
<div class="highlight"><pre><span class="k">enum</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w"> </span><span class="nb">None</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>


<!-- -->

<div class="highlight"><pre><span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Nothing</span>
</pre></div>


<p><code>Result</code> and <code>Either</code>, on the other hand,
can be thought as an extension of this idea.
They also represent two possibilities,
but the &#8220;wrong&#8221; one isn&#8217;t just <code>None</code> or <code>Nothing</code>
&#8212; it has some more information associated with&nbsp;it:</p>
<div class="highlight"><pre><span class="k">enum</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>


<!-- -->

<div class="highlight"><pre><span class="kr">data</span> <span class="kt">Either</span> <span class="n">e</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">e</span> <span class="o">|</span> <span class="kt">Right</span> <span class="n">a</span>
</pre></div>


<p>This dichotomy between the <code>Ok</code> (or <code>Right</code>) value and the <code>Err</code>or value (or the <code>Left</code> one)
makes it a great vehicle for carrying results of functions that can <em>fail</em>.</p>
<p>In Rust, this replaces the traditional error handling mechanisms based on exceptions.
In Haskell, the exceptions are present and sometimes necessary,
but <code>Either</code> is nevertheless the preferred approach to dealing with&nbsp;errors.</p>
<h5>What to <code>do</code>?</h5>
<p>One thing that Haskell does better is <em>composing</em> those fallible functions
into bigger chunks of&nbsp;logic.</p>
<p>Relatively recently, Rust has added the <a href="https://m4rw3r.github.io/rust-questionmark-operator"><code>?</code> operator</a>
as a replacement for the <code>try!</code> macro.
This is now the preferred way of <em>error propagation</em>,
allowing for a more concise composition of functions that return <code>Result</code>s:</p>
<div class="highlight"><pre><span class="c-Doc">/// Read an integer from given file.</span>
<span class="k">fn</span><span class="w"> </span><span class="n">int_from_file</span><span class="p">(</span><span class="n">path</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="nb">Path</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">io</span><span class="o">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span><span class="o">::</span><span class="n">File</span><span class="o">::</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">String</span><span class="o">::</span><span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">io</span><span class="o">::</span><span class="n">Error</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">io</span><span class="o">::</span><span class="n">ErrorKind</span><span class="o">::</span><span class="n">InvalidData</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>But Haskell had it for much longer,
and it&#8217;s something of a hallmark of the language and functional programming in general
&#8212; even though it looks thoroughly <em>imperative</em>:</p>
<div class="highlight"><pre><span class="nf">intFromFile</span> <span class="ow">::</span> <span class="kt">FilePath</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Int</span>
<span class="nf">intFromFile</span> <span class="n">path</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">readFile</span> <span class="n">path</span>
    <span class="n">i</span> <span class="ow">&lt;-</span> <span class="n">readIO</span> <span class="n">s</span>
    <span class="n">return</span> <span class="n">i</span>
</pre></div>


<p>If you haven&#8217;t seen it before, this is of course a <em>monad</em> &#8212; the <code>IO</code> monad, to be precise.
While discussing monads in detail is way outside of the scope of this article,
we can definitely notice some analogies with Rust.
The <code>do</code> notation with <code>&lt;-</code> arrows is evidently similar to
how in Rust you&#8217;d assign the result of a fallible operation after &#8220;unpacking&#8221; it with <code>?</code>.</p>
<p>But of course,
there&#8217;s plenty of different monads in Haskell: not just <code>IO</code>,
but also <code>Either</code>, <code>Maybe</code>, <code>Reader</code>, <code>Writer</code>, <code>Cont</code>, <code>STM</code>, and many others.
In Rust (at least as of 1.19), the <code>?</code> operator only works for <code>Result</code> types,
although there is <a href="https://github.com/rust-lang/rfcs/issues/1718">some talk</a>
about extending it to <code>Option</code> as well<sup id="fnref:6"><a class="footnote-ref" href="#fn:6" rel="footnote">6</a></sup>.</p>
<p>Eventually, we may see the language adopt some variant of the <code>do</code> notation,
though the motivation for this will most likely come from
<a href="https://github.com/alexcrichton/futures-await">asynchronous programming with <code>Future</code>s</a>
rather than plain <code>Result</code>s.
General monads, however, require support for <em>higher kinded types</em>
which <a href="https://github.com/rust-lang/rfcs/issues/324">isn&#8217;t coming anytime soon</a>.</p>
<h4>A path through&nbsp;Rust?</h4>
<p>Now that we&#8217;ve discussed those similarities,
the obvious question&nbsp;arises.</p>
<blockquote>
<p>Is learning Rust worthwhile
if your ultimate goal is getting proficient at functional programming in general,
or Haskell in&nbsp;particular?</p>
</blockquote>
<p>My answer to that is actually pretty&nbsp;straightforward.</p>
<p>If &#8220;getting to <span class="caps">FP</span>&#8221; is your main goal, then Rust will <em>not</em> help you very much.
Functional paradigm isn&#8217;t the main idea behind the language &#8212;
its shtick is mostly <em>memory safety</em>, and zero-cost abstractions.
While it succeeds somewhat at being &#8220;Haskell Lite&#8221;,
it really strives to be <em>safer C++</em><sup id="fnref:7"><a class="footnote-ref" href="#fn:7" rel="footnote">7</a></sup>.</p>
<p>But if, on the other hand, you regard <span class="caps">FP</span> mostly as a curiosity
that seems to be seeping into your favorite imperative language at an increasing rate,
Rust can be a good way to gain familiarity with this peculiar&nbsp;beast.</p>
<p>At the very least, you will learn the functional way of <em>modeling programs</em>,
with lots of smart enums/unions and structs but without&nbsp;inheritance.</p>
<p>And the best part is: you will be so busy
<a href="https://m-decoster.github.io//2017/01/16/fighting-borrowchk/">fighting the borrow checker</a>
you won&#8217;t even notice when it happens&nbsp;;-)</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Just ask in <code>#haskell-beginners</code> on Freenode if you&#8217;re interested.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Though ironically,
I found the <a href="https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_"><span class="caps">CT</span> lectures by Bartosz Milewski</a>
very helpful in developing the right intuitions, even though they&#8217;re very abstract.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>For example, Haskell has <em>green threads</em> (created with <code>forkIO</code>)
which are somewhat similar to goroutines from Go.
To get anything remotely similar in Rust, you need to use <a href="http://tokio.rs">external libraries</a>.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>Note that such containers aren&#8217;t very idiomatic Haskell.
A more typical solution would be to just curry the <code>draw</code> function,
implicitly putting the <code>Draw</code> object inside its closure.&#160;<a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:5">
<p>This mechanisms expands to
<a href="https://doc.rust-lang.org/1.6.0/book/associated-constants.html">associated constants</a>
in Rust 1.20.&#160;<a class="footnote-backref" href="#fnref:5" rev="footnote" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:6">
<p>Those two types also have a form of <em>monadic bind</em> (<code>&gt;&gt;=</code> in Haskell)
exposed as <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then">the <code>and_then</code> method</a>.&#160;<a class="footnote-backref" href="#fnref:6" rev="footnote" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:7">
<p>If you want another language for easing into the concept of functional programming,
I&#8217;ve heard that Scala fills that niche quite well.&#160;<a class="footnote-backref" href="#fnref:7" rev="footnote" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/programming/rust-into-haskell.html#rust-into-haskell">Continue reading</a>
  </div>
</article>

  <div class="pagination">
  </div>

    <footer>
<p>
  &copy; Karol Kuczmarski 2017 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-27379564-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Karol Kuczmarski's Blog ",
  "url" : "http://xion.io",
  "image": "http://xion.io/logo.jpeg",
  "description": ""
}
</script><script type="text/javascript">
    var disqus_shortname = 'xionblog';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>