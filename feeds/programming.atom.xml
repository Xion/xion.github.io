<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Karol Kuczmarski's Blog</title><link href="http://xion.io/" rel="alternate"></link><link href="http://xion.io/feeds/programming.atom.xml" rel="self"></link><id>http://xion.io/</id><updated>2018-08-18T13:07:00+02:00</updated><entry><title>A Haskell retrospective</title><link href="http://xion.io/post/programming/haskell-retrospective.html" rel="alternate"></link><updated>2018-08-18T13:07:00+02:00</updated><author><name>Karol Kuczmarski</name></author><id>tag:xion.io,2018-08-18:post/programming/haskell-retrospective.html</id><summary type="html">&lt;p&gt;Approximately a year ago,
I had the opportunity to work on &lt;a href="https://code.facebook.com/posts/745068642270222/fighting-spam-with-haskell/"&gt;Sigma&lt;/a&gt;
&amp;#8212; a large, distributed system that protects Facebook users from spam and other kinds of&amp;nbsp;abuse.&lt;/p&gt;
&lt;p&gt;One reason it was a pretty unique experience is that Sigma is almost entirely a &lt;em&gt;Haskell&lt;/em&gt; codebase.
It was the first time I got to work with the language in a professional setting,
so I was eager to see how it performs in a real-world, production-grade&amp;nbsp;application.&lt;/p&gt;
&lt;p&gt;In this (rather long) post, I&amp;#8217;ll draw on this experience
and highlight Haskell&amp;#8217;s notable features from a practical, engineering standpoint.
In other words, I&amp;#8217;ll be interested in how much does it help with solving actual problems
that arise in the field of software development &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt;&amp;nbsp;maintenance.&lt;/p&gt;
&lt;h4&gt;Haskell&amp;nbsp;Who?&lt;/h4&gt;
&lt;p&gt;Before we start, however,
it seems necessary to clarify what &amp;#8220;Haskell&amp;#8221; are we actually talking&amp;nbsp;about.&lt;/p&gt;
&lt;p&gt;Granted, this may be a little surprising.
From a far-away vantage point,
Haskell is typically discussed as a rather uniform language,
and it is often treated as synonymous with &lt;em&gt;functional programming&lt;/em&gt; in&amp;nbsp;general.&lt;/p&gt;
&lt;p&gt;But if you look closer, that turns out to be a bit of a misrepresentation.
In reality, Haskell is a complex manifold of different components,
some of which can be thought as their own sublanguages.
Roughly speaking, Haskell
&amp;#8212; as it&amp;#8217;s used in the industry and in the &lt;span class="caps"&gt;OSS&lt;/span&gt; world today &amp;#8212;
should be thought of as a cake with at least the following&amp;nbsp;layers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The base Haskell language, as defined by the Haskell &amp;#8216;98 and 2010 reports.
At least in theory, this is the &lt;em&gt;portable&lt;/em&gt; version of the language
that any conforming compiler is supposed to accept.
In practice, given &lt;a href="http://taylor.fausak.me/2017/11/15/2017-state-of-haskell-survey-results/#question-14"&gt;the absolute monopoly of &lt;span class="caps"&gt;GHC&lt;/span&gt;&lt;/a&gt;,
it is merely a theoretical base that needs to be significantly augmented
in order to reach some level of practical&amp;nbsp;usability.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A bunch of &lt;span class="caps"&gt;GHC&lt;/span&gt; extensions that are
&lt;a href="http://dev.stephendiehl.com/hask/#the-benign"&gt;widely considered&lt;/a&gt;
mandatory for any real-world project.
Some, like &lt;code&gt;TupleSections&lt;/code&gt; or &lt;code&gt;MultiParamTypeClasses&lt;/code&gt;,
are mostly there to fix some surprising feature gaps
that would be more confusing if you had worked around them instead.
Others, like &lt;code&gt;GADTs&lt;/code&gt; or &lt;code&gt;DataKinds&lt;/code&gt;,
open up completely new avenues for type-level&amp;nbsp;abstractions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A repertoire of common third-party libraries with unique DSLs,
like &lt;a href="https://hackage.haskell.org/package/conduit"&gt;&lt;em&gt;conduit&lt;/em&gt;&lt;/a&gt;,
&lt;a href="https://hackage.haskell.org/package/pipes"&gt;&lt;em&gt;pipes&lt;/em&gt;&lt;/a&gt;,
or &lt;a href="https://hackage.haskell.org/package/lens-tutorial-1.0.3/docs/Control-Lens-Tutorial.html"&gt;&lt;em&gt;lens&lt;/em&gt;&lt;/a&gt;.
Unlike many &amp;#8220;regular&amp;#8221; packages that merely bring in some domain-specific &lt;span class="caps"&gt;API&lt;/span&gt;,
these fundamental libraries shape both the deeper architecture
and the surface-level look &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; feel of any Haskell codebase that uses&amp;nbsp;them.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A selection of &lt;a href="https://ocharles.org.uk/blog/posts/2014-12-01-24-days-of-ghc-extensions.html"&gt;less common extensions&lt;/a&gt;
which are nevertheless encountered in Haskell code with some&amp;nbsp;regularity.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://wiki.haskell.org/Template_Haskell"&gt;Template Haskell&lt;/a&gt;,
the language for compile-time metaprogramming whose main application is probably &lt;em&gt;generics&lt;/em&gt;.&lt;br&gt;
To be clear, neither &amp;#8220;template&amp;#8221; nor &amp;#8220;generics&amp;#8221; have anything to do with the usual meanings
of those terms in C++ and Java/C#/Go&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;.
Rather, it refers to a kind of &lt;span class="caps"&gt;AST&lt;/span&gt;-based &amp;#8220;preprocessing&amp;#8221;
that allows Haskell code to operate on the generic &lt;em&gt;structure&lt;/em&gt; of user-defined types:
their constructors, parameters, and record fields&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;br&gt;
Direct use of &lt;span class="caps"&gt;TH&lt;/span&gt; in application code is extremely rare,
but many projects rely on libraries which utilize it behind the scenes.
A great example would be &lt;a href="https://hackage.haskell.org/package/persistent-2.7.1/docs/Database-Persist.html"&gt;Persistent&lt;/a&gt;,
a database interface library where the &lt;span class="caps"&gt;ORM&lt;/span&gt;
uses Template Haskell to construct record types from a &lt;span class="caps"&gt;DB&lt;/span&gt; schema at compile&amp;nbsp;time.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;There is a language in my type&amp;nbsp;system&lt;/h4&gt;
&lt;p&gt;What&amp;#8217;s striking about this ensemble of features and ideas
is that most of them don&amp;#8217;t seem to follow from the ostensible premise of the language:
that it is functional, pure / referentially transparent, and non-strict / lazily evaluated.
Instead, they are mostly a collection of progressively more sophisticated refinements
and applications of Haskell&amp;#8217;s &lt;em&gt;type system&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This singular focus on type theory &amp;#8212; especially in the recent years&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt; &amp;#8212;
is probably why many people in the wider programming world think
it is necessary to grok advanced type system concepts
if you even want to dabble in functional&amp;nbsp;programming&lt;/p&gt;
&lt;p&gt;That is, of course, patently untrue&lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="#fn:4" rel="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt;.
&lt;em&gt;Some&lt;/em&gt; features of a strong static type system are definitely useful to have in a functional language.
You can look at &lt;a href="http://elm-lang.org/"&gt;Elm&lt;/a&gt;
to see &lt;a href="http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Result#map3"&gt;how awkward&lt;/a&gt;
things become when you deprive an &lt;span class="caps"&gt;FP&lt;/span&gt; language of its typeclasses
and &lt;a href="http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Result#andThen"&gt;composition sugar&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But when the focus on type systems becomes too heavy,
the concepts &lt;a href="https://wiki.haskell.org/GHC/Type_system"&gt;keep piling up&lt;/a&gt;
and the language becomes increasingly impenetrable.
Eventually, you may end up with an ecosystem where the recommended way to implement an &lt;span class="caps"&gt;HTTP&lt;/span&gt; &lt;span class="caps"&gt;API&lt;/span&gt;
is to call upon
&lt;a href="http://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html#a-first-example"&gt;half a dozen compiler extensions&lt;/a&gt;
in order to specify it as
&lt;a href="http://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html#from-combinators-to-handler-arguments"&gt;one humongous type&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But hey, isn&amp;#8217;t it desirable to have this kind of increased type&amp;nbsp;safety?&lt;/p&gt;
&lt;p&gt;In principle, the answer would of course be yes.
However, the price we pay here is in the precious currency of &lt;em&gt;complexity&lt;/em&gt;,
and it often turns out to be way too high.
When libraries, frameworks, and languages get complicated and abstract,
it&amp;#8217;s not just safety and/or productivity that can (hopefully) increase &amp;#8212;
it is also the burden on developers&amp;#8217; thought processes.
While the exact threshold of diminishing or even negative returns is hard to pinpoint,
it can definitely be reached even by the smartest and most talented teams.
Add in the usual obstacles of software engineering &amp;#8212; shifting requirements,
deadlines, turnover &amp;#8212; and you may encounter it much sooner than you&amp;nbsp;think.&lt;/p&gt;
&lt;p&gt;For some, this is a sufficient justification to basically
&lt;a href="https://golang.org/"&gt;give up on type systems&lt;/a&gt; altogether.
And while I&amp;#8217;d say such a knee-jerk reaction is rather excessive and unwarranted,
it is at least equally harmful to letting your typing regime grow in boundless complexity.
Both approaches are just too extreme to stand the test of&amp;nbsp;practicality.&lt;/p&gt;
&lt;h4&gt;The legacy of bleeding&amp;nbsp;edge&lt;/h4&gt;
&lt;p&gt;In other words, Haskell &lt;em&gt;is&lt;/em&gt; hard and this &lt;em&gt;does&lt;/em&gt; count as one of its serious problems.
This conclusion isn&amp;#8217;t exactly novel or surprising,
even if some people would &lt;a href="http://dave.fayr.am/posts/2011-08-19-lets-go-shopping.html"&gt;still argue with it&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Suppose, however, that we have somehow caused this issue to disappear completely.
Let&amp;#8217;s say that through some kind of divine intervention,
it was made so that the learning curve of Haskell
is no longer a problem for the majority of programmers.
Maybe we found a magic lamp and &amp;#8212; for the lack of better ideas &amp;#8212;
we wished that everyone be as proficient
in applicative parsers as they are in inheritance&amp;nbsp;hierarchies.&lt;/p&gt;
&lt;p&gt;Even in this hypothetical scenario, I posit that
the value proposition of Haskell would &lt;em&gt;still&lt;/em&gt; be a tough&amp;nbsp;sell.&lt;/p&gt;
&lt;p&gt;There is this old quote from Bjarne Stroustrup (creator of C++)
where he says that programming languages divide into those everyone complains about,
and those that no one uses.&lt;br&gt;
The first group consists of old, established technologies
that managed to accrue significant complexity debt through years and decades of evolution.
All the while, they&amp;#8217;ve been adapting to the constantly shifting perspectives
on what are the best industry practices.
Traces of those adaptations can still be found today,
sticking out like a leftover appendix or residual tail bone &amp;#8212;
or like the built-in support for &lt;span class="caps"&gt;XML&lt;/span&gt; in&amp;nbsp;Java.&lt;/p&gt;
&lt;p&gt;Languages that &amp;#8220;no one uses&amp;#8221;, on the other hand,
haven&amp;#8217;t yet passed the industry threshold of sufficient maturity and stability.
Their ecosystems are still cutting edge, and their future is uncertain,
but they sometimes champion some really compelling paradigm shifts.
As long as you can bear with things that are rough around the edges,
you can take advantage of their novel&amp;nbsp;ideas.&lt;/p&gt;
&lt;p&gt;Unfortunately for Haskell,
it manages to combine the &lt;em&gt;worst parts&lt;/em&gt; of both of these&amp;nbsp;worlds.&lt;/p&gt;
&lt;p&gt;On one hand, it is a surprisingly old language,
clocking more than two decades of fruitful research around many innovative concepts.
Yet on the other hand, it bears the signs of a fresh new technology,
with relatively few production-grade libraries,
scarce coverage of some domains (e.g. &lt;span class="caps"&gt;GUI&lt;/span&gt; programming),
and not too many stories of commercial&amp;nbsp;successes.&lt;/p&gt;
&lt;h4&gt;There are many ways to do&amp;nbsp;it&lt;/h4&gt;
&lt;p&gt;Nothing shows better the problems of Haskell&amp;#8217;s evolution over the years
than the various approaches to handling &lt;em&gt;strings&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; that it now has.&lt;sup id="fnref:5"&gt;&lt;a class="footnote-ref" href="#fn:5" rel="footnote"&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h5&gt;String&amp;nbsp;theory&lt;/h5&gt;
&lt;p&gt;Historically, &lt;code&gt;String&lt;/code&gt; has been defined as a list of &lt;code&gt;Char&lt;/code&gt;acters,
which is normally denoted as the &lt;code&gt;[Char]&lt;/code&gt; type.
The good thing about this representation is that many string-based algorithms
can simply be written using just the list&amp;nbsp;functions.&lt;/p&gt;
&lt;p&gt;The bad thing is that Haskell lists are the so-called &lt;em&gt;cons lists&lt;/em&gt;.
They consist of the single element (called &lt;code&gt;head&lt;/code&gt;),
followed by another list of the remaining elements (called &lt;code&gt;tail&lt;/code&gt;).
This makes them roughly equivalent to what the data structures theory
calls a &lt;em&gt;singly-linked list&lt;/em&gt;
&amp;#8212; a rarely used construct that has a number of undesirable&amp;nbsp;characteristics:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;linear time (&lt;code&gt;O(n)&lt;/code&gt;) for finding a specific element in the&amp;nbsp;list&lt;/li&gt;
&lt;li&gt;linear time for finding an element with a specific &lt;em&gt;index&lt;/em&gt; in the&amp;nbsp;list&lt;/li&gt;
&lt;li&gt;linear time for insertion in the middle of the&amp;nbsp;list&lt;/li&gt;
&lt;li&gt;poor cache coherency due to scattered allocations of list nodes&lt;sup id="fnref:6"&gt;&lt;a class="footnote-ref" href="#fn:6" rel="footnote"&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;On top of that, keeping only a single character inside each node
results in a significant waste of&amp;nbsp;memory.&lt;/p&gt;
&lt;p&gt;Given those downsides,
it isn&amp;#8217;t very surprising that virtually no serious Haskell program
uses &lt;code&gt;String&lt;/code&gt;s for any meaningful text processing.
The community-accepted replacement is &lt;a href="https://hackage.haskell.org/package/text"&gt;the &lt;em&gt;text&lt;/em&gt; package&lt;/a&gt;,
whose implementation stores strings inside packed arrays, i.e. just as you would expect.
As a result, Haskell has at least two main types of &amp;#8220;strings&amp;#8221; &amp;#8212; or even &lt;em&gt;three&lt;/em&gt;,
since &lt;code&gt;Text&lt;/code&gt; has both lazy and strict&amp;nbsp;variants.&lt;/p&gt;
&lt;p&gt;That&amp;#8217;s not all, however:
there is also &lt;a href="https://hackage.haskell.org/package/bytestring"&gt;the &lt;em&gt;bytestring&lt;/em&gt; package&lt;/a&gt;.
Although technically it implements generic byte buffers,
its &lt;span class="caps"&gt;API&lt;/span&gt; has been &lt;a href="https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString.html#g:11"&gt;pretty rich and enticing&lt;/a&gt;.
As a result, many other packages would rather use &lt;code&gt;ByteString&lt;/code&gt;s directly in their interfaces
than to incur the conversions to and from &lt;code&gt;Text&lt;/code&gt;.&lt;br&gt;
And just like in case of &lt;code&gt;Text&lt;/code&gt;,
separate lazy and strict variants of &lt;code&gt;ByteString&lt;/code&gt; are also available.
But unlike &lt;code&gt;Text&lt;/code&gt;, byte strings also have &lt;code&gt;Word8&lt;/code&gt; and &lt;code&gt;Char8&lt;/code&gt; versions,
where the latter is designed to handle legacy cases of &lt;span class="caps"&gt;ASCII&lt;/span&gt;-exclusive text&amp;nbsp;support.&lt;/p&gt;
&lt;p&gt;Well, I hope you kept count of all these types!
I also hope you can memorize the correct way of converting between them,
because it&amp;#8217;s commonplace to see them used simultaneously.
This may sometimes happen even within the same library,
but it definitely occurs in application code
that utilizes many different dependencies.
What it usually results in are numerous occurrences of something like &lt;code&gt;Text.pack . foo . Text.unpack&lt;/code&gt;,
with conversion functions copiously sprinkled in
to help win in the &lt;a href="http://javran.github.io/posts/2014-02-28-type-tetris-and-typeclassopedia.html"&gt;Type Tetris&lt;/a&gt;.&lt;/p&gt;
&lt;h5&gt;Errors and how to handle&amp;nbsp;them&lt;/h5&gt;
&lt;p&gt;A somewhat similar issue applies to error handling.
Over the years, Haskell has tried many approaches to this problem,
often mixing techniques that are very rarely found in a single language,
like exceptions combined with result&amp;nbsp;types.&lt;/p&gt;
&lt;p&gt;Nowadays, there is some consensus about those
&lt;a href="https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail"&gt;mistakes of the past&lt;/a&gt;,
but the best we got is their deprecation:
the current version of &lt;span class="caps"&gt;GHC&lt;/span&gt; still supports them&amp;nbsp;all.&lt;/p&gt;
&lt;p&gt;What are all those techniques? Here&amp;#8217;s an abridged&amp;nbsp;list:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;code&gt;error&lt;/code&gt; function, terminating the program with a message
  (which is obviously&amp;nbsp;discouraged)&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;fail&lt;/code&gt; method of the &lt;code&gt;Monad&lt;/code&gt; typeclass
  (which is now deprecated and moved to &lt;code&gt;MonadFail&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Error.html#t:MonadError"&gt;the &lt;code&gt;MonadError&lt;/code&gt; class&lt;/a&gt;
  with the associated &lt;code&gt;ErrorT&lt;/code&gt; transformer, now deprecated in favor&amp;nbsp;of&amp;#8230;&lt;/li&gt;
&lt;li&gt;a &lt;em&gt;different&lt;/em&gt; &lt;a href="https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html#t:MonadError"&gt;&lt;code&gt;MonadError&lt;/code&gt; class&lt;/a&gt;,
  with &lt;code&gt;ExceptT&lt;/code&gt; as the new&amp;nbsp;transformer&lt;/li&gt;
&lt;li&gt;&lt;a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Exception.html"&gt;exceptions in the &lt;code&gt;IO&lt;/code&gt; monad&lt;/a&gt;,
  normally raised by the standard I/O calls to signal abnormal conditions and error;
  however, libraries and application code are free to &lt;a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Exception.html#g:2"&gt;also throw them&lt;/a&gt;
  and use for their own error&amp;nbsp;handling&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;Either&lt;/code&gt; sum type / monad, which is essentially a type-safe version of the venerable return&amp;nbsp;codes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you really stretched the definition of error handling,
I could also imagine counting &lt;code&gt;Maybe&lt;/code&gt;/&lt;code&gt;MaybeT&lt;/code&gt; as yet another method.
But even without it, that&amp;#8217;s half a dozen distinct approaches
which you are likely to encounter in the wild in one form or&amp;nbsp;another.&lt;/p&gt;
&lt;h4&gt;Implicit is better than&amp;nbsp;explicit&lt;/h4&gt;
&lt;p&gt;The other kind of troublesome legacy of Haskell
relates to the various design choices in the language itself.
They reflect ideas straight from the time they were conceived in,
which doesn&amp;#8217;t necessarily agree with the best engineering practices as we understand them &lt;em&gt;now&lt;/em&gt;.&lt;/p&gt;
&lt;h5&gt;Leaky&amp;nbsp;modules&lt;/h5&gt;
&lt;p&gt;Take the &lt;em&gt;module system&lt;/em&gt;, for&amp;nbsp;example.&lt;/p&gt;
&lt;p&gt;Today, it is rather uncontroversial that the purpose of splitting code into multiple submodules
is to isolate it as much as possible and prevent accidental dependencies.
The benefit of such isolation is better internal cohesion for each module.
This can simplify testing, improve readability, foster simplicity,
and reduce cognitive burden on the&amp;nbsp;maintainers.&lt;/p&gt;
&lt;p&gt;Contemporary languages help achieving this goal
by making inter-module dependencies explicit.
If you want to use a symbol (functions, class) from module A inside another module B,
you typically have to&amp;nbsp;both:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;declare it &lt;em&gt;public&lt;/em&gt; in module&amp;nbsp;A&lt;/li&gt;
&lt;li&gt;explicitly &lt;em&gt;import&lt;/em&gt; its name in module&amp;nbsp;B&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first step helps to ensure that the &lt;span class="caps"&gt;API&lt;/span&gt; of module A is limited and tractable.
The second step does the same to the external dependencies of module&amp;nbsp;B.&lt;/p&gt;
&lt;p&gt;Unfortunately, Haskell requires neither of those steps.
In fact, it encourages precisely the &lt;em&gt;opposite&lt;/em&gt; of well-defined, self-contained modules,
all by the virtue of its default&amp;nbsp;behaviors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the default module declaration (&lt;code&gt;module Foo where ...&lt;/code&gt;)
implicitly declares &lt;em&gt;every symbol&lt;/em&gt; defined in the module &lt;code&gt;Foo&lt;/code&gt;
as public and importable by&amp;nbsp;others&lt;/li&gt;
&lt;li&gt;the default import statement (&lt;code&gt;import Foo&lt;/code&gt;) brings in &lt;em&gt;every public symbol&lt;/em&gt;
from the module &lt;code&gt;Foo&lt;/code&gt; into the global namespace of the current&amp;nbsp;module&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In essence, this is like putting &lt;code&gt;public&lt;/code&gt; on each and every class or method
that you&amp;#8217;d define in a Java project,
while simultaneously using nothing but wildcard (star) imports.
In a very short order, you will end up with project
where everything depends on everything else, and nothing can be developed in&amp;nbsp;isolation.&lt;/p&gt;
&lt;h5&gt;Namespaces are apparently a bad&amp;nbsp;idea&lt;/h5&gt;
&lt;p&gt;Thankfully, it is possible to avoid this pitfall
by explicitly declaring both your exported and imported&amp;nbsp;symbols:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;-- Foo.hs --&lt;/span&gt;
&lt;span class="kr"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;

&lt;span class="nf"&gt;foo&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="nf"&gt;bar&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="nf"&gt;baz&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;  &lt;span class="c1"&gt;-- not exported&lt;/span&gt;

&lt;span class="c1"&gt;-- Bar.hs --&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;-- `bar` is inaccessible here, but `foo` is available&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But while this helps fighting the tangle of dependencies,
it still results in cluttering the namespace of any non-trivial module
with a significant number of imported&amp;nbsp;symbols.&lt;/p&gt;
&lt;p&gt;In many other languages, you can instead import the module as a whole
and only refer to its members using &lt;em&gt;qualified names&lt;/em&gt;.
This is possible in Haskell as well, though it requires yet another variant
of the &lt;code&gt;import&lt;/code&gt; statement:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="k"&gt;qualified&lt;/span&gt; &lt;span class="nn"&gt;Data.Text&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;Text&lt;/span&gt;

&lt;span class="nf"&gt;duplicateWords&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;
&lt;span class="nf"&gt;duplicateWords&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unwords&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unwords&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;replicate&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;words&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;What if you want both, though? In the above code, for example,
the qualified name &lt;code&gt;Text.Text&lt;/code&gt; looks a little silly,
especially when it&amp;#8217;s such a common type.
It would be nice to import it directly, so that we can use it simply as &lt;code&gt;Text&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Unfortunately, this is only possible when using &lt;em&gt;two&lt;/em&gt; &lt;code&gt;import&lt;/code&gt; statements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Data.Text&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="k"&gt;qualified&lt;/span&gt; &lt;span class="nn"&gt;Data.Text&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;Text&lt;/span&gt;

&lt;span class="nf"&gt;duplicateWords&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
&lt;span class="nf"&gt;duplicateWords&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unwords&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unwords&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;replicate&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;words&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You will find this duplication pervasive throughout Haskell codebases.
Given how it affects the most important third-party packages (like &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;bytestring&lt;/code&gt;),
there have been a few proposals to improve the situation&lt;sup id="fnref:7"&gt;&lt;a class="footnote-ref" href="#fn:7" rel="footnote"&gt;7&lt;/a&gt;&lt;/sup&gt;,
but it seems that none can go through the syntax bikeshedding&amp;nbsp;phase.&lt;/p&gt;
&lt;p&gt;Contrast this with Rust, for example, where it&amp;#8217;s common to see imports such as&amp;nbsp;this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;read_first_half&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;Result&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// (omitted)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;where &lt;code&gt;self&lt;/code&gt; conveniently stands for the module as a&amp;nbsp;whole.&lt;/p&gt;
&lt;h5&gt;Wild&amp;nbsp;records&lt;/h5&gt;
&lt;p&gt;Another aspect of the difficulties with keeping your namespaces in check
relates to Haskell &lt;em&gt;record types&lt;/em&gt; &amp;#8212; its rough equivalent of &lt;code&gt;struct&lt;/code&gt;s from C and&amp;nbsp;others.&lt;/p&gt;
&lt;p&gt;When you define a record&amp;nbsp;type:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;User&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;usrFirstName&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
                 &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;usrLastName&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
                 &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;usrEmail&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
                 &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;you are declaring not one but multiple different names,
and dumping them all straight into the global namespace.
These names&amp;nbsp;include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the record &lt;em&gt;type&lt;/em&gt; (here, &lt;code&gt;User&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;its &lt;em&gt;type constructor&lt;/em&gt; (also &lt;code&gt;User&lt;/code&gt;, second one&amp;nbsp;above)&lt;/li&gt;
&lt;li&gt;all of its fields (&lt;code&gt;usrFirstName&lt;/code&gt;, &lt;code&gt;usrLastName&lt;/code&gt;, &lt;code&gt;usrEmail&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Yep, thats right.
Because Haskell has no special syntax for accessing record fields,
each field declaration creates an unqualified getter function.
Combined with the lack of function overloading,
this creates many opportunities for name&amp;nbsp;collisions.&lt;/p&gt;
&lt;p&gt;This is why in the above example,
&lt;a href="https://en.wikipedia.org/wiki/Hungarian_notation"&gt;Hungarian notation&lt;/a&gt; is used to prevent those clashes.
Despite its age and almost complete disuse in basically every other language,
it is still a widely accepted practice in Haskell&lt;sup id="fnref:8"&gt;&lt;a class="footnote-ref" href="#fn:8" rel="footnote"&gt;8&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h4&gt;Purity beats&amp;nbsp;practicality&lt;/h4&gt;
&lt;p&gt;We have previously discussed the multiple ways of working with strings
and handling errors in Haskell. While somewhat confusing at times,
there at least appears to be an agreement in the community as to which one
should generally be&amp;nbsp;preferred.&lt;/p&gt;
&lt;p&gt;This is not the case for some subtler and more abstract&amp;nbsp;topics.&lt;/p&gt;
&lt;p&gt;Haskell is, famously,
a &lt;a href="https://en.wikipedia.org/wiki/Purely_functional_programming"&gt;&lt;em&gt;purely functional&lt;/em&gt; programming language&lt;/a&gt;.
Evaluating functions, in a mathematical sense,
is all a Haskell program is supposed to be doing.
But the obvious problem is
that such a program wouldn&amp;#8217;t be able to do anything actually &lt;em&gt;useful&lt;/em&gt;;
there needs to be some way for it to &lt;em&gt;effect&lt;/em&gt; the environment it runs in,
if only to print the results it&amp;nbsp;computed.&lt;/p&gt;
&lt;p&gt;How to reconcile the functional purity with real-world applications
is probably the most important problem
that the Haskell language designers have to contend with.
After a couple of decades of research &lt;em&gt;and&lt;/em&gt; industrial use
it still doesn&amp;#8217;t have a satisfactory&amp;nbsp;answer.&lt;/p&gt;
&lt;p&gt;Yes, there is the &lt;code&gt;IO&lt;/code&gt; monad, but it is a very blunt instrument.
It offers a distinction between pure code and &amp;#8220;effectful&amp;#8221; code,
but allows for no granularity or structure for the latter.
An &lt;code&gt;IO&lt;/code&gt;-returning function can do literally anything,
while a pure function can only compute some value based on its arguments.
Most code, however, is best placed somewhere between those two&amp;nbsp;extremes.&lt;/p&gt;
&lt;p&gt;How to represent different varieties of &lt;em&gt;effects&lt;/em&gt; (filesystem, logging, network, etc.)?&lt;br&gt;
How to express them as function constraints that can be verified by the compiler?&lt;br&gt;
How to compose them? How to extend them?&lt;br&gt;&lt;/p&gt;
&lt;p&gt;These (and others) are still very much open questions in the Haskell community.
The traditional way of dealing with them are &lt;em&gt;monad transformers&lt;/em&gt;,
but they suffer from many shortcomings&lt;sup id="fnref:9"&gt;&lt;a class="footnote-ref" href="#fn:9" rel="footnote"&gt;9&lt;/a&gt;&lt;/sup&gt;.
More recent solutions like &lt;a href="http://hackage.haskell.org/package/extensible-effects"&gt;effects&lt;/a&gt;
or &lt;a href="http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html"&gt;free monads&lt;/a&gt; are promising,
but exhibit performance issues that likely won&amp;#8217;t be solvable without full compiler support.
And even so, you can &lt;a href="https://markkarpov.com/post/free-monad-considered-harmful.html"&gt;convincingly argue against&lt;/a&gt;
those new approaches,
which suggests that we may ultimately need something else&amp;nbsp;entirely.&lt;/p&gt;
&lt;p&gt;Of course, this state of affairs doesn&amp;#8217;t really prevent anyone
from writing useful applications in Haskell.
&amp;#8220;Regular&amp;#8221; monads are still a fine choice.
Indeed, even if you end up stuffing most of your code inside plain &lt;code&gt;IO&lt;/code&gt;,
it will already be a step up compared to most other&amp;nbsp;languages.&lt;/p&gt;
&lt;h4&gt;Good&amp;nbsp;Enough™&lt;/h4&gt;
&lt;p&gt;Incidentally, something similar could probably be said about the language as a&amp;nbsp;whole.&lt;/p&gt;
&lt;p&gt;Yes, it has numerous glaring flaws and some not-so-obvious shortcomings.&lt;br&gt;
Yes, it requires disciplined coding style and attention to readability.&lt;br&gt;
Yes, it will force you to courageously tackle problems
that are completely unknown to programmers using other languages.&lt;br&gt;
In the end, however, you will probably find it better than most&amp;nbsp;alternatives.&lt;/p&gt;
&lt;p&gt;Basically, Haskell is like pizza:
even when it&amp;#8217;s bad, it is still &lt;em&gt;pretty good&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;But what&amp;#8217;s possibly the best thing about it
is that you don&amp;#8217;t even really need to adopt Haskell in order to benefit from its innovations
(and avoid the legacy&amp;nbsp;warts).&lt;/p&gt;
&lt;p&gt;There is already a breed of mainstream languages
that can aptly be characterized as &amp;#8220;Haskell-lite&amp;#8221;:
heavily influenced by &lt;span class="caps"&gt;FP&lt;/span&gt; paradigms but without subscribing to them completely.
The closest example in this category is of course Scala,
while the newest one would be Rust.&lt;br&gt;
In many aspects, they offer a great compromise
that provides some important functional features
while sparing you most of the teething issues
that Haskell still has after almost 30 years.
Functional purists may not be completely satisfied,
but at least they&amp;#8217;ll get to keep their typeclasses and&amp;nbsp;monoids.&lt;/p&gt;
&lt;p&gt;And what if you don&amp;#8217;t want to hear about this &lt;span class="caps"&gt;FP&lt;/span&gt; nonsense at all?&amp;#8230;
Well, I&amp;#8217;m afraid it will get harder and harder to avoid.
These days, it&amp;#8217;s evidently fine for a language to omit generics
but it seems inconceivable to ditch &lt;a href="https://gobyexample.com/closures"&gt;first-class functions&lt;/a&gt;.
Even the traditional &lt;span class="caps"&gt;OOP&lt;/span&gt; powerhouse like Java
cannot do without
&lt;a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html"&gt;support for anonymous (&amp;#8220;lambda&amp;#8221;) functions&lt;/a&gt;
anymore.
And let&amp;#8217;s not forget
&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#Chaining"&gt;all&lt;/a&gt;
&lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#flatMap-java.util.function.Function-"&gt;the&lt;/a&gt;
&lt;a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.selectmany.aspx"&gt;numerous&lt;/a&gt;
&lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#flatMap-java.util.function.Function-"&gt;examples&lt;/a&gt;
of monadic constructs
that pervade many of the mature APIs, libraries, and&amp;nbsp;languages.&lt;/p&gt;
&lt;p&gt;So even if you, understandably, don&amp;#8217;t really want to come to Haskell,
it&amp;#8217;s looking more and more likely that Haskell will soon come to you&amp;nbsp;:)&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;In case of Go, I&amp;#8217;m of course referring to a feature that&amp;#8217;s notoriously &lt;em&gt;missing&lt;/em&gt; from the language.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;For a close analogue in languages other than Haskell,
you can look at the
&lt;a href="https://doc.rust-lang.org/book/first-edition/procedural-macros.html"&gt;current state of procedural macros&lt;/a&gt;
in Rust (commonly known as &amp;#8220;custom derives&amp;#8221;).&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;What seems to excite the Haskell community in 2018, for example,
are things like &lt;a href="https://ghc.haskell.org/trac/ghc/wiki/LinearTypes"&gt;linear types&lt;/a&gt;
and &lt;a href="https://typesandkinds.wordpress.com/2016/07/24/dependent-types-in-haskell-progress-report/"&gt;dependent types&lt;/a&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;The obvious counterexample is &lt;a href="https://en.wikipedia.org/wiki/Clojure"&gt;Clojure&lt;/a&gt;
and its cousins in the Lisp family of languages.&amp;#160;&lt;a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:5"&gt;
&lt;p&gt;Although
&lt;a href="https://www.reddit.com/r/haskell/comments/8ilw75/there_are_too_many_prettyprinting_libraries/"&gt;the abundance of pretty-printing libraries&lt;/a&gt;
is high up there, too :)&amp;#160;&lt;a class="footnote-backref" href="#fnref:5" rev="footnote" title="Jump back to footnote 5 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:6"&gt;
&lt;p&gt;This can be mitigated somewhat by using a contiguous chunk of memory
through a dedicated &lt;em&gt;arena allocator&lt;/em&gt;, or implementing the list as an array.&amp;#160;&lt;a class="footnote-backref" href="#fnref:6" rev="footnote" title="Jump back to footnote 6 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:7"&gt;
&lt;p&gt;See for example &lt;a href="https://theam.github.io/require/"&gt;this project&lt;/a&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:7" rev="footnote" title="Jump back to footnote 7 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:8"&gt;
&lt;p&gt;Some &lt;span class="caps"&gt;GHC&lt;/span&gt; extensions like &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; allow for correct type inference
even in case of &amp;#8220;overloaded&amp;#8221; field names, though.&amp;#160;&lt;a class="footnote-backref" href="#fnref:8" rev="footnote" title="Jump back to footnote 8 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:9"&gt;
&lt;p&gt;To name a few:
they don&amp;#8217;t compose well (e.g. can only have one instance of a particular monad in the stack);
they can cause some &lt;a href="https://www.fpcomplete.com/blog/2017/06/tale-of-two-brackets"&gt;extremely tricky bugs&lt;/a&gt;;
they don&amp;#8217;t really cooperate with the standard library which uses &lt;code&gt;IO&lt;/code&gt; everywhere
(often requiring tricks like &lt;a href="https://github.com/fpco/unliftio"&gt;this&lt;/a&gt;).&amp;#160;&lt;a class="footnote-backref" href="#fnref:9" rev="footnote" title="Jump back to footnote 9 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="Haskell"></category><category term="functional programming"></category><category term="type systems"></category><category term="Facebook"></category></entry><entry><title>Recap of the gisht project</title><link href="http://xion.io/post/programming/gisht-recap.html" rel="alternate"></link><updated>2017-11-24T17:52:00+00:00</updated><author><name>Karol Kuczmarski</name></author><id>tag:xion.io,2017-11-24:post/programming/gisht-recap.html</id><summary type="html">&lt;p&gt;In this post, I want to discuss some of the experiences I had with a project
that I recently finished, &lt;a href="https://github.com/Xion/gisht"&gt;&lt;em&gt;gisht&lt;/em&gt;&lt;/a&gt;.
By &amp;#8220;finished&amp;#8221; I mean that I don&amp;#8217;t anticipate developing any new major features for it,
though smaller things, bug fixes, or non-code stuff, is of course still very&amp;nbsp;possible.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m thinking this is as much &amp;#8220;done&amp;#8221; as most software projects can ever hope to be.
Thus, it is probably the best time for a recap / summary / postmortem / etc. &amp;#8212;
something to recount the lessons learned, and assess the choices&amp;nbsp;made.&lt;/p&gt;
&lt;h4&gt;Some&amp;nbsp;context&lt;/h4&gt;
&lt;p&gt;The original purpose of &lt;em&gt;gisht&lt;/em&gt; was to facilitate download &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; execution of GitHub gists
straight from the command&amp;nbsp;line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;gisht Xion/git-outgoing  &lt;span class="c"&gt;# run the https://gist.github.com/Xion/git-outgoing gist&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I initially wrote &lt;a href="https://github.com/Xion/gisht.py"&gt;its first version in Python&lt;/a&gt;
because I&amp;#8217;ve accumulated a sizable number of small &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; useful scripts
(for Git, Unix, Python, etc.) which were all posted as gists.
Sure, I could download them manually to &lt;code&gt;~/bin&lt;/code&gt; every time I used a new machine
but that&amp;#8217;s rather cumbersome, and I&amp;#8217;m quite&amp;nbsp;lazy.&lt;/p&gt;
&lt;p&gt;Well, lazy &lt;em&gt;and&lt;/em&gt; impatient :)
I noticed pretty fast that the speed tax of Python
is basically unacceptable for a program like &lt;em&gt;gisht&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;What I&amp;#8217;m referring to here is not the speed of code execution, however,
but only the &lt;em&gt;startup time&lt;/em&gt; of Python interpreter.
Irrespective of the machine, operating system, or language version,
it doesn&amp;#8217;t seem to go lower than about one hundred milliseconds;
empirically, it&amp;#8217;s often 2 or 3 times higher than that.
For the common case of finding a cached gist (no downloads)
and doing a simple &lt;code&gt;fork&lt;/code&gt;+&lt;code&gt;exec&lt;/code&gt;,
this startup time was very noticeable and extremely jarring.
It also precluded some more sophisticated uses for &lt;em&gt;gisht&lt;/em&gt;,
like putting its invocation into the shell&amp;#8217;s &lt;code&gt;$PROMPT&lt;/code&gt;&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h4&gt;Speed:&amp;nbsp;delivered&lt;/h4&gt;
&lt;p&gt;And so the obvious solution emerged:
let&amp;#8217;s &lt;a href="https://transitiontech.ca/random/RIIR"&gt;rewrite it in Rust&lt;/a&gt;!&amp;#8230;&lt;/p&gt;
&lt;p&gt;Because if I&amp;#8217;m executing code straight from the internet,
I should at least do it in a &lt;em&gt;safe&lt;/em&gt;&amp;nbsp;language.&lt;/p&gt;
&lt;p&gt;But jokes aside, it is obvious that a language compiling to native code
is likely a good pick if you want to optimize for startup speed.
So while the choice of Rust was in large part educational
(&lt;em&gt;gisht&lt;/em&gt; was one of my first projects to be written in it),
it definitely hasn&amp;#8217;t disappointed&amp;nbsp;there.&lt;/p&gt;
&lt;p&gt;Even without any intentional optimization efforts,
the app still runs &lt;em&gt;instantaneously&lt;/em&gt;.
I tried to take some measurements using the &lt;code&gt;time&lt;/code&gt; command,
but it never ticked into more than 0.001s.
Perceptively, it is at least on par with &lt;code&gt;git&lt;/code&gt;,
so that&amp;#8217;s acceptable for me&amp;nbsp;:)&lt;/p&gt;
&lt;h4&gt;Can&amp;#8217;t segfault if your code doesn&amp;#8217;t&amp;nbsp;build&lt;/h4&gt;
&lt;p&gt;Achieving the performance objective wouldn&amp;#8217;t do us much good, however,
if the road to get there involved excessive penalties on productivity.
Such negative impact could manifest in many ways,
including troublesome debugging due to a tricky runtime&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;,
or difficulty in getting the code to compile in the first&amp;nbsp;place.&lt;/p&gt;
&lt;p&gt;If you had even a passing contact with Rust,
you&amp;#8217;d expect the latter to be much more likely than the&amp;nbsp;former.&lt;/p&gt;
&lt;p&gt;Indeed, Rust&amp;#8217;s very design eschews runtime flexibility to a ridiculous degree
(in its &amp;#8220;safe&amp;#8221; mode, at least),
while also forcing you to absorb subtle &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; complex ideas
to even get your code past the compiler.
The reward is increased likelihood your program will behave as intended &amp;#8212;
although it&amp;#8217;s definitely not on the level of &amp;#8220;if it compiles, it works&amp;#8221;
that can be offered by Haskell or&amp;nbsp;Idris.&lt;/p&gt;
&lt;p&gt;But since &lt;em&gt;gisht&lt;/em&gt; is hardly mission critical,
I didn&amp;#8217;t actually care too much about this increased reliability.
I don&amp;#8217;t think it&amp;#8217;s likely that Rust would buy me much over something like modern C++.
And if I were to &lt;em&gt;really&lt;/em&gt; do some kind of cost-benefit analysis of several languages
&amp;#8212; rather than going with Rust simply to learn it better &amp;#8212;
then it would be hard to justify it over something like&amp;nbsp;Go.&lt;/p&gt;
&lt;h4&gt;It&amp;nbsp;scales&lt;/h4&gt;
&lt;p&gt;So the real question is: has Rust &lt;em&gt;not hampered&lt;/em&gt; my productivity too much?
Having the benefit of hindsight,
I&amp;#8217;m happy to say that the trade-off was definitely acceptable&amp;nbsp;:)&lt;/p&gt;
&lt;p&gt;One thing I was particularly satisfied with was the language&amp;#8217;s &lt;em&gt;scalability&lt;/em&gt;.
What I mean here is the ability to adapt as the project grows,
but also to start quickly and remain nimble
while the codebase is still pretty&amp;nbsp;small.&lt;/p&gt;
&lt;p&gt;Many languages (most, perhaps) are naturally tailored towards the large end,
doing their best to make it more bearable to work with big codebases.
In turn, they often forget about helping projects take off in the first place.
Between complicated build systems and dependency managers (Java),
or a virtual lack of either (C++),
it can be really hard to get going in a &amp;#8220;serious&amp;#8221; language like&amp;nbsp;this.&lt;/p&gt;
&lt;p&gt;On the other hand, languages like Python make it very easy to start up
and achieve relatively impressive results.
Some people, however, report having encountered problems
once the code evolves past certain size.
While I&amp;#8217;m actually
&lt;a href="http://xion.io/post/programming/long-live-dynamic-languages.html"&gt;very unsympathetic&lt;/a&gt; to those claims,
I realize perception plays a significant role here,
making those anecdotal experiences into a sort of self-fulfilling&amp;nbsp;prophecy.&lt;/p&gt;
&lt;p&gt;This perception problem should almost certainly spare Rust,
as it&amp;#8217;s a natively compiled and statically typed language,
with a respectable type system to boot.
There is also &lt;a href="https://servo.org/"&gt;some evidence&lt;/a&gt;
that the language works well in large projects already.
So the only question that we might want to ask is:
how easy it is to actually &lt;em&gt;start&lt;/em&gt; a project in Rust,
and carry it towards some kind of &lt;abbr title="Minimum Viable Product"&gt;&lt;span class="caps"&gt;MVP&lt;/span&gt;&lt;/abbr&gt;?&lt;/p&gt;
&lt;p&gt;Based on my experiences with &lt;em&gt;gisht&lt;/em&gt;,
I can say that it is, in fact, quite easy.
Thanks mostly to the impressive Swiss army knife of &lt;code&gt;cargo&lt;/code&gt;
&amp;#8212; acting as both package manager and a rudimentary build system &amp;#8212;
it was almost Python-trivial to cook a &amp;#8220;Hello World&amp;#8221; program
that does something tangible, like
&lt;a href="https://github.com/Xion/gisht/blob/de1be876784d671dd84618c3a15d0836f9fd5697/src/main.rs"&gt;talk to a &lt;span class="caps"&gt;JSON&lt;/span&gt; &lt;span class="caps"&gt;API&lt;/span&gt;&lt;/a&gt;.
From there, it only took a few coding sessions to grow it
into a &lt;a href="https://github.com/Xion/gisht/tree/5c156cb"&gt;functioning prototype&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Abstractions&amp;nbsp;galore&lt;/h4&gt;
&lt;p&gt;As part of rewriting &lt;em&gt;gisht&lt;/em&gt; from Python to Rust,
I also wanted to fix some longstanding issues that limited its&amp;nbsp;capabilities.&lt;/p&gt;
&lt;p&gt;The most important one was the hopeless coupling to GitHub
and their particular flavor of gists.
Sure, this is where the project even got its name from,
but people use a dozen of different services to share code snippets
and it should very possible to support them&amp;nbsp;all.&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s where it became necessary to utilize
the abstraction capabilities that Rust has to offer.
It was somewhat obvious to
&lt;a href="https://github.com/Xion/gisht/blob/3fc443dc9986612fd46b4311ca2ecbc613a15cf9/src/gist.rs#L16"&gt;define a &lt;code&gt;Host&lt;/code&gt; trait&lt;/a&gt;
but of course its exact form had to be
&lt;a href="https://github.com/Xion/gisht/commit/26746dfc2eac68b67753f71148eb9897a861914e#diff-9d0a9c0911fa012f0fcf8ca56b43f8c5"&gt;shaped&lt;/a&gt;
over &lt;a href="https://github.com/Xion/gisht/commit/1e54ad05480b42089977171f10d4727beca5f835#diff-9d0a9c0911fa012f0fcf8ca56b43f8c5"&gt;numerous iterations&lt;/a&gt;.
Along the way, it even turned out that &lt;code&gt;Result&amp;lt;Option&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;Result&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;
are sometimes &lt;a href="https://github.com/Xion/gisht/blob/d9c30e69d58b2a4e5608e6c8a1aa6392133b490f/src/hosts/mod.rs#L44"&gt;both necessary&lt;/a&gt;
as return types&amp;nbsp;:)&lt;/p&gt;
&lt;p&gt;Besides cleaner architecture,
another neat thing about an explicit abstraction is
the ability to slice a concept into smaller pieces &amp;#8212;
and then put &lt;em&gt;some of them&lt;/em&gt; back together.
While the &lt;code&gt;Host&lt;/code&gt; trait could support a very diverse set of gist services and &lt;em&gt;pastebins&lt;/em&gt;,
many of them turned out to be just a slight variation of one central theme.
Because of this similarity, it was possible to introduce
a single &lt;a href="https://github.com/Xion/gisht/blob/d2e78b1f5ee4616b1d5eb7067c3c5dd0ce9e2fe4/src/hosts/simple.rs#L26"&gt;&lt;code&gt;Basic&lt;/code&gt; implementation&lt;/a&gt;
which handles multiple services through varying sets of &lt;span class="caps"&gt;URL&lt;/span&gt;&amp;nbsp;patterns.&lt;/p&gt;
&lt;p&gt;Devices like these aren&amp;#8217;t of course specific to Rust:
interfaces (traits) and classes are a staple of &lt;span class="caps"&gt;OO&lt;/span&gt; languages in general.
But some other techniques were more idiomatic;
the concept of &lt;a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"&gt;iterators&lt;/a&gt;, for example,
is flexible enough to accommodate
&lt;a href="https://github.com/Xion/gisht/blob/4fa347c6197190b0f6c68dd548efc28287a5859f/src/hosts/github.rs#L354"&gt;looping over GitHub user&amp;#8217;s gists&lt;/a&gt;,
even as they read directly from &lt;span class="caps"&gt;HTTP&lt;/span&gt;&amp;nbsp;responses.&lt;/p&gt;
&lt;h4&gt;Hacking&amp;nbsp;time&lt;/h4&gt;
&lt;p&gt;Not everything was sunshine and rainbows,&amp;nbsp;though.&lt;/p&gt;
&lt;p&gt;Take &lt;em&gt;clap&lt;/em&gt;, for example.
It&amp;#8217;s mostly a very good crate for parsing command line arguments,
but it couldn&amp;#8217;t &lt;em&gt;quite&lt;/em&gt; cope with the unusual requirements that &lt;em&gt;gisht&lt;/em&gt; had.
To make &lt;code&gt;gisht Foo/bar&lt;/code&gt; work alongside &lt;code&gt;gisht run Foo/bar&lt;/code&gt;,
it was necessary to
&lt;a href="https://github.com/Xion/gisht/commit/0eff00e31f94f3856558ebb1f6655a9e6fc50ca6#diff-7397f82f682a49eb62e2b056118124d0"&gt;analyze &lt;code&gt;argv&lt;/code&gt;&lt;/a&gt;
before even handing it over to &lt;code&gt;clap&lt;/code&gt;.
This turned out to be
&lt;a href="https://github.com/Xion/gisht/commit/e7ab06a01d4675947965ec82fc6f3ec5a2517c89#diff-7397f82f682a49eb62e2b056118124d0"&gt;surprisingly tricky&lt;/a&gt;
to get right.
Like,
&lt;a href="https://github.com/Xion/gisht/commit/69e8aad4a1743beb57184dc38150ef02b306a0a1#diff-7397f82f682a49eb62e2b056118124d0"&gt;really&lt;/a&gt;
tricky, with
&lt;a href="https://github.com/Xion/gisht/commit/acadcfa0a97fe52584fbf8198541baa8733cb0a5#diff-7397f82f682a49eb62e2b056118124d0R58"&gt;edges cases&lt;/a&gt;
and
&lt;a href="https://github.com/Xion/gisht/commit/a9eb599168f5b6821aefa46dde0b0a89a41cd4e6#diff-7397f82f682a49eb62e2b056118124d0R562"&gt;stuff&lt;/a&gt;.
But as it is often the case in software,
the answer turned out to be yet another layer of indirection plus
&lt;a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/src/args.rs#L457-L578"&gt;a copious amount of tests&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In another instance, however, a direct library support was&amp;nbsp;crucial.&lt;/p&gt;
&lt;p&gt;It so happened that &lt;em&gt;hyper&lt;/em&gt;, the crate I&amp;#8217;ve been using for &lt;span class="caps"&gt;HTTP&lt;/span&gt; requests,
didn&amp;#8217;t handle the &lt;code&gt;Link:&lt;/code&gt; response header out of the box&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;.
This was a stumbling block that prevented the gist iterator (mentioned earlier)
from correctly handling pagination in the responses from GitHub &lt;span class="caps"&gt;API&lt;/span&gt;.
Thankfully, having &lt;a href="https://docs.rs/hyper/0.11.7/hyper/header/trait.Header.html"&gt;the &lt;code&gt;Header&lt;/code&gt; abstraction&lt;/a&gt; in &lt;em&gt;hyper&lt;/em&gt;
meant it was possible to add the missing support in
&lt;a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/src/ext/hyper.rs"&gt;a relatively straighforward manner&lt;/a&gt;.
Yes, it&amp;#8217;s &lt;a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/src/ext/hyper.rs#L23"&gt;not a universal implementation&lt;/a&gt;
that&amp;#8217;d be suitable for &lt;em&gt;every&lt;/em&gt; &lt;span class="caps"&gt;HTTP&lt;/span&gt; client,
but it does the job for &lt;em&gt;gisht&lt;/em&gt; just&amp;nbsp;fine.&lt;/p&gt;
&lt;h4&gt;Test-Reluctant&amp;nbsp;Development&lt;/h4&gt;
&lt;p&gt;And so the program kept growing steadily over the months,
most notably through
&lt;a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/src/hosts/mod.rs#L101"&gt;more and more gist hosts&lt;/a&gt;
it could now&amp;nbsp;support.&lt;/p&gt;
&lt;p&gt;Eventually, some of them would fall into a sort of twilight zone.
They weren&amp;#8217;t as complicated as GitHub to warrant writing a completely new &lt;code&gt;Host&lt;/code&gt; instance,
but they also couldn&amp;#8217;t be handled via
&lt;a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/src/hosts/common/basic.rs#L28"&gt;the &lt;code&gt;Basic&lt;/code&gt; structure&lt;/a&gt; alone.
A good example would be &lt;a href="http://sprunge.us/"&gt;sprunge.us&lt;/a&gt;:
mostly an ordinary pastebin,
except for its optional syntax highlighting
which may add some &amp;#8220;junk&amp;#8221; to the otherwise regular&amp;nbsp;URLs.&lt;/p&gt;
&lt;p&gt;In order to handle those odd cases,
I went for a classic wrapper/decorator pattern which, in its essence,
boils down to something like&amp;nbsp;this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;pub&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Sprunge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;inner&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Basic&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Sprunge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;pub&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;Sprunge&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;inner&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Basic&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sprunge.us&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                  &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://sprunge.us/${id}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...)}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Host&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Sprunge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// override &amp;amp; wrap methods that require custom logic:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resolve_url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="kt"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;Result&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Gist&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;url_obj&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;try_opt&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Url&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;ok&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;url_obj&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;None&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;inner&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resolve_url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url_obj&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_string&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;as_str&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// passthrough to the `Basic` struct for others:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fetch_gist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;gist&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Gist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FetchMode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;Result&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inner&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fetch_gist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// (etc.)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Despite the noticeable boilerplate of a few pass-through methods,
I was pretty happy with this solution, at least initially.
After a few more unusual hosts, however,
it became cumbersome to fix all the edge cases
by looking only at the final output of the inner &lt;code&gt;Basic&lt;/code&gt; implementation.
The code was evidently asking for some &lt;em&gt;tests&lt;/em&gt;,
if only to check how the inner structure is being&amp;nbsp;called.&lt;/p&gt;
&lt;p&gt;Shouldn&amp;#8217;t be too hard, right?&amp;#8230; Yeah, that&amp;#8217;s what I thought,&amp;nbsp;too.&lt;/p&gt;
&lt;p&gt;The reality, unfortunately, fell very short of those expectations.
Stubs, mocks, fakes &amp;#8212;
&lt;a href="https://testing.googleblog.com/2013/07/testing-on-toilet-know-your-test-doubles.html"&gt;&lt;em&gt;test doubles&lt;/em&gt;&lt;/a&gt;
in general &amp;#8212;
are a dark and forgotten corner of Rust
that almost no one seems to pay any attention to.
Absent a proper library support &amp;#8212; much less a language one &amp;#8212;
the only way forward was to roll up my sleeves
and implement
&lt;a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/src/testing/inmemory_host.rs"&gt;a fake &lt;code&gt;Host&lt;/code&gt;&lt;/a&gt;
from&amp;nbsp;scratch.&lt;/p&gt;
&lt;p&gt;But that was just the beginning.
How do you seamlessly inject this fake implementation into the wrapper
so that it replaces the &lt;code&gt;Basic&lt;/code&gt; struct for testing?
If you are not careful and go for the &amp;#8220;obvious&amp;#8221; solution &amp;#8212; a trait&amp;nbsp;object:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;pub&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Sprunge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;inner&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Box&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Host&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;you&amp;#8217;ll soon realize that you need not just a &lt;code&gt;Box&lt;/code&gt;, but at least an &lt;code&gt;Rc&lt;/code&gt; (or maybe even &lt;code&gt;Arc&lt;/code&gt;).
Without this kind of shared ownership,
you&amp;#8217;ll lose your chance to interrogate the test double once you hand it over to the wrapper.
This, in turn, will heavily limit your ability to write effective&amp;nbsp;tests.&lt;/p&gt;
&lt;p&gt;What&amp;#8217;s the non-obvious approach, then?
The full rationale would probably warrant a separate post,
but the working recipe looks more or less like&amp;nbsp;this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;First, &lt;em&gt;parametrize&lt;/em&gt; the wrapper with its inner type:
  &lt;code&gt;pub struct Sprunge&amp;lt;T: Host&amp;gt; { inner: T }&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Put that in an internal module with the correct visibility&amp;nbsp;setup:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;mod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;internal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;pub&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Sprunge&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Host&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;pub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;super&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inner&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Make the regular (&amp;#8220;production&amp;#8221;) version of the wrapper into an &lt;em&gt;alias&lt;/em&gt;,
  giving it the type parameter that you&amp;#8217;ve been using directly&lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="#fn:4" rel="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;pub&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Sprunge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;internal&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Sprunge&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Basic&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change the &lt;code&gt;new&lt;/code&gt; constructor to instantiate the &lt;code&gt;internal&lt;/code&gt; type.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In tests, create the wrapper with a fake &lt;code&gt;inner&lt;/code&gt; object&amp;nbsp;inside.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As you can see in
&lt;a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/src/hosts/sprunge.rs"&gt;the real example&lt;/a&gt;,
this convoluted technique removes the need for any pointer indirection.
It also permits you to
&lt;a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/src/hosts/sprunge.rs#L152"&gt;access the out-of-band interface&lt;/a&gt;
that a fake object would normally&amp;nbsp;expose.&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s a shame, though, that so much work is required for something
that should be very simple.
As it appears, testing is still a neglected topic in&amp;nbsp;Rust.&lt;/p&gt;
&lt;h4&gt;Packing&amp;nbsp;up&lt;/h4&gt;
&lt;p&gt;It wasn&amp;#8217;t just Rust that played a notable role in the development of &lt;em&gt;gisht&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Pretty soon after getting the app to a presentable state,
it became clear that a mere &lt;code&gt;cargo build&lt;/code&gt; won&amp;#8217;t do everything
that&amp;#8217;s necessary to carry out a complete build.
It &lt;em&gt;could&lt;/em&gt; do more, admittedly,
if I had the foresight to explore &lt;a href="http://doc.crates.io/build-script.html"&gt;Cargo build scripts&lt;/a&gt;
a little more thoroughly.
But overall, I don&amp;#8217;t regret dropping back to my trusty ol&amp;#8217; pick:&amp;nbsp;Python.&lt;/p&gt;
&lt;p&gt;Like in a few previous projects, I used the &lt;a href="http://pyinvoke.org"&gt;Invoke task runner&lt;/a&gt;
for both the crucial and the auxiliary automation tasks.
It is a relatively powerful tool
&amp;#8212; and probably the best in its class in Python that I know of &amp;#8212;
though it can be a bit capricious if you want to
&lt;a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/tasks/release/__init__.py#L69"&gt;really fine-tune it&lt;/a&gt;.
But it does make it much easier to organize your automation code,
to reuse it between tasks, and to (ahem) &lt;em&gt;invoke&lt;/em&gt; those tasks in a convenient&amp;nbsp;manner.&lt;/p&gt;
&lt;p&gt;In any case, it certainly beats a collection of disconnected Bash scripts&amp;nbsp;;)&lt;/p&gt;
&lt;p&gt;What have I automated in this way, you may ask?
Well, a couple of small things; those&amp;nbsp;include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;embedding of the current Git commit hash into the binary,
to help identify the exact revision in the logs of any potential bug reports&lt;sup id="fnref:5"&gt;&lt;a class="footnote-ref" href="#fn:5" rel="footnote"&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;after a successful build,
&lt;a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/tasks/build.py#L40"&gt;replacing&lt;/a&gt;
the &lt;em&gt;Usage&lt;/em&gt; section in &lt;em&gt;&lt;span class="caps"&gt;README&lt;/span&gt;&lt;/em&gt; with the program&amp;#8217;s &lt;code&gt;--help&lt;/code&gt; output&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;generating &lt;a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/tasks/build.py#L96"&gt;completion scripts&lt;/a&gt;
for popular shells by invoking the binary with a magic hidden flag (courtesy of &lt;em&gt;clap&lt;/em&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Undoubtedly the biggest task that I relegated to Python/Invoke,
was the preparation of
&lt;a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/tasks/release/__init__.py"&gt;&lt;em&gt;release packages&lt;/em&gt;&lt;/a&gt;.
When it comes to the various Linuxes (currently Debian and Red Hat flavors),
this wasn&amp;#8217;t particularly complicated.
Major thanks are due to the amazing &lt;a href="https://github.com/jordansissel/fpm"&gt;&lt;em&gt;fpm&lt;/em&gt; tool&lt;/a&gt; here,
which I recommend to anyone who needs to package their software in a distro-compatible&amp;nbsp;manner.&lt;/p&gt;
&lt;p&gt;Homebrew, however &amp;#8212; or more precisely, &lt;span class="caps"&gt;OS&lt;/span&gt; X itself &amp;#8212; was quite a different story.
Many, &lt;a href="https://github.com/Xion/gisht/commits/a5423a63d10221c50faa1cb30a999a85286853a1"&gt;many&lt;/a&gt;
failed attempts were needed to even get it to build on &lt;a href="https://travis-ci.org"&gt;Travis&lt;/a&gt;,
and the additional dependency on Python was
&lt;a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/ci/travis/before_install-osx.sh#L15"&gt;partially to blame&lt;/a&gt;.
To be fair, however, most of the pain was exclusively due to OpenSSL;
getting that thing to build is always &lt;a href="https://github.com/sfackler/rust-openssl/issues/255"&gt;loads of &amp;#8220;fun&amp;#8221;&lt;/a&gt;,
especially in such an opaque and poorly debuggable environment as&amp;nbsp;Travis.&lt;/p&gt;
&lt;h4&gt;The&amp;nbsp;wrap&lt;/h4&gt;
&lt;p&gt;There&amp;#8217;s probably a lot of minor things and tidbits I could&amp;#8217;ve mentioned along the way,
but the story so far has most likely covered all the important topics.
Let&amp;#8217;s wrap it up then, and highlight some interesting points in the classic &lt;em&gt;Yay/Meh/Nay&lt;/em&gt;&amp;nbsp;manner.&lt;/p&gt;
&lt;h5&gt;Yay&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;It was definitely a good choice to rewrite &lt;em&gt;gisht&lt;/em&gt; specifically in Rust.
Besides all the advantages I&amp;#8217;ve mentioned already,
it is also worth noting that the language went through about 10 minor version bumps
while I was working on this project.
Of all those new releases,
I don&amp;#8217;t recall a single one that would introduce a breaking&amp;nbsp;change.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Most of the Rust ecosystem (third-party libraries) was a joy to use,
and very easy to get started with.
Honorable mention goes to &lt;em&gt;serde_json&lt;/em&gt; and how easy it was to
&lt;a href="https://github.com/Xion/gisht/commit/a0655a6a5b86c05df5665e3bc7f1512f2476c9e4"&gt;transition the code&lt;/a&gt;
from &lt;em&gt;rustc_serialize&lt;/em&gt; that I had used at&amp;nbsp;first.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;With a possible exception of sucking in node.js as a huge dependency of your project
and using Grunt, there is probably no better way of writing automation &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; support code than Python.
There may eventually be some Rust-based task runners that could try to compete,
but I&amp;#8217;m not very convinced about using a compiled language for this purpose
(and especially one that takes so long to&amp;nbsp;build).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;Meh&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;While &lt;a href="https://docs.rs/clap"&gt;the &lt;em&gt;clap&lt;/em&gt; crate&lt;/a&gt; is quite configurable and pretty straightforward to use,
it does lack at least &lt;a href="https://github.com/kbknapp/clap-rs/issues/568"&gt;one feature&lt;/a&gt;
that&amp;#8217;d be very nice for &lt;em&gt;gisht&lt;/em&gt;.
Additionally, working with raw &lt;em&gt;clap&lt;/em&gt; is often a little tedious,
as it doesn&amp;#8217;t assist you in translating parsed flags into your own configuration types,
and thus requires
&lt;a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/src/args.rs#L138-L182"&gt;shuffling those bits&lt;/a&gt;
manually&lt;sup id="fnref:6"&gt;&lt;a class="footnote-ref" href="#fn:6" rel="footnote"&gt;6&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Being a &lt;em&gt;defacto&lt;/em&gt; standard for continuous integration in open-source projects,
&lt;a href="https://travis-ci.org"&gt;Travis &lt;span class="caps"&gt;CI&lt;/span&gt;&lt;/a&gt; could be a &lt;em&gt;little&lt;/em&gt; less finicky.
In almost every project I decide to use it for,
I end up with about half a dozen commits
that frantically try to fix silly configuration issues,
all before even a simple &lt;em&gt;.travis.yml&lt;/em&gt; works as intended.
Providing a way to test &lt;span class="caps"&gt;CI&lt;/span&gt; builds locally would be an obvious way to avoid this&amp;nbsp;churn.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;Nay&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Testing in Rust is such a weird animal.
On one hand, there is a first-class, out-of-the-box support for unit tests
(and even integration tests) right in the toolchain.
On the other hand, the relevant parts of the ecosystem are immature or lacking,
as evidenced by the dreary story of mocking and stubbing.
It&amp;#8217;s no surprise that there is a long way to catch up to languages with the strongest testing culture
(Java and C#/.&lt;span class="caps"&gt;NET&lt;/span&gt;&lt;sup id="fnref:7"&gt;&lt;a class="footnote-ref" href="#fn:7" rel="footnote"&gt;7&lt;/a&gt;&lt;/sup&gt;), but it&amp;#8217;s disappointing to see Rust outclassed
&lt;a href="https://github.com/google/googletest"&gt;even by C++&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Getting anything to build reliably on &lt;span class="caps"&gt;OSX&lt;/span&gt; in a &lt;span class="caps"&gt;CI&lt;/span&gt; environment is already a tall order.
But if it involves things as OpenSSL, then it quickly goes from bad to terrible.
I&amp;#8217;m really not amused anymore how this &amp;#8220;Just Works&amp;#8221; system often turns out to hardly work at&amp;nbsp;all.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since I don&amp;#8217;t want to end on such a negative note,
I feel compelled to state the obvious fact: every technology choice is a trade-off.
In case of this project, however, the drawbacks were &lt;em&gt;heavily&lt;/em&gt; outweighed by the&amp;nbsp;benefits.&lt;/p&gt;
&lt;p&gt;For this reason, I can definitely recommend the software stack I&amp;#8217;ve just described
to anyone developing non-trivial, cross-platform command line&amp;nbsp;tools.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;This is not an isolated complaint, by the way,
as the interpreter startup time has recently emerged as &lt;a href="https://lwn.net/Articles/730915/"&gt;an important issue&lt;/a&gt;
to many developers of the Python language.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Which may also include a practical &lt;em&gt;lack&lt;/em&gt; thereof.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;It does handle it &lt;a href="https://docs.rs/hyper/0.11.7/hyper/header/struct.Link.html"&gt;now&lt;/a&gt;, fortunately.&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;Observant readers may notice that we&amp;#8217;re exposing a technically private type (&lt;code&gt;internal::Sprunge&lt;/code&gt;)
through a publicly visible type alias. If that type was &lt;em&gt;actually&lt;/em&gt; private,
this would trigger a compiler warning
which is slated to become &lt;a href="https://github.com/rust-lang/rust/issues/34537"&gt;a hard error&lt;/a&gt;
at some point in the future. But, amusingly, we can fool the compiler by making it a
&lt;em&gt;public type&lt;/em&gt; inside a &lt;em&gt;private module&lt;/em&gt;, which is exactly what we&amp;#8217;re doing here.&amp;#160;&lt;a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:5"&gt;
&lt;p&gt;This has since been rewritten and is now done in
&lt;a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/build.rs"&gt;&lt;em&gt;build.rs&lt;/em&gt;&lt;/a&gt;
&amp;#8212; but that&amp;#8217;s only because I implemented
&lt;a href="https://github.com/rust-lang/cargo/pull/3929"&gt;the relevant Cargo feature&lt;/a&gt; myself :)&amp;#160;&lt;a class="footnote-backref" href="#fnref:5" rev="footnote" title="Jump back to footnote 5 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:6"&gt;
&lt;p&gt;For an alternative approach that doesn&amp;#8217;t seem to have this problem,
check &lt;a href="https://docs.rs/structopt_derive"&gt;the &lt;em&gt;structopt&lt;/em&gt; crate&lt;/a&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:6" rev="footnote" title="Jump back to footnote 6 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:7"&gt;
&lt;p&gt;Dynamically typed languages, due to their rich runtime,
are basically a class of their own when it comes to testing ease,
so it wouldn&amp;#8217;t really be fair to hold them up for comparison.&amp;#160;&lt;a class="footnote-backref" href="#fnref:7" rev="footnote" title="Jump back to footnote 7 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="Rust"></category><category term="gisht"></category><category term="CLI"></category><category term="GitHub"></category><category term="Python"></category><category term="testing"></category></entry><entry><title>Currying and API design</title><link href="http://xion.io/post/programming/currying-api-design.html" rel="alternate"></link><updated>2017-11-12T14:07:00+00:00</updated><author><name>Karol Kuczmarski</name></author><id>tag:xion.io,2017-11-12:post/programming/currying-api-design.html</id><summary type="html">&lt;p&gt;In functional programming, &lt;em&gt;currying&lt;/em&gt; is one of the concepts
that contribute greatly to its expressive power.
Its importance could be compared to something as ubiquitous
as chaining method calls (&lt;code&gt;foo.bar().baz()&lt;/code&gt;) in imperative, object-oriented&amp;nbsp;languages.&lt;/p&gt;
&lt;p&gt;Although a simple idea on the surface,
it has significant consequences for the way functional APIs are designed.
This post is an overview of various techniques
that help utilize currying effectively when writing your functions.
While the examples are written in Haskell syntax,
I believe it should be useful for developers working in other functional languages,&amp;nbsp;too.&lt;/p&gt;
&lt;h4&gt;The&amp;nbsp;basics&lt;/h4&gt;
&lt;p&gt;Let&amp;#8217;s start with a short&amp;nbsp;recap.&lt;/p&gt;
&lt;p&gt;Intuitively, we say that an &lt;em&gt;N&lt;/em&gt;-argument function is &lt;em&gt;curried&lt;/em&gt;
if you can invoke it with a single argument and get back an (&lt;em&gt;N&lt;/em&gt;-1)-argument function.
Repeat this &lt;em&gt;N&lt;/em&gt; times,
and it&amp;#8217;ll be equivalent to supplying all &lt;em&gt;N&lt;/em&gt; arguments at&amp;nbsp;once.&lt;/p&gt;
&lt;p&gt;Here&amp;#8217;s an example: the &lt;code&gt;Data.Text&lt;/code&gt; module in Haskell
contains the following function called &lt;code&gt;splitOn&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;splitOn&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;splitOn&lt;/span&gt; &lt;span class="n"&gt;sep&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It&amp;#8217;s a fairly standard string splitting function,
taking a separator as its first argument,
with the second one being a string to perform the splitting&amp;nbsp;on:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;splitOn&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1,2,3&amp;quot;&lt;/span&gt;  &lt;span class="c1"&gt;-- produces [&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Both arguments are of type &lt;code&gt;Text&lt;/code&gt; (Haskell strings),
while the return type is &lt;code&gt;[Text]&lt;/code&gt; &amp;#8212; a &lt;em&gt;list&lt;/em&gt; of strings.
This add up to the signature (type) of &lt;code&gt;splitOn&lt;/code&gt;,
written above as &lt;code&gt;Text -&amp;gt; Text -&amp;gt; [Text]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Like all functions in Haskell, however, &lt;code&gt;splitOn&lt;/code&gt; is &lt;em&gt;curried&lt;/em&gt;.
We don&amp;#8217;t have to provide it with both arguments at once;
instead, we can stop at one in order to obtain &lt;em&gt;another function&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;splitOnComma&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;splitOnComma&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;splitOn&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This new function is a &lt;em&gt;partially applied&lt;/em&gt; version of &lt;code&gt;splitOn&lt;/code&gt;,
with its first argument (the separator) already filled in.
To complete the call, all you need to do now is provide the text to&amp;nbsp;split:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;splitOnComma&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1,2,3&amp;quot;&lt;/span&gt;  &lt;span class="c1"&gt;-- also produces [&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and, unsurprisingly, you&amp;#8217;ll get the exact same&amp;nbsp;result.&lt;/p&gt;
&lt;p&gt;Compare now the type signatures of both &lt;code&gt;splitOn&lt;/code&gt; and &lt;code&gt;splitOnComma&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;splitOn&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;splitOnComma&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It may be puzzling at first why the same arrow symbol (&lt;code&gt;-&amp;gt;&lt;/code&gt;) is used
for what seems like two distinct meanings: the &amp;#8220;argument separator&amp;#8221;,
and the return type&amp;nbsp;indicator.&lt;/p&gt;
&lt;p&gt;But for curried functions, both of those meanings are in fact &lt;em&gt;identical&lt;/em&gt;!&lt;/p&gt;
&lt;p&gt;Indeed, we can make it more explicit by defining &lt;code&gt;splitOn&lt;/code&gt; as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;splitOn&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;or&amp;nbsp;even:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;splitOn&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;TypeOf&lt;/span&gt; &lt;span class="n"&gt;splitOnComma&lt;/span&gt; &lt;span class="c1"&gt;-- (not a real Haskell syntax)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;From this perspective, what &lt;code&gt;splitOn&lt;/code&gt; actually returns is not &lt;code&gt;[Text]&lt;/code&gt;
but a &lt;em&gt;function&lt;/em&gt;  from &lt;code&gt;Text&lt;/code&gt; to &lt;code&gt;[Text]&lt;/code&gt; (&lt;code&gt;Text -&amp;gt; [Text]&lt;/code&gt;).
And conversely, a call with two&amp;nbsp;arguments:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;splitOn&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1,2,3&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;is instead &lt;em&gt;two function calls&lt;/em&gt;, each taking just &lt;em&gt;one argument&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;splitOn&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1,2,3&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is why the &lt;code&gt;-&amp;gt;&lt;/code&gt; arrow isn&amp;#8217;t actually ambiguous:
it always signifies the &lt;em&gt;mapping&lt;/em&gt; of an argument type to a result type.
And it&amp;#8217;s always just one argument, too,&amp;nbsp;because:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Currying makes all functions take only one&amp;nbsp;argument.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It&amp;#8217;s just that sometimes, what those single-argument functions return
will be yet another&amp;nbsp;function.&lt;/p&gt;
&lt;h4&gt;Least used arguments go &lt;em&gt;first&lt;/em&gt;&lt;/h4&gt;
&lt;p&gt;Now that we have a firmer grasp on the idea of currying,
we can see how it influences &lt;span class="caps"&gt;API&lt;/span&gt;&amp;nbsp;design.&lt;/p&gt;
&lt;p&gt;There is one thing in particular you will notice almost immediately,
especially if you are coming from imperative languages
that support default argument values and/or function overloading.
It&amp;#8217;s the particular &lt;em&gt;order of arguments&lt;/em&gt;
that a well designed, functional &lt;span class="caps"&gt;API&lt;/span&gt; will almost certainly&amp;nbsp;follow.&lt;/p&gt;
&lt;p&gt;See the &lt;code&gt;splitOn&lt;/code&gt; function&amp;nbsp;again:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;splitOn&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;splitOn&lt;/span&gt; &lt;span class="n"&gt;sep&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It is no accident that it puts the &lt;code&gt;sep&lt;/code&gt;arator as its first argument.
This choice &amp;#8212; as opposed to the alternative where &lt;code&gt;text&lt;/code&gt; goes first &amp;#8212;
produces much more useful results when the function is applied partially
through&amp;nbsp;currying.&lt;/p&gt;
&lt;p&gt;Say, for instance, that you want to splice a list of strings
where the individual pieces can be&amp;nbsp;comma-separated:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;spliceOnComma&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;spliceOnComma&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;2,3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;4,5,6&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;7&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="c1"&gt;-- ^ This should produce [&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;5&amp;quot;, &amp;quot;6&amp;quot;, &amp;quot;7&amp;quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Because the separator appears first in a &lt;code&gt;splitOn&lt;/code&gt; call,
you can do it easily through a direct use of&amp;nbsp;currying:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;spliceOnComma&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;concat&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;splitOn&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;

&lt;span class="c1"&gt;-- or equivalently, in a terser point-free style:&lt;/span&gt;
&lt;span class="c1"&gt;-- spliceOnComma = concatMap $ splitOn &amp;quot;,&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;What we do here is apply the split to every string in the list &lt;code&gt;xs&lt;/code&gt;
(with &lt;code&gt;map&lt;/code&gt;), followed by flattening the result &amp;#8212; a list of lists, &lt;code&gt;[[Text]]&lt;/code&gt; &amp;#8212;
back to a regular &lt;code&gt;[Text]&lt;/code&gt; with &lt;code&gt;concat&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If we had the alternative version of &lt;code&gt;splitOn&lt;/code&gt;,
one where the order of arguments is&amp;nbsp;reversed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;splitOn&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="n"&gt;sep&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;we&amp;#8217;d have no choice but to &amp;#8220;fix it&amp;#8221;, with either a lambda function
or &lt;a href="http://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html#v:flip"&gt;the &lt;code&gt;flip&lt;/code&gt; combinator&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;spliceOnComma&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;concat&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;splitOn&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;
&lt;span class="nf"&gt;spliceOnComma&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;concat&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flip&lt;/span&gt; &lt;span class="n"&gt;splitOn&amp;#39;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Putting the delimiter first is simply more convenient.
It is much more likely you&amp;#8217;ll be splitting multiple strings on the same separator,
as opposed to a single string and multiple separators.
The argument order of &lt;code&gt;splitOn&lt;/code&gt; is making the common use case slightly easier
by moving the more &amp;#8220;stable&amp;#8221; parameter to the&amp;nbsp;front.&lt;/p&gt;
&lt;p&gt;This practice generalizes to all curried functions,
forming a simple&amp;nbsp;rule:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The more likely it is for an argument to remain &lt;em&gt;constant&lt;/em&gt; between calls,
the sooner it should appear in the function&amp;nbsp;signature.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Note how this is different compared to any language
where functions may take variable number of arguments.
In Python, for example, the equivalent of &lt;code&gt;splitOn&lt;/code&gt; is defined&amp;nbsp;as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sep&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and the implicit default value for &lt;code&gt;sep&lt;/code&gt; is essentially &amp;#8220;any whitespace character&amp;#8221;.
In many cases, this is exactly what we want,
making the following calls possible&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Alice has a cat&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Alice&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;has&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;cat&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So, as a less-used argument, &lt;code&gt;sep&lt;/code&gt; actually goes last in &lt;code&gt;str.split&lt;/code&gt;,
as it is often desirable to omit it altogether.
Under the currying regime, however, we put it &lt;em&gt;first&lt;/em&gt;,
so that we can fix it to a chosen value and obtain a more specialized version of the&amp;nbsp;function.&lt;/p&gt;
&lt;h4&gt;The fewer arguments, the&amp;nbsp;better&lt;/h4&gt;
&lt;p&gt;Another thing you&amp;#8217;d encounter in languages with flexible function definitions
is the proliferation of optional&amp;nbsp;arguments:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://example.com/foo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                        &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;arg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
                        &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;field&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;value&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
                        &lt;span class="n"&gt;auth&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;user&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;pass&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                        &lt;span class="n"&gt;headers&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;User-Agent&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;My Amazing App&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
                        &lt;span class="n"&gt;cookies&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;c_is&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;for_cookie&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
                        &lt;span class="n"&gt;files&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;attachment.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;file.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;rb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)},&lt;/span&gt;
                        &lt;span class="n"&gt;allow_redirects&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                        &lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;5.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Trying to translate this directly to a functional paradigm
would result in extremely unreadable function calls &amp;#8212;
doubly so when you don&amp;#8217;t actually need all those arguments
and have to provide some canned&amp;nbsp;defaults:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;response&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kt"&gt;Requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;http://example.com/foo&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;&amp;#39;arg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;What does that &lt;code&gt;True&lt;/code&gt; mean, for example?
Or what exactly does each empty list signify?
It&amp;#8217;s impossible to know just by looking at the function call&amp;nbsp;alone.&lt;/p&gt;
&lt;p&gt;Long argument lists are thus detrimental to the quality of functional APIs.
It&amp;#8217;s much harder to correctly apply the previous rule (least used arguments first)
when there are so many possible&amp;nbsp;permutations.&lt;/p&gt;
&lt;p&gt;What should we do then?&amp;#8230;
In some cases, including the above example of an &lt;span class="caps"&gt;HTTP&lt;/span&gt; library,
we cannot simply cut out features in the name of elegance.
The necessary information needs to go &lt;em&gt;somewhere&lt;/em&gt;,
meaning we need to find at least somewhat acceptable place for&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;Fortunately, we have a couple of options
that should help us with solving this&amp;nbsp;problem.&lt;/p&gt;
&lt;h5&gt;Combinators /&amp;nbsp;builders&lt;/h5&gt;
&lt;p&gt;Looking back at the last example in Python,
we can see why the function call remains readable
even if it sprouts a dozen or so additional&amp;nbsp;arguments.&lt;/p&gt;
&lt;p&gt;The obvious reason is that
each one has been uniquely identified by a &lt;em&gt;name&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In order to emulate some form of what&amp;#8217;s called keyword arguments,
we can split the single function call into multiple stages.
Each one would then supply one piece of data,
with a matching function name serving as a readability&amp;nbsp;cue:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;response&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;sendRequest&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;
            &lt;span class="n"&gt;withHeaders&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;User-Agent&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;My Amazing App&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;
            &lt;span class="n"&gt;withBasicAuth&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;user&amp;quot;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;pass&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;
            &lt;span class="n"&gt;withData&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;field&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;
                &lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://example.com/foo&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If we follow this approach,
the caller would only invoke those intermediate functions
that fit his particular use case.
The &lt;span class="caps"&gt;API&lt;/span&gt; above could still offer &lt;code&gt;withCookies&lt;/code&gt;, &lt;code&gt;withFiles&lt;/code&gt;,
or any of the other combinators,
but their usage shall be completely&amp;nbsp;optional.&lt;/p&gt;
&lt;p&gt;Pretty neat,&amp;nbsp;right?&lt;/p&gt;
&lt;p&gt;Thing is, the implementation would be a little involved here.
We would clearly need to carry some data between the various &lt;code&gt;withFoo&lt;/code&gt; calls,
which requires some additional data types in addition to plain functions.
At minimum, we need something to represent the &lt;code&gt;Request&lt;/code&gt;,
as it is created by the &lt;code&gt;get&lt;/code&gt; function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;get&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Request&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and then &amp;#8220;piped&amp;#8221; through &lt;code&gt;withFoo&lt;/code&gt; transformers like this&amp;nbsp;one:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;withBasicAuth&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Request&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;so that it can we can finally send&amp;nbsp;it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;sendRequest&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Request&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kt"&gt;Response&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Such &lt;code&gt;Request&lt;/code&gt; type needs to keep track of all the additional parameters
that may have been tacked onto&amp;nbsp;it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Request&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Param&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;  &lt;span class="c1"&gt;-- Text is the URL&lt;/span&gt;

&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Param&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Header&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;BasicAuth&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Data&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
           &lt;span class="c1"&gt;-- and so on&lt;/span&gt;

&lt;span class="c1"&gt;-- example&lt;/span&gt;
&lt;span class="nf"&gt;withBasicAuth&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="n"&gt;pass&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;BasicAuth&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="n"&gt;pass&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;All of a sudden, what would be a single function explodes into a collection of data types
and associated&amp;nbsp;combinators.&lt;/p&gt;
&lt;p&gt;In Haskell at least,
we can forgo some of the boilerplate by automatically deriving an instance
of &lt;a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Monoid.html"&gt;&lt;code&gt;Monoid&lt;/code&gt;&lt;/a&gt;
(or perhaps a &lt;a href="https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Semigroup.html"&gt;&lt;code&gt;Semigroup&lt;/code&gt;&lt;/a&gt;).
Rather than invoking a series of combinators,
clients would then build their requests through repeated &lt;code&gt;mappend&lt;/code&gt;s&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;response&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;sendRequest&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://example.com/foo&amp;quot;&lt;/span&gt;
                          &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;header&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;User-Agent&amp;quot;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;My Awesome App&amp;quot;&lt;/span&gt;
                          &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;basicAuth&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;user&amp;quot;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;pass&amp;quot;&lt;/span&gt;
                          &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;field&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This mini-&lt;a href="https://en.wikipedia.org/wiki/Domain-specific_language"&gt;&lt;span class="caps"&gt;DSL&lt;/span&gt;&lt;/a&gt;
looks very similar to keyword arguments in Python,
as well as the equivalent Builder pattern from Java, Rust, and others.
What&amp;#8217;s disappointing, however,
is that it doesn&amp;#8217;t easily beat those solutions in terms of compile-time safety.
Unless you invest into some tricky type-level hacks,
there is nothing to prevent the users from building invalid requests at&amp;nbsp;runtime:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;reqParams&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://example.com/foo&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;--&lt;/span&gt;
&lt;span class="c1"&gt;-- ... lots of code in between ...&lt;/span&gt;
&lt;span class="c1"&gt;--&lt;/span&gt;
&lt;span class="nf"&gt;response&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;sendRequest&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;
            &lt;span class="n"&gt;reqParams&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://example.com/bar&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;-- woops!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Compared to a plain function (with however many arguments),
we have actually lost some measure of correctness&amp;nbsp;here.&lt;/p&gt;
&lt;h5&gt;Record&amp;nbsp;types&lt;/h5&gt;
&lt;p&gt;In many cases, fortunately,
there is another way to keep our calls both flexible and safe against runtime errors.
We just need to change the representation of the input type (here, &lt;code&gt;Request&lt;/code&gt;)
into a &lt;em&gt;record&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Record is simply a user-defined type that&amp;#8217;s a collection of &lt;em&gt;named fields&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Most languages (especially imperative ones: C, C++, Go, Rust, &amp;#8230;) call those &lt;em&gt;structures&lt;/em&gt;,
and use the &lt;code&gt;struct&lt;/code&gt; keyword to signify a record definition.
In functional programming parlance, they are also referred to as &lt;em&gt;product types&lt;/em&gt;;
this is because the joint record type is a Cartesian product of its individual field types&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;Going back to our example,
it shouldn&amp;#8217;t be difficult to define a record representing an &lt;span class="caps"&gt;HTTP&lt;/span&gt; &lt;code&gt;Request&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Request&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Request&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;reqURL&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;URL&lt;/span&gt;
                       &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;reqMethod&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Method&lt;/span&gt;
                       &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;reqHeaders&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="kt"&gt;Header&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                       &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;reqPostData&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                       &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In fact, I suspect most programmers would naturally reach for this notation&amp;nbsp;first.&lt;/p&gt;
&lt;p&gt;Having this definition,
calls to &lt;code&gt;sendRequest&lt;/code&gt; can be rewritten to take a record instance
that we construct on the spot&lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="#fn:4" rel="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;response&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;sendRequest&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;
    &lt;span class="kt"&gt;Request&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;reqURL&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://example.com/bar&amp;quot;&lt;/span&gt;
            &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;reqMethod&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;GET&lt;/span&gt;
            &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;reqHeaders&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;User-Agent&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;My Awesome App&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
            &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;reqPostData&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Compare this snippet to the Python example from the beginning of this section.
It comes remarkably close, right?
The &lt;code&gt;Request&lt;/code&gt; record and its fields can indeed work quite nicely
as substitutes for keyword&amp;nbsp;arguments.&lt;/p&gt;
&lt;p&gt;But besides the readability boon of having &amp;#8220;argument&amp;#8221; names at the call site.
we&amp;#8217;ve also gained stronger correctness checks.
For example, there is no way anymore to accidentally supply the &lt;span class="caps"&gt;URL&lt;/span&gt; field&amp;nbsp;twice.&lt;/p&gt;
&lt;h4&gt;Different functions for different&amp;nbsp;things&lt;/h4&gt;
&lt;p&gt;Astute readers may have noticed at least two things about the previous&amp;nbsp;solutions.&lt;/p&gt;
&lt;p&gt;First, they are not mutually incompatible.
Quite the opposite, actually: they compose very neatly, allowing us to combine
builder functions with the &lt;em&gt;record update&lt;/em&gt; syntax in the final &lt;span class="caps"&gt;API&lt;/span&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;response&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;sendRequest&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://example.com/baz&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;reqHeaders&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;User-Agent&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;My Awesome App&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This cuts out basically all the boilerplate of record-based calls,
leaving only the parts that actually differ from the defaults&lt;sup id="fnref:5"&gt;&lt;a class="footnote-ref" href="#fn:5" rel="footnote"&gt;5&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;But on the second and more important note:
we don&amp;#8217;t seem to be talking about &lt;em&gt;currying&lt;/em&gt; anymore.
Does it mean it loses its usefulness
once we go beyond certain threshold of&amp;nbsp;complexity?&amp;#8230;&lt;/p&gt;
&lt;p&gt;Thankfully, the answer is no.
While some APIs may require more advanced techniques
to access the full breadth of their functionality,
it is always possible to expose some carefully constructed facade
that is conducive to partial&amp;nbsp;application.&lt;/p&gt;
&lt;p&gt;Consider, for example, the functionality exposed by this set of &lt;span class="caps"&gt;HTTP&lt;/span&gt;&amp;nbsp;wrappers:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;URL&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Request&lt;/span&gt;
&lt;span class="nf"&gt;headWith&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="kt"&gt;Header&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;URL&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Request&lt;/span&gt;
&lt;span class="nf"&gt;get&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;URL&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Request&lt;/span&gt;
&lt;span class="nf"&gt;getWith&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="kt"&gt;Header&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;URL&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Request&lt;/span&gt;
&lt;span class="nf"&gt;postForm&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;URL&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Request&lt;/span&gt;
&lt;span class="nf"&gt;postFormWith&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="kt"&gt;Header&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;URL&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Request&lt;/span&gt;
&lt;span class="nf"&gt;toURL&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Method&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;URL&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Request&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Each one is obviously curry-friendly&lt;sup id="fnref:6"&gt;&lt;a class="footnote-ref" href="#fn:6" rel="footnote"&gt;6&lt;/a&gt;&lt;/sup&gt;.
Combined, they also offer a pretty comprehensive &lt;span class="caps"&gt;API&lt;/span&gt; surface.
And should they prove insufficient,
you&amp;#8217;d still have the builder pattern and/or record updates to fall back on &amp;#8212;
either for specialized one-off cases, or for writing your own&amp;nbsp;wrappers.&lt;/p&gt;
&lt;p&gt;Naturally, this technique of layered &lt;span class="caps"&gt;API&lt;/span&gt; design &amp;#8212;
with simple wrappers hiding a progressively more advanced core &amp;#8212;
isn&amp;#8217;t limited to just functional programming.
In some way, it is what &lt;em&gt;good&lt;/em&gt; &lt;span class="caps"&gt;API&lt;/span&gt; design looks like in general.
But in &lt;span class="caps"&gt;FP&lt;/span&gt; languages, it becomes especially important,
because the expressive benefits of partial application are so paramount&amp;nbsp;there&lt;/p&gt;
&lt;p&gt;Fortunately, these principles seem to be followed pretty consistently,
at least within the Haskell ecosystem.
You can see it in the design of
&lt;a href="https://www.stackage.org/haddock/lts-9.12/http-client-0.5.7.0/Network-HTTP-Client.html"&gt;the &lt;code&gt;http-client&lt;/code&gt; package&lt;/a&gt;,
which is the real world extension of the &lt;span class="caps"&gt;HTTP&lt;/span&gt; interface outlined here.
More evidently, it can be observed in any of the numerous packages
the expose both a basic &lt;code&gt;foo&lt;/code&gt; and a more customizable &lt;code&gt;fooWith&lt;/code&gt; functions;
popular examples include
&lt;a href="https://www.stackage.org/haddock/lts-9.12/async-2.1.1.1/Control-Concurrent-Async.html#v:cancelWith"&gt;the &lt;code&gt;async&lt;/code&gt; package&lt;/a&gt;,
&lt;a href="https://hackage.haskell.org/package/zlib-0.6.1.2/docs/Codec-Compression-Zlib.html#g:2"&gt;the &lt;code&gt;zlib&lt;/code&gt; library&lt;/a&gt;,
and &lt;a href="https://www.stackage.org/haddock/lts-9.12/regex-compat-tdfa-0.95.1.4/Text-Regex.html"&gt;the &lt;code&gt;Text.Regex&lt;/code&gt; module&lt;/a&gt;.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;It&amp;#8217;d be more common in Python to write this as &lt;code&gt;"Alice has a cat".split()&lt;/code&gt;,
but this form would make it less obvious how the arguments are passed.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;A great example of this pattern can be found
in the &lt;a href="http://hackage.haskell.org/package/optparse-applicative"&gt;&lt;em&gt;optparse-applicative&lt;/em&gt; package&lt;/a&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;Tuples (like &lt;code&gt;(Int, String)&lt;/code&gt;) are also product types.
They can be thought of as ad-hoc records where field indices serve as rudimentary &amp;#8220;names&amp;#8221;.
In fact, some languages even use the dotted notation to access fields
of both records/structs (&lt;code&gt;x.foo&lt;/code&gt;) and tuples (&lt;code&gt;y.0&lt;/code&gt;).&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;For simplicity, I&amp;#8217;m gonna assume the &lt;code&gt;URL&lt;/code&gt; and &lt;code&gt;Header&lt;/code&gt; types
can be &amp;#8220;magically&amp;#8221; constructed from string literals
through the &lt;span class="caps"&gt;GHC&lt;/span&gt;&amp;#8217;s &lt;code&gt;OverloadedStrings&lt;/code&gt; extension.&amp;#160;&lt;a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:5"&gt;
&lt;p&gt;In many languages,
we can specify more formally what the &amp;#8220;default&amp;#8221; means for a compound-type like &lt;code&gt;Request&lt;/code&gt;,
and sometimes even &lt;em&gt;derive&lt;/em&gt; it automatically.
Examples include
&lt;a href="https://hackage.haskell.org/package/data-default-0.7.1.1/docs/Data-Default.html#t:Default"&gt;the &lt;code&gt;Default&lt;/code&gt; typeclass&lt;/a&gt; in Haskell,
&lt;a href="https://doc.rust-lang.org/std/default/trait.Default.html"&gt;the &lt;code&gt;Default&lt;/code&gt; trait&lt;/a&gt; in Rust,
and the default/argumentless/trivial constructors in C++ &lt;em&gt;et al&lt;/em&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:5" rev="footnote" title="Jump back to footnote 5 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:6"&gt;
&lt;p&gt;Haskell programmers may especially notice how the last function is designed specifically
for infix application: &lt;code&gt;response &amp;lt;- sendRequest $ POST `toUrl` url&lt;/code&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:6" rev="footnote" title="Jump back to footnote 6 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="functional programming"></category><category term="currying"></category><category term="partial application"></category><category term="Haskell"></category><category term="API"></category><category term="abstraction"></category></entry><entry><title>O(n log n) isn’t bad</title><link href="http://xion.io/post/programming/o-nlogn-isnt-bad.html" rel="alternate"></link><updated>2017-10-19T14:59:00+00:00</updated><author><name>Karol Kuczmarski</name></author><id>tag:xion.io,2017-10-19:post/programming/o-nlogn-isnt-bad.html</id><summary type="html">&lt;p&gt;Most programmers should be familiar with the Big O notation of computational complexity.
This is how, in very theoretical terms, we are describing the relative differences in the performance of&amp;nbsp;algorithms.&lt;/p&gt;
&lt;p&gt;Excluding the case of constant time complexity (&lt;code&gt;O(1)&lt;/code&gt;),
the vast majority of practical algorithms falls into one of the following&amp;nbsp;classes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;O(log n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O(n log n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O(n²)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The further down a class is on this list, the worse (less efficient) it gets.
What may not be completely obvious, however, is the magnitude of&amp;nbsp;differences.&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s have a closer&amp;nbsp;look.&lt;/p&gt;
&lt;h4&gt;The best and the&amp;nbsp;worst&lt;/h4&gt;
&lt;p&gt;First, it&amp;#8217;s pretty easy when it comes to the extreme points.
A logarithmic complexity is clearly great,
because the number of operations barely even grows as the size of input increases.
For &lt;code&gt;N&lt;/code&gt; of one million,  the (natural&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;) logarithm is equal to about 14.
For one &lt;em&gt;trillion&lt;/em&gt; &amp;#8212; million times more &amp;#8212; &lt;code&gt;log n&lt;/code&gt; is only&amp;nbsp;27!&lt;/p&gt;
&lt;p&gt;Such amazing scalability is one of the reasons
why databases, for example,
can execute queries extremely efficiently even for millions or billions of&amp;nbsp;records.&lt;/p&gt;
&lt;p&gt;On the other end, an algorithm that has quadratic complexity
will only do well for very small datasets.
It can still be useful in practice,
especially as a small-input optimization of some larger procedure&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;,
or because of some other desirable properties (like good&amp;nbsp;parallelizability).&lt;/p&gt;
&lt;p&gt;Outside of those carefully selected cases, however,
the computational requirements of &lt;code&gt;O(n²)&lt;/code&gt; for any large dataset are usually too&amp;nbsp;great.&lt;/p&gt;
&lt;h4&gt;Middle&amp;nbsp;ground&lt;/h4&gt;
&lt;p&gt;As for the remaining two classes,
the linear one (&lt;code&gt;O(n)&lt;/code&gt;) is probably the easiest to reason&amp;nbsp;about.&lt;/p&gt;
&lt;p&gt;In a linear algorithm,
the number of operations increases steadily along with the size of input.&lt;br&gt;
For thousand elements, you need roughly a thousand steps (times a constant factor).&lt;br&gt;
For a million, there will be a million operations&amp;nbsp;necessary.&lt;/p&gt;
&lt;p&gt;Thus, by itself, the linear scaling doesn&amp;#8217;t get any better or worse when data gets bigger&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;.
In many cases, it means there is nothing to be exploited in the structure of input set
that could make the running time any better
(compared to e.g. the reliance of logarithmic searches on sorted order).
Typically, all the data must be traversed at least once in its&amp;nbsp;entirety.&lt;/p&gt;
&lt;p&gt;All in all, it can be a decent time complexity,
but it&amp;#8217;s nothing to write home&amp;nbsp;about.&lt;/p&gt;
&lt;h4&gt;A function has no&amp;nbsp;name&lt;/h4&gt;
&lt;p&gt;What about &lt;code&gt;O(n log n)&lt;/code&gt;, then?
It falls between the linear and the quadratic,
which suggests that it&amp;#8217;s somewhere half-way between mediocre and awful.
We don&amp;#8217;t even have a widely used word for it,
meaning it is probably not even that&amp;nbsp;important.&lt;/p&gt;
&lt;p&gt;Both of those suppositions are&amp;nbsp;wrong.&lt;/p&gt;
&lt;p&gt;First, &lt;code&gt;O(n log n)&lt;/code&gt; isn&amp;#8217;t even remotely close to the &amp;#8220;median&amp;#8221; (whatever that means) of &lt;code&gt;O(n)&lt;/code&gt; and &lt;code&gt;O(n²)&lt;/code&gt;.
In reality, its asymptotic rate of growth places it very close to the former.
You can see this pretty clearly by looking at the following&amp;nbsp;plot:&lt;/p&gt;
&lt;p style="text-align:center"&gt;
    &lt;img src="http://xion.io/images/time-complexity.png" alt="Time complexity plot"&gt;&lt;br&gt;
    &lt;small&gt;
        &lt;a href="http://coding-geek.com/how-databases-work/"&gt;Source&lt;/a&gt;
    &lt;/small&gt;
&lt;/p&gt;

&lt;p&gt;The gap between &lt;code&gt;O(n)&lt;/code&gt; and &lt;code&gt;O(n log n)&lt;/code&gt; barely even widens,
even as the values on vertical axis increase to the limits of&amp;nbsp;practicality.&lt;/p&gt;
&lt;p&gt;Indeed, the &lt;code&gt;log n&lt;/code&gt; part of the function grows slowly enough
that, for many practical purposes, it can be considered a large &amp;#8220;constant&amp;#8221; in the complexity formula.
Some complicated algorithm that&amp;#8217;s technically linear may therefore be a &lt;em&gt;worse&lt;/em&gt; choice
than a simpler solution with &lt;code&gt;O(n log n)&lt;/code&gt; scaling.&lt;/p&gt;
&lt;h4&gt;Sorting it&amp;nbsp;out&lt;/h4&gt;
&lt;p&gt;What are the typical situations where &lt;code&gt;O(n log n)&lt;/code&gt; arises in practice?
Very often, it has to do with establishing some kind of &lt;em&gt;ordering&lt;/em&gt; of the input
which includes at least one of the&amp;nbsp;following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a wholesale sorting of it (using pairwise&amp;nbsp;comparison)&lt;/li&gt;
&lt;li&gt;repeated queries for the current maximum or minimum (via a priority&amp;nbsp;queue)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Considering that many practical algoithms &amp;#8212;
from &lt;a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"&gt;pathfinding&lt;/a&gt;
to &lt;a href="https://en.wikipedia.org/wiki/Huffman_coding"&gt;compression&lt;/a&gt; &amp;#8212;
utilize some form of sorting or sorted data structures,
it makes &lt;code&gt;O(n log n)&lt;/code&gt; quite an important complexity&amp;nbsp;class.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Natural logarithm has a base of &lt;em&gt;e&lt;/em&gt; = 2.71828183&amp;#8230;
The exact choice of logarithm base doesn&amp;#8217;t matter for asymptotic complexity,
because it changes only the constant coefficient in the &lt;code&gt;O(f(n))&lt;/code&gt; function.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;A widely used example is &lt;a href="https://en.wikipedia.org/wiki/Timsort"&gt;Timsort&lt;/a&gt;
which switches from merge sort (&lt;code&gt;O(log n)&lt;/code&gt;) to insertion sort (&lt;code&gt;O(n²)&lt;/code&gt;)
when the array slice is short enough to warrant it.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;In reality, practical factors like memory/cache size, &lt;span class="caps"&gt;OS&lt;/span&gt; scheduling behavior,
and a myriad of other things can make the actual running time scale sublinearly beyond a certain point.&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="algorithms"></category><category term="complexity"></category><category term="Big O"></category></entry><entry><title>Rust as a gateway drug to Haskell</title><link href="http://xion.io/post/programming/rust-into-haskell.html" rel="alternate"></link><updated>2017-06-13T22:56:00+00:00</updated><author><name>Karol Kuczmarski</name></author><id>tag:xion.io,2017-06-13:post/programming/rust-into-haskell.html</id><summary type="html">&lt;p&gt;For work-related reasons,
I had to recently get up to speed on programming in &lt;a href="https://www.haskell.org/"&gt;Haskell&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Before that, I had very little actual experience with the language,
clocking probably at less than a thousand lines of working code over a couple of years.
Nothing impressive either:
some &lt;a href="https://gist.github.com/Xion/b8fdb6a896264915ad85"&gt;wrapper script&lt;/a&gt; here,
some &lt;a href="https://gist.github.com/Xion/1525222"&gt;experimental rewrite&lt;/a&gt;&amp;nbsp;there&amp;#8230;&lt;/p&gt;
&lt;p&gt;These days, I heard, there are a few resources for learning Haskell&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;
that don&amp;#8217;t require having a PhD in category theory&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;.
They may be quite helpful when your exposure to the functional programming is limited.
In my case, however, the one thing that &lt;em&gt;really&lt;/em&gt; enabled me to become (somewhat) productive
was not even related to Haskell at&amp;nbsp;all.&lt;/p&gt;
&lt;p&gt;It was &lt;a href="http://rust-lang.org/"&gt;Rust&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In theory, this shouldn&amp;#8217;t really make much of a sense.
If you compare both languages by putting checkmarks in a feature chart,
you won&amp;#8217;t find them to have much in&amp;nbsp;common.&lt;/p&gt;
&lt;p&gt;Some of the obvious differences&amp;nbsp;include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;predominantly functional vs. mostly&amp;nbsp;imperative&lt;/li&gt;
&lt;li&gt;garbage collection vs. explicit memory&amp;nbsp;management&lt;/li&gt;
&lt;li&gt;lazy vs. eager&amp;nbsp;evaluation&lt;/li&gt;
&lt;li&gt;rich runtime&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt; vs. almost no&amp;nbsp;runtime&lt;/li&gt;
&lt;li&gt;global vs. localized type&amp;nbsp;inference&lt;/li&gt;
&lt;li&gt;indentation vs.&amp;nbsp;braces&lt;/li&gt;
&lt;li&gt;two decades (!) vs. barely two years since&amp;nbsp;release&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Setting aside syntax, most of those differences are pretty&amp;nbsp;significant.&lt;/p&gt;
&lt;p&gt;You probably wouldn&amp;#8217;t use Haskell for embedded programming, for instance,
both for performance (&lt;span class="caps"&gt;GC&lt;/span&gt;) and memory usage reasons (laziness).
Similarly, Rust&amp;#8217;s ownership system can be too much of a hassle for high level code
that isn&amp;#8217;t subject to real time&amp;nbsp;requirements.&lt;/p&gt;
&lt;p&gt;But if you look a little deeper,
beyond just the surface descriptions of both languages,
you can find plenty of &lt;em&gt;concepts&lt;/em&gt; they&amp;nbsp;share.&lt;/p&gt;
&lt;h4&gt;Traits: they are typeclasses,&amp;nbsp;essentially&lt;/h4&gt;
&lt;p&gt;Take Haskell&amp;#8217;s typeclasses, for example &amp;#8212;
the cornerstone of its rich and expressive type&amp;nbsp;system.&lt;/p&gt;
&lt;p&gt;A &lt;a href="https://en.wikipedia.org/wiki/Type_class"&gt;&lt;em&gt;typeclass&lt;/em&gt;&lt;/a&gt; is, simply speaking,
a list of capabilities:
it defines what a type can &lt;em&gt;do&lt;/em&gt;.
There exist analogs of typeclasses in most programming languages,
but they are normally called interfaces or protocols,
and remain closely tied to the object-oriented&amp;nbsp;paradigm.&lt;/p&gt;
&lt;p&gt;Not so in&amp;nbsp;Haskell.&lt;/p&gt;
&lt;p&gt;Or in Rust for that matter, where the equivalent concept exists under the name of &lt;em&gt;traits&lt;/em&gt;.
What typeclasses and traits have in common is that
they&amp;#8217;re used for &lt;em&gt;all kinds of polymorphism&lt;/em&gt; in their respective&amp;nbsp;languages.&lt;/p&gt;
&lt;h5&gt;Generics&lt;/h5&gt;
&lt;p&gt;For example, let&amp;#8217;s consider &lt;em&gt;parametrized types&lt;/em&gt;,
sometimes also referred to as templates (C++) or generics&amp;nbsp;(C#).&lt;/p&gt;
&lt;p&gt;In many cases, a generic function or type requires its type arguments
to exhibit certain characteristics.
In some languages (like the legacy C++), this is checked only implicitly:
as long as the template type-checks after its expansion, everything is&amp;nbsp;okay:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="nl"&gt;b&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// OK&lt;/span&gt;
    &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;  &lt;span class="c1"&gt;// ERROR, no operator `&amp;gt;`&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;More advanced type systems, however, allow to specify the generic constraints &lt;em&gt;explicitly&lt;/em&gt;.
This is the case in&amp;nbsp;Rust:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;Ord&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;as well as in&amp;nbsp;Haskell:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;min&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Ord&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;min&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="kr"&gt;then&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="kr"&gt;else&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In both languages, the notion of a type supporting certain operations (like comparison/ordering)
is represented as its own, first-class concept:
a &lt;em&gt;trait&lt;/em&gt; (Rust) or a &lt;em&gt;typeclass&lt;/em&gt; (Haskell).
Since the compiler is aware of those constraints,
it can verify that the &lt;code&gt;min&lt;/code&gt; function is used correctly even before
it tries to generate code for a specific substitution of &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;
&lt;h5&gt;Dynamic&amp;nbsp;dispatch&lt;/h5&gt;
&lt;p&gt;On the other hand, let&amp;#8217;s look at &lt;em&gt;runtime polymorphism&lt;/em&gt;:
the one that &lt;span class="caps"&gt;OO&lt;/span&gt; languages implement
through abstract base classes and virtual methods.
It&amp;#8217;s the tool of choice if you need a container of objects of different types,
which nevertheless all expose the same&amp;nbsp;interface.&lt;/p&gt;
&lt;p&gt;To offer it, Rust has &lt;a href="https://doc.rust-lang.org/book/first-edition/trait-objects.html"&gt;&lt;em&gt;trait objects&lt;/em&gt;&lt;/a&gt;,
and they work pretty much exactly like base class pointers/references from Java, C++, or&amp;nbsp;C#.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Trait definition&lt;/span&gt;
&lt;span class="k"&gt;trait&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Draw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;draw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Data type implementing the trait&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Circle&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;i32&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Draw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Circle&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;draw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* omitted */&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Usage&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;draw_all&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Vec&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Box&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Draw&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;draw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The Haskell analogue is, in turn, based on typeclasses,
though the specifics can be a little bit&amp;nbsp;trickier:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;{-# LANGUAGE ExistentialQuantification #-}&lt;/span&gt;

&lt;span class="c1"&gt;-- Typeclass definition&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Draw&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
    &lt;span class="n"&gt;draw&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;-- Polymorphic wrapper type&lt;/span&gt;
&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Draw&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;forall&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="kt"&gt;Draw&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Draw&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Draw&lt;/span&gt; &lt;span class="kt"&gt;Draw&amp;#39;&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
    &lt;span class="n"&gt;draw&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Draw&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;draw&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;

&lt;span class="c1"&gt;-- Data types instantiating (&amp;quot;implementing&amp;quot;) the typeclass&lt;/span&gt;
&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Circle&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Circle&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Draw&lt;/span&gt; &lt;span class="kt"&gt;Circle&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt; &lt;span class="n"&gt;draw&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;undefined&lt;/span&gt; &lt;span class="c1"&gt;-- omitted&lt;/span&gt;
&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Square&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Square&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;Draw&lt;/span&gt; &lt;span class="kt"&gt;Square&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt; &lt;span class="n"&gt;draw&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;undefined&lt;/span&gt; &lt;span class="c1"&gt;-- omitted&lt;/span&gt;

&lt;span class="c1"&gt;-- Usage&lt;/span&gt;
&lt;span class="nf"&gt;drawAll&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Draw&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;drawAll&lt;/span&gt; &lt;span class="n"&gt;ds&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mapM_&lt;/span&gt; &lt;span class="n"&gt;draw&lt;/span&gt; &lt;span class="n"&gt;ds&lt;/span&gt;

&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Draw&amp;#39;&lt;/span&gt; &lt;span class="kt"&gt;Circle&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Draw&amp;#39;&lt;/span&gt; &lt;span class="kt"&gt;Square&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;drawAll&lt;/span&gt; &lt;span class="n"&gt;shapes&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here, the generic function can use typeclass constraints directly (&lt;code&gt;(Draw a) =&amp;gt; ...&lt;/code&gt;),
but creating a container of different object types requires a polymorphic wrapper&lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="#fn:4" rel="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h5&gt;Differences&lt;/h5&gt;
&lt;p&gt;All those similarities do not mean that
Rust traits and Haskell typeclasses are one and the same.
There are, in fact, quite a few differences, owing mostly to the fact that
Haskell&amp;#8217;s type system is more&amp;nbsp;expressive:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Rust lacks &lt;a href="https://en.wikipedia.org/wiki/Kind_(type_theory)#Kinds_in_Haskell"&gt;&lt;em&gt;higher kinded types&lt;/em&gt;&lt;/a&gt;,
  making certain abstractions impossible to encode as traits.
  It &lt;em&gt;is&lt;/em&gt; possible, however, to implement a trait for infinitely many types at once
  if the &lt;code&gt;impl&lt;/code&gt;ementation itself is generic
  (like &lt;a href="https://github.com/Xion/rofld/blob/2a9e427707cc93c716e011e99b0127f19cd770a5/src/lib/resources/mod.rs#L45"&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When defining a trait in Rust, you can ask implementors to provide some auxiliary,
  &lt;a href="https://doc.rust-lang.org/book/first-edition/associated-types.html"&gt;associated types&lt;/a&gt;
  in addition to just methods&lt;sup id="fnref:5"&gt;&lt;a class="footnote-ref" href="#fn:5" rel="footnote"&gt;5&lt;/a&gt;&lt;/sup&gt;.
  A similar mechanism in Haskell is expanded into &lt;a href="https://wiki.haskell.org/GHC/Type_families"&gt;type families&lt;/a&gt;,
  and requires enabling a &lt;a href="https://ocharles.org.uk/blog/posts/2014-12-12-type-families.html"&gt;&lt;span class="caps"&gt;GHC&lt;/span&gt; extension&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;While typeclasses in Haskell can be implemented for multiple types simultaneously
  via a &lt;a href="https://wiki.haskell.org/Multi-parameter_type_class"&gt;&lt;span class="caps"&gt;GHC&lt;/span&gt; extension&lt;/a&gt;,
  Rust&amp;#8217;s take on this feature is to make &lt;em&gt;traits themselves&lt;/em&gt; generic (e.g. &lt;code&gt;trait Foo&amp;lt;T&amp;gt;&lt;/code&gt;).
  The end result is roughly similar;
  however, the &amp;#8220;main implementing type&amp;#8221; (one after &lt;code&gt;for&lt;/code&gt; in &lt;code&gt;impl ... for ...&lt;/code&gt;)
  is still a method receiver (&lt;code&gt;self&lt;/code&gt;), just like in &lt;span class="caps"&gt;OO&lt;/span&gt;&amp;nbsp;languages.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rust enforces &lt;em&gt;coherence rules&lt;/em&gt; on trait implementations.
  The topic is actually
  &lt;a href="http://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/"&gt;rather complicated&lt;/a&gt;,
  but the gist is about local (current package) vs. remote (other packages / standard library)
  traits and types.&lt;br&gt;
  Without too much detail, coherence demands that there be a local type or trait
  somewhere in the &lt;code&gt;impl ... for ...&lt;/code&gt; construct.
  Haskell doesn&amp;#8217;t have this limitation,
  although it is recommended &lt;a href="https://wiki.haskell.org/Orphan_instance"&gt;not to take advantage of this&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;The&amp;nbsp;M-word&lt;/h4&gt;
&lt;p&gt;Another area of overlap between Haskell and Rust exists
in the &lt;em&gt;data model&lt;/em&gt; utilized by those languages.
Both are taking heavy advantage of &lt;a href="https://en.wikipedia.org/wiki/Algebraic_data_type"&gt;&lt;em&gt;algebraic data types&lt;/em&gt; (&lt;span class="caps"&gt;ADT&lt;/span&gt;)&lt;/a&gt;,
including the ability to define both &lt;em&gt;product types&lt;/em&gt; (&amp;#8220;regular&amp;#8221; structs and records)
as well as &lt;em&gt;sum types&lt;/em&gt; (tagged&amp;nbsp;unions).&lt;/p&gt;
&lt;h5&gt;&lt;code&gt;Maybe&lt;/code&gt; you&amp;#8217;d like &lt;code&gt;Some(T)&lt;/code&gt;?&lt;/h5&gt;
&lt;p&gt;Even more interestingly,
code in both languages makes extensive use of the two most basic&amp;nbsp;ADTs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Option&lt;/code&gt; (Rust) or &lt;code&gt;Maybe&lt;/code&gt; (Haskell) &amp;#8212;
  for denoting a presence or absence of a&amp;nbsp;value&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Result&lt;/code&gt; (Rust) or &lt;code&gt;Either&lt;/code&gt; (Haskell) &amp;#8212;
  for representing the alternative of &amp;#8220;correct&amp;#8221; and &amp;#8220;erroneous&amp;#8221;&amp;nbsp;value&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These aren&amp;#8217;t just simple datatypes.
They are deeply interwoven into the basic semantics of both languages,
not to mention their standard libraries and community-provided&amp;nbsp;packages.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Option&lt;/code&gt;/&lt;code&gt;Maybe&lt;/code&gt; type, for example,
is the alternative to &lt;em&gt;nullable references&lt;/em&gt;:
something that&amp;#8217;s been
&lt;a href="https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/"&gt;heavily criticized&lt;/a&gt;
for making programs prone to unexpected &lt;code&gt;NullReferenceException&lt;/code&gt;s.
The idea behind both of those types is to make actual values impossible to confuse with &lt;code&gt;null&lt;/code&gt;s
by encoding the potential nullability into the type&amp;nbsp;system:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;Some&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;None&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;!-- --&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;Result&lt;/code&gt; and &lt;code&gt;Either&lt;/code&gt;, on the other hand,
can be thought as an extension of this idea.
They also represent two possibilities,
but the &amp;#8220;wrong&amp;#8221; one isn&amp;#8217;t just &lt;code&gt;None&lt;/code&gt; or &lt;code&gt;Nothing&lt;/code&gt;
&amp;#8212; it has some more information associated with&amp;nbsp;it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;Result&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;Err&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;!-- --&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Either&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Left&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Right&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This dichotomy between the &lt;code&gt;Ok&lt;/code&gt; (or &lt;code&gt;Right&lt;/code&gt;) value and the &lt;code&gt;Err&lt;/code&gt;or value (or the &lt;code&gt;Left&lt;/code&gt; one)
makes it a great vehicle for carrying results of functions that can &lt;em&gt;fail&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In Rust, this replaces the traditional error handling mechanisms based on exceptions.
In Haskell, the exceptions are present and sometimes necessary,
but &lt;code&gt;Either&lt;/code&gt; is nevertheless the preferred approach to dealing with&amp;nbsp;errors.&lt;/p&gt;
&lt;h5&gt;What to &lt;code&gt;do&lt;/code&gt;?&lt;/h5&gt;
&lt;p&gt;One thing that Haskell does better is &lt;em&gt;composing&lt;/em&gt; those fallible functions
into bigger chunks of&amp;nbsp;logic.&lt;/p&gt;
&lt;p&gt;Relatively recently, Rust has added the &lt;a href="https://m4rw3r.github.io/rust-questionmark-operator"&gt;&lt;code&gt;?&lt;/code&gt; operator&lt;/a&gt;
as a replacement for the &lt;code&gt;try!&lt;/code&gt; macro.
This is now the preferred way of &lt;em&gt;error propagation&lt;/em&gt;,
allowing for a more concise composition of functions that return &lt;code&gt;Result&lt;/code&gt;s:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c-Doc"&gt;/// Read an integer from given file.&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_from_file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;Result&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;i32&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;File&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_to_string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;map_err&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Error&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ErrorKind&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InvalidData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But Haskell had it for much longer,
and it&amp;#8217;s something of a hallmark of the language and functional programming in general
&amp;#8212; even though it looks thoroughly &lt;em&gt;imperative&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;intFromFile&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
&lt;span class="nf"&gt;intFromFile&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;readFile&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;readIO&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
    &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you haven&amp;#8217;t seen it before, this is of course a &lt;em&gt;monad&lt;/em&gt; &amp;#8212; the &lt;code&gt;IO&lt;/code&gt; monad, to be precise.
While discussing monads in detail is way outside of the scope of this article,
we can definitely notice some analogies with Rust.
The &lt;code&gt;do&lt;/code&gt; notation with &lt;code&gt;&amp;lt;-&lt;/code&gt; arrows is evidently similar to
how in Rust you&amp;#8217;d assign the result of a fallible operation after &amp;#8220;unpacking&amp;#8221; it with &lt;code&gt;?&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But of course,
there&amp;#8217;s plenty of different monads in Haskell: not just &lt;code&gt;IO&lt;/code&gt;,
but also &lt;code&gt;Either&lt;/code&gt;, &lt;code&gt;Maybe&lt;/code&gt;, &lt;code&gt;Reader&lt;/code&gt;, &lt;code&gt;Writer&lt;/code&gt;, &lt;code&gt;Cont&lt;/code&gt;, &lt;code&gt;STM&lt;/code&gt;, and many others.
In Rust (at least as of 1.19), the &lt;code&gt;?&lt;/code&gt; operator only works for &lt;code&gt;Result&lt;/code&gt; types,
although there is &lt;a href="https://github.com/rust-lang/rfcs/issues/1718"&gt;some talk&lt;/a&gt;
about extending it to &lt;code&gt;Option&lt;/code&gt; as well&lt;sup id="fnref:6"&gt;&lt;a class="footnote-ref" href="#fn:6" rel="footnote"&gt;6&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;Eventually, we may see the language adopt some variant of the &lt;code&gt;do&lt;/code&gt; notation,
though the motivation for this will most likely come from
&lt;a href="https://github.com/alexcrichton/futures-await"&gt;asynchronous programming with &lt;code&gt;Future&lt;/code&gt;s&lt;/a&gt;
rather than plain &lt;code&gt;Result&lt;/code&gt;s.
General monads, however, require support for &lt;em&gt;higher kinded types&lt;/em&gt;
which &lt;a href="https://github.com/rust-lang/rfcs/issues/324"&gt;isn&amp;#8217;t coming anytime soon&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;A path through&amp;nbsp;Rust?&lt;/h4&gt;
&lt;p&gt;Now that we&amp;#8217;ve discussed those similarities,
the obvious question&amp;nbsp;arises.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Is learning Rust worthwhile
if your ultimate goal is getting proficient at functional programming in general,
or Haskell in&amp;nbsp;particular?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;My answer to that is actually pretty&amp;nbsp;straightforward.&lt;/p&gt;
&lt;p&gt;If &amp;#8220;getting to &lt;span class="caps"&gt;FP&lt;/span&gt;&amp;#8221; is your main goal, then Rust will &lt;em&gt;not&lt;/em&gt; help you very much.
Functional paradigm isn&amp;#8217;t the main idea behind the language &amp;#8212;
its shtick is mostly &lt;em&gt;memory safety&lt;/em&gt;, and zero-cost abstractions.
While it succeeds somewhat at being &amp;#8220;Haskell Lite&amp;#8221;,
it really strives to be &lt;em&gt;safer C++&lt;/em&gt;&lt;sup id="fnref:7"&gt;&lt;a class="footnote-ref" href="#fn:7" rel="footnote"&gt;7&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;But if, on the other hand, you regard &lt;span class="caps"&gt;FP&lt;/span&gt; mostly as a curiosity
that seems to be seeping into your favorite imperative language at an increasing rate,
Rust can be a good way to gain familiarity with this peculiar&amp;nbsp;beast.&lt;/p&gt;
&lt;p&gt;At the very least, you will learn the functional way of &lt;em&gt;modeling programs&lt;/em&gt;,
with lots of smart enums/unions and structs but without&amp;nbsp;inheritance.&lt;/p&gt;
&lt;p&gt;And the best part is: you will be so busy
&lt;a href="https://m-decoster.github.io//2017/01/16/fighting-borrowchk/"&gt;fighting the borrow checker&lt;/a&gt;
you won&amp;#8217;t even notice when it happens&amp;nbsp;;-)&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Just ask in &lt;code&gt;#haskell-beginners&lt;/code&gt; on Freenode if you&amp;#8217;re interested.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Though ironically,
I found the &lt;a href="https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_"&gt;&lt;span class="caps"&gt;CT&lt;/span&gt; lectures by Bartosz Milewski&lt;/a&gt;
very helpful in developing the right intuitions, even though they&amp;#8217;re very abstract.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;For example, Haskell has &lt;em&gt;green threads&lt;/em&gt; (created with &lt;code&gt;forkIO&lt;/code&gt;)
which are somewhat similar to goroutines from Go.
To get anything remotely similar in Rust, you need to use &lt;a href="http://tokio.rs"&gt;external libraries&lt;/a&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;Note that such containers aren&amp;#8217;t very idiomatic Haskell.
A more typical solution would be to just curry the &lt;code&gt;draw&lt;/code&gt; function,
implicitly putting the &lt;code&gt;Draw&lt;/code&gt; object inside its closure.&amp;#160;&lt;a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:5"&gt;
&lt;p&gt;This mechanisms expands to
&lt;a href="https://doc.rust-lang.org/1.6.0/book/associated-constants.html"&gt;associated constants&lt;/a&gt;
in Rust 1.20.&amp;#160;&lt;a class="footnote-backref" href="#fnref:5" rev="footnote" title="Jump back to footnote 5 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:6"&gt;
&lt;p&gt;Those two types also have a form of &lt;em&gt;monadic bind&lt;/em&gt; (&lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; in Haskell)
exposed as &lt;a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then"&gt;the &lt;code&gt;and_then&lt;/code&gt; method&lt;/a&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:6" rev="footnote" title="Jump back to footnote 6 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:7"&gt;
&lt;p&gt;If you want another language for easing into the concept of functional programming,
I&amp;#8217;ve heard that Scala fills that niche quite well.&amp;#160;&lt;a class="footnote-backref" href="#fnref:7" rev="footnote" title="Jump back to footnote 7 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="Rust"></category><category term="Haskell"></category><category term="traits"></category><category term="typeclasses"></category><category term="monads"></category><category term="ADTs"></category><category term="FP"></category></entry><entry><title>Long Live Dynamic Languages!</title><link href="http://xion.io/post/programming/long-live-dynamic-languages.html" rel="alternate"></link><updated>2017-05-24T19:07:00+00:00</updated><author><name>Karol Kuczmarski</name></author><id>tag:xion.io,2017-05-24:post/programming/long-live-dynamic-languages.html</id><summary type="html">&lt;p&gt;If you followed the few (or a dozen) of my recent posts,
you&amp;#8217;ve probably noticed a sizable bias in the choice of topics.
The vast majority were about &lt;a href="http://rust-lang.org"&gt;Rust&lt;/a&gt; &amp;#8212;
a native, bare metal, statically typed language with powerful compile time semantics
but little in the way of runtime&amp;nbsp;flexibility.&lt;/p&gt;
&lt;p&gt;Needless to say, Rust is radically different than (almost the exact opposite of) Python,
the other language that I&amp;#8217;m covering sometimes.
Considering this topical shift,
it would fair to assume that I, too, have subscribed to the whole Static Typing™&amp;nbsp;trend.&lt;/p&gt;
&lt;p&gt;But that wouldn&amp;#8217;t be very&amp;nbsp;accurate.&lt;/p&gt;
&lt;p&gt;Don&amp;#8217;t get me wrong.
As far as fashion cycles in the software industry go,
the current trend towards static/compiled languages is difficult to disparage.
Strong in both hype &lt;em&gt;and&lt;/em&gt; merit,
it has given us some &lt;a href="http://rust-lang.org"&gt;really innovative&lt;/a&gt;
&lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; &lt;a href="https://www.typescriptlang.org/"&gt;promising&lt;/a&gt; solutions
(as well as some &lt;a href="http://golang.org"&gt;not-so-innovative&lt;/a&gt; ones)
that are poised to shape the future of programming for years, if not decades to come.
In many ways, it is also correcting mistakes of &lt;a href="https://www.java.com/en/"&gt;the previous generation&lt;/a&gt;:
excessive boilerplate, byzantine abstractions, and software&amp;nbsp;bloat.&lt;/p&gt;
&lt;p&gt;What about dynamic languages, then?
Are they slowly going the way of the&amp;nbsp;dodo?&lt;/p&gt;
&lt;h4&gt;Trigger warning: &lt;code&gt;TypeError&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;Some programmers would certainly wish&amp;nbsp;so.&lt;/p&gt;
&lt;p&gt;Indeed, it&amp;#8217;s not hard at all to find
&lt;a href="https://arstechnica.com/information-technology/2014/06/why-do-dynamic-languages-make-it-difficult-to-maintain-large-codebases/"&gt;articles&lt;/a&gt;
and &lt;a href="https://www.reddit.com/r/rust/comments/6aqksm/rust_productivity_compared_to_other_languages/dhgp037/"&gt;opinions&lt;/a&gt;
about dynamic languages that are, well, less than&amp;nbsp;flattering.&lt;/p&gt;
&lt;p&gt;The common argument echoed in those accounts points to supposed unsuitability of Python et al.
for any large, multi-person project.
The reasoning can be summed up as &amp;#8220;good for small scripts and not much else&amp;#8221;.
Without statically checked types, the argument goes,
anything bigger than a quick hack or a prototype
shall inevitably become hairy and dangerous&amp;nbsp;monstrosity.&lt;/p&gt;
&lt;p&gt;And when that happens,
&lt;em&gt;a single typo&lt;/em&gt; can go unchecked and bring down the entire&amp;nbsp;system!&amp;#8230;&lt;/p&gt;
&lt;p&gt;At the very end of this spectrum of beliefs,
some pundits may eventually make the leap from languages to &lt;em&gt;people&lt;/em&gt;.
If dynamically typed languages (or &amp;#8220;untyped&amp;#8221; ones, as they&amp;#8217;re often mislabeled)
are letting even trivial bugs through,
then obviously anyone who wants to use them is
&lt;a href="https://danluu.com/images/empirical-pl/pl_godwin.png"&gt;dangerously irresponsible&lt;/a&gt;.
It must follow that all they &lt;em&gt;really&lt;/em&gt; want is to hack up some shoddy code,
&lt;em&gt;yolo&lt;/em&gt; it over to production, and let others worry about the&amp;nbsp;consequences.&lt;/p&gt;
&lt;h4&gt;Mind the&amp;nbsp;gap&lt;/h4&gt;
&lt;p&gt;It&amp;#8217;s likely unproductive to engage with someone who&amp;#8217;s that extreme.
If the rhetoric is dialed down, however, we can definitely find the edge of&amp;nbsp;reason.&lt;/p&gt;
&lt;p&gt;In my opinion, this fine line goes right through the &amp;#8220;good in small quantities&amp;#8221; argument.
I can certainly understand the apprehension towards large projects
that utilize dynamically typed languages throughout their codebases.
The prospect of such a project &lt;em&gt;is&lt;/em&gt; scary,
because it contains an additional element of uncertainty.
More so than with many other technologies,
you ought to &lt;em&gt;know what you&amp;#8217;re doing&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Some people (and teams) do. Others, not so&amp;nbsp;much.&lt;/p&gt;
&lt;p&gt;I would therefore refine the argument
so that it better reflects the strengths and weaknesses of dynamic languages.
They are perfectly suited for at least the following&amp;nbsp;cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;anyone writing small, standalone applications or&amp;nbsp;scripts&lt;/li&gt;
&lt;li&gt;&lt;em&gt;any project&lt;/em&gt; (large or small) with a well-functioning team of talented&amp;nbsp;individuals&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The sad reality of the software industry is the vast, gaping chasm of calamity and despair
that stretches between those two&amp;nbsp;scenarios.&lt;/p&gt;
&lt;p&gt;Within lies the bulk of commercial software projects,
consistently hamstrung by the usual suspects:
incompetent management, unclear and shifting requirements, under- or overstaffing,
ancient development practices, lack of coding standards, rampant bureaucracy,
&lt;a href="http://www.daedtech.com/how-developers-stop-learning-rise-of-the-expert-beginner/"&gt;inexperienced developers&lt;/a&gt;,
and so&amp;nbsp;on.&lt;/p&gt;
&lt;p&gt;In such an environment,
it becomes nigh impossible to capitalize on the strengths of dynamic languages.
Instead, the main priority is to protect from even further productivity losses,
which is what bog-standard languages like Java, C#, or Go tend to be pretty good at.
Rather than to move fast, the objective is to remain moving &lt;em&gt;at all&lt;/em&gt;.&lt;/p&gt;
&lt;h4&gt;Freedom of&amp;nbsp;choice&lt;/h4&gt;
&lt;p&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;But that&amp;#8217;s backwards&amp;#8221;, the usual retort goes.
&amp;#8220;Static typing and compilation checks are what &lt;em&gt;enables&lt;/em&gt; me to be&amp;nbsp;productive!&amp;#8221;&lt;/p&gt;
&lt;p&gt;I have no doubt that most people saying this do indeed believe
they&amp;#8217;re better off programming in static languages.
Regardless of what they think, however,
there exists &lt;a href="https://danluu.com/empirical-pl/"&gt;no conclusive evidence&lt;/a&gt;
to back up such claims as a universal&amp;nbsp;rule.&lt;/p&gt;
&lt;p&gt;This is of course the perennial problem with software engineering in general,
and the project management aspect of it in particular.
There is very little proper research on optimal and effective approaches to it,
which is why any of the so-called &amp;#8220;best practices&amp;#8221;
are quite likely to stem from &lt;a href="https://leanpub.com/leprechauns"&gt;unsubstantiated hearsay&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We can lament this state of affairs, of course.
But on the other hand, we can also find it &lt;em&gt;liberating&lt;/em&gt;.
In the absence of rigid prescriptions and judgments about productivity,
we are free to explore, within technical limitations,
what language works best for us, our team, and our&amp;nbsp;projects.&lt;/p&gt;
&lt;p&gt;Sometimes it&amp;#8217;ll be Go, Java, Rust, or even Haskell.&lt;br&gt;
A different situation may be best handled by Python, Ruby, or even&amp;nbsp;JavaScript.&lt;/p&gt;
&lt;p&gt;As the old adage goes, there is no silver bullet.
We should not try to polish static typing into&amp;nbsp;one.&lt;/p&gt;</summary><category term="Python"></category><category term="Rust"></category><category term="dynamic languages"></category><category term="dynamic typing"></category><category term="static typing"></category></entry><entry><title>Asynchronous Rust for fun &amp; profit</title><link href="http://xion.io/post/programming/rust-async-closer-look.html" rel="alternate"></link><updated>2017-05-20T14:33:00+00:00</updated><author><name>Karol Kuczmarski</name></author><id>tag:xion.io,2017-04-28:post/programming/rust-async-closer-look.html</id><summary type="html">&lt;p&gt;&lt;em&gt;&amp;#8230;or: Is Rust&amp;nbsp;webscale?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In this day and age, no language can really make an impact anymore
unless it enables its programmers to harness the power of the Internet.
&lt;a href="https://www.rust-lang.org/en-US/"&gt;Rust&lt;/a&gt; is no different here.
Despite posing as a true systems language
(as opposed to those &lt;a href="http://golang.org/"&gt;only marketed as such&lt;/a&gt;),
it includes &lt;a href="https://github.com/aturon/rfcs/blob/roadmap-2017/text/0000-roadmap-2017.md#rust-should-be-well-equipped-for-writing-robust-high-scale-servers"&gt;highly scalable servers&lt;/a&gt;
as a prominent objective in its 2017&amp;nbsp;agenda.&lt;/p&gt;
&lt;p&gt;Presumably to satisfy this very objective,
the Rust ecosystem has recently seen some major developments
in the space of &lt;em&gt;asynchronous I/O&lt;/em&gt;.
Given the pace of those improvements,
it may seem that production quality async services are quite possible&amp;nbsp;already.&lt;/p&gt;
&lt;p&gt;But is that so?
How exactly do you write async Rust servers in the early to mid&amp;nbsp;2017?&lt;/p&gt;
&lt;p&gt;To find out, I set to code up a toy application.
Said program was a small intermediary/&lt;span class="caps"&gt;API&lt;/span&gt; server (a &amp;#8220;microservice&amp;#8221;, if you will)
that tries to hit many of the typical requirements that arise in such projects.
The main objective was to test the limits of asynchronous Rust,
and see how easily (or difficult) they can be&amp;nbsp;pushed.&lt;/p&gt;
&lt;p&gt;This post is a summary of all the lessons I&amp;#8217;ve learned from&amp;nbsp;that.&lt;/p&gt;
&lt;p&gt;It is necessarily quite long,
so if you look for some &lt;span class="caps"&gt;TL&lt;/span&gt;;&lt;span class="caps"&gt;DR&lt;/span&gt;, scroll down straight to &lt;em&gt;Conclusions&lt;/em&gt;.&lt;/p&gt;
&lt;p align="center"&gt;&lt;img src="http://xion.io/images/jump-to-conclusions-mat.jpeg"&gt;&lt;/p&gt;

&lt;h4&gt;Asynchro-what?&lt;/h4&gt;
&lt;p&gt;Before we dive in, I have to clarify what &amp;#8220;asynchronous&amp;#8221; means in this context.
Those familiar with async concepts can freely skip this&amp;nbsp;section.&lt;/p&gt;
&lt;h5&gt;Pulling some&amp;nbsp;threads&lt;/h5&gt;
&lt;p&gt;Asynchronous processing (or &lt;em&gt;async&lt;/em&gt; for short) is brought up most often
in the context of I/O operations: disk reads, network calls, database queries,
and so&amp;nbsp;on.&lt;/p&gt;
&lt;p&gt;Relatively speaking, all those tasks tend to be &lt;em&gt;slow&lt;/em&gt;:
they take orders of magnitude longer than just executing code or even accessing &lt;span class="caps"&gt;RAM&lt;/span&gt;.
The &amp;#8220;traditional&amp;#8221; (synchronous) approach to dealing with them
is to relegate those tasks to separate &lt;em&gt;threads&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;When one thread has to wait for a lengthy I/O operation to complete,
the operating system (its &lt;em&gt;scheduler&lt;/em&gt;, to be precise) can suspend that thread.
This lets others execute their code in the mean time and not waste &lt;span class="caps"&gt;CPU&lt;/span&gt;&amp;nbsp;cycles.&lt;/p&gt;
&lt;p&gt;This is the essence of &lt;em&gt;concurrency&lt;/em&gt;&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h5&gt;Schedule&amp;nbsp;yourself&lt;/h5&gt;
&lt;p&gt;But threads are not the only option when dealing with many things (i.e. requests) at&amp;nbsp;once.&lt;/p&gt;
&lt;p&gt;The alternative approach is one where no threads are automatically suspended or resumed
by the &lt;span class="caps"&gt;OS&lt;/span&gt;. Instead, a special version of I/O subroutines
allows the program to continue execution immediately after issuing an I/O call.
While the operation happens in the background&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;,
the code is given an opaque handle &amp;#8212; usually called a promise, a &lt;em&gt;future&lt;/em&gt;,
or an async result &amp;#8212; that will eventually resolve to the actual return&amp;nbsp;value.&lt;/p&gt;
&lt;p&gt;The program can wait for the handle synchronously,
but it would typically hand it over to an &lt;em&gt;event loop&lt;/em&gt;,
an abstraction provided by a dedicated async framework.
Such a framework (among which node.js is probably the best known example)
maintains a list of all I/O &amp;#8220;descriptors&amp;#8221; (fds in Unix)
that are associated with pending I/O&amp;nbsp;operations.&lt;/p&gt;
&lt;p&gt;Then, in the loop, it simply waits on &lt;em&gt;all&lt;/em&gt; of them,
usually via the &lt;a href="https://en.wikipedia.org/wiki/Epoll"&gt;&lt;code&gt;epoll&lt;/code&gt; system call&lt;/a&gt;.
Whenever an I/O task completes, the loop would execute a &lt;em&gt;callback&lt;/em&gt; associated
with its result (or promise, or future).
Through this callback, the application is able to process&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;In a sense, we can treat the event loop as a dedicated scheduler for its&amp;nbsp;program.&lt;/p&gt;
&lt;h5&gt;But&amp;nbsp;why?&lt;/h5&gt;
&lt;p&gt;So, what exactly the benefit of asynchronous I/O?
If anything, it definitely sounds more complicated for the programmer. (Spoiler alert: it&amp;nbsp;is).&lt;/p&gt;
&lt;p&gt;The impetus for the development of async techniques most likely came from
the &lt;a href="http://www.kegel.com/c10k.html"&gt;&lt;span class="caps"&gt;C10K&lt;/span&gt; problem&lt;/a&gt;.
The short version of it is that computers are nowadays very fast
and should therefore be able to serve thousands of requests simultaneously.
(especially when those requests are mostly I/O, which translate to waiting time for the &lt;span class="caps"&gt;CPU&lt;/span&gt;).&lt;/p&gt;
&lt;p&gt;And if &amp;#8220;serving&amp;#8221; queries is indeed almost all waiting,
then handling thousands of clients should be very&amp;nbsp;possible.&lt;/p&gt;
&lt;p&gt;In some cases, however, it was found that when the &lt;span class="caps"&gt;OS&lt;/span&gt; is scheduling the threads,
it introduces too much overhead on the frequent pause/resume state changes (&lt;em&gt;context switching&lt;/em&gt;).
Like I mentioned above, the asynchronous alternative does away with all that,
and indeed lets the &lt;span class="caps"&gt;CPU&lt;/span&gt; just wait (on &lt;code&gt;epoll&lt;/code&gt;) until something interesting happens.
Once it does, the application can deal with it quickly,
issue another I/O call, and let the server go back to&amp;nbsp;waiting.&lt;/p&gt;
&lt;p&gt;With today&amp;#8217;s processing power we can theoretically handle
&lt;em&gt;a lot&lt;/em&gt; of concurrent clients this way: up to hundreds of thousands or even&amp;nbsp;millions.&lt;/p&gt;
&lt;h5&gt;Reality&amp;nbsp;check&lt;/h5&gt;
&lt;p&gt;Well, ain&amp;#8217;t that grand? No wonder everyone is writing everything in node.js&amp;nbsp;now!&lt;/p&gt;
&lt;p&gt;Jokes aside, the &lt;em&gt;actual&lt;/em&gt; benefits of asynchronous I/O
(especially when weighed against its inconvenience for developers)
are a bit harder to quantify.
For one, they rely heavily on the assumption of fast code &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; slow I/O being valid in all&amp;nbsp;situations.&lt;/p&gt;
&lt;p&gt;But this isn&amp;#8217;t really self-evident, and becomes increasingly dubious as time goes on
and code complexity grows.
It should be obvious, for example, that a Python web frontend
talking mostly to in-memory caches in the same datacenter will have radically different
performance characteristics than a C++ proxy server calling &lt;span class="caps"&gt;HTTP&lt;/span&gt; APIs over public Internet.
Those nuances are often lost in translation between simplistic benchmarks
and exaggerated blog posts&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;Upon a closer look, however, these details point quite clearly in favor of asynchronous Rust.
Being a language that compiles to native code, it should usually run faster
than interpreted (Python, Ruby) or even JITed (&lt;span class="caps"&gt;JVM&lt;/span&gt; &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; .&lt;span class="caps"&gt;NET&lt;/span&gt;) languages,
very close to what is typically referred to as &amp;#8220;bare metal&amp;#8221; speed.
For async I/O, it means the event loop won&amp;#8217;t be disturbed for a (relatively) long time
to do some trivial processing, leading to higher potential throughput of&amp;nbsp;requests.&lt;/p&gt;
&lt;p&gt;All in all, it would seem that Rust is one of the few languages
where async actually &lt;em&gt;makes sense&lt;/em&gt;.&lt;/p&gt;
&lt;h4&gt;Rust: the story so&amp;nbsp;far&lt;/h4&gt;
&lt;p&gt;Obviously, this means it&amp;#8217;s been built into the language right from the start&amp;#8230;&amp;nbsp;right?&lt;/p&gt;
&lt;p&gt;Well, not really.
It was always possible to use native &lt;code&gt;epoll&lt;/code&gt; through &lt;a href="https://doc.rust-lang.org/book/ffi.html"&gt;&lt;span class="caps"&gt;FFI&lt;/span&gt;&lt;/a&gt;,
of course, but that&amp;#8217;s not exactly the level of abstraction we&amp;#8217;d like to work with.
Still, the upper layers of the async I/O stack have been steadily growing at least since Rust&amp;nbsp;1.0.&lt;/p&gt;
&lt;p&gt;The major milestones here include &lt;a href="https://docs.rs/mio"&gt;&lt;em&gt;mio&lt;/em&gt;&lt;/a&gt;,
a comparatively basic building block that provides an asynchronous version of &lt;span class="caps"&gt;TCP&lt;/span&gt;/&lt;span class="caps"&gt;IP&lt;/span&gt;.
It also offers idiomatic wrappers over &lt;code&gt;epoll&lt;/code&gt;, allowing us to write our own event&amp;nbsp;loop.&lt;/p&gt;
&lt;p&gt;On the application side, &lt;a href="https://docs.rs/futures"&gt;the &lt;em&gt;futures&lt;/em&gt; crate&lt;/a&gt; abstracts the notion
of a potentially incomplete operation into, well, a &lt;em&gt;future&lt;/em&gt;.
Manipulating those futures is how one can now write asynchronous code in&amp;nbsp;Rust.&lt;/p&gt;
&lt;p&gt;More recently, &lt;a href="http://tokio.rs"&gt;Tokio&lt;/a&gt; has been emerging as
&lt;a href="https://blog.mozilla.org/blog/2017/04/10/mozilla-awards-365000-to-open-source-projects-as-part-of-moss/"&gt;&lt;em&gt;defacto&lt;/em&gt; framework&lt;/a&gt;
for async I/O in Rust. It essentially combines the two previously mentioned crates,
and provides additional abstractions specifically for network clients and&amp;nbsp;servers.&lt;/p&gt;
&lt;p&gt;And finally, the popular &lt;span class="caps"&gt;HTTP&lt;/span&gt; framework &lt;a href="http://hyper.rs"&gt;Hyper&lt;/a&gt; is now also supporting
asynchronous request handling via Tokio.
What this means is that bread-and-butter of the Internet&amp;#8217;s application layer &amp;#8212;
&lt;span class="caps"&gt;API&lt;/span&gt; servers talking &lt;span class="caps"&gt;JSON&lt;/span&gt; over &lt;span class="caps"&gt;HTTP&lt;/span&gt; &amp;#8212; should now be fully supported by the ecosystem
of asynchronous&amp;nbsp;Rust.&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s take it for a spin then, shall&amp;nbsp;we?&lt;/p&gt;
&lt;h4&gt;The Grand&amp;nbsp;Project&lt;/h4&gt;
&lt;p&gt;Earlier on, we have established that the main use case for asynchronous I/O
is intermediate microservices.
They often sit somewhere between a standard web frontend and a storage server or a database.
Because of their typical role within a bigger system,
these kinds of projects don&amp;#8217;t tend to be particularly exciting on their&amp;nbsp;own.&lt;/p&gt;
&lt;p&gt;But perhaps we can liven them up a&amp;nbsp;little.&lt;/p&gt;
&lt;p&gt;In the end, it is all about the Internet that we&amp;#8217;re talking here,
and everything on the Internet can usually be improved by one simple&amp;nbsp;addition.&lt;/p&gt;
&lt;p align="center"&gt;
    &lt;img src="http://xion.io/images/smoothie.jpeg"&gt;
    &lt;br/&gt;
    &lt;small style="text-side: xx-small"&gt;
        &lt;a href="http://www.boredpanda.com/beautiful-fluffy-cat-british-longhair/"&gt;
            Image source
        &lt;/a&gt;
    &lt;/small&gt;
&lt;/p&gt;

&lt;p&gt;&amp;#8230;Okay, &lt;em&gt;two&lt;/em&gt; possible additions &amp;#8212; the other one&amp;nbsp;being:&lt;/p&gt;
&lt;p align="center"&gt;&lt;img src="http://xion.io/images/oprah-memes.png" alt="Memes!"&gt;&lt;/p&gt;

&lt;p&gt;If you&amp;#8217;re really pedantic, you may call them &lt;em&gt;image macros&lt;/em&gt;.
But regardless of the name, the important part is putting text on pictures,
preferably in a funny&amp;nbsp;way.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/Xion/rofld"&gt;The microservice I wrote&lt;/a&gt; is doing just that.
Thought it won&amp;#8217;t ensure your memes are sufficiently hilarious,
it will try to deliver them exactly to
&lt;a href="https://github.com/Xion/rofld/blob/e25e9d01bdd7e85452e6a5922770dae941d5b61c/src/caption/mod.rs#L32"&gt;your specifications&lt;/a&gt;.
You may thus think of it as possible backend for
&lt;a href="http://www.quickmeme.com/caption"&gt;an image site like this one&lt;/a&gt;.&lt;/p&gt;
&lt;h5&gt;Flimsy excuses &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; post-hoc&amp;nbsp;justifications&lt;/h5&gt;
&lt;p&gt;It is, of course, a &lt;em&gt;complete&lt;/em&gt; coincidence,
lacking &lt;em&gt;any&lt;/em&gt; premeditation on my part,
that when it comes to evaluating an async platform,
a service like this fits the bill &lt;em&gt;very well&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;And especially when said platform is async &lt;em&gt;Rust&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Why, though, is it such a happy, er,&amp;nbsp;accident?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;It&amp;#8217;s a simple, well-defined application&lt;/strong&gt;.
  There is basically a &lt;a href="https://github.com/Xion/rofld/blob/e25e9d01bdd7e85452e6a5922770dae941d5b61c/src/service.rs#L33"&gt;single endpoint&lt;/a&gt;,
  accepting simple input (&lt;span class="caps"&gt;JSON&lt;/span&gt; or query string) and producing a straightforward result (an image).
  No need to persist any state made creating
  &lt;a href="https://github.com/Xion/rofld/blob/8026eab34ea54c4ba1b814c1114b3f5d87020233/src/main.rs"&gt;an &lt;span class="caps"&gt;MVP&lt;/span&gt;&lt;/a&gt;
  significantly&amp;nbsp;easier.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Caching can be used for meme templates and fonts.&lt;/strong&gt;
  Besides being an inherent part of most network services,
  a cache also represents a point of contention for Rust programs.
  The language is widely known for its alergy to global mutable state,
  which is exactly what programmatic caches boil down&amp;nbsp;to.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Image captioning is a &lt;span class="caps"&gt;CPU&lt;/span&gt;-intensive operation.&lt;/strong&gt;
  While the &amp;#8220;async&amp;#8221; part of async I/O may sometimes go all the way down,
  many practical services either evolve some important &lt;span class="caps"&gt;CPU&lt;/span&gt;-bound code,
  or require it right from the start.
  For this reason, I wanted to check if &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; how async Rust can mix
  with threaded&amp;nbsp;concurrency.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Configuration knobs can be added.&lt;/strong&gt;
  Unlike trivial experiments in the vein of an echo or &amp;#8220;Hello world&amp;#8221; server,
  this kind of service warrants some flags that the user could tweak,
  like the number of image captioning threads, or the size of the template cache.
  We can see how easy (or how hard) it is to make them applicable across
  all future-based&amp;nbsp;requests.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All in all, and despite its frivolous subject matter,
a meme server is actually hitting quite a few notable spots in the microservice&amp;nbsp;domain.&lt;/p&gt;
&lt;p align="center"&gt;
    &lt;img src="http://xion.io/images/meme-shocked.png" alt=""&gt;
&lt;/p&gt;

&lt;h4&gt;Learnings&lt;/h4&gt;
&lt;p&gt;As you may glean from its &lt;a href="https://github.com/Xion/rofld"&gt;GitHub repo&lt;/a&gt;,
it would seem that the experiment was successful.
Sure, you could implement some features in the captioning department
(supporting animated GIFs comes to mind),
but none of these are pertinent to the async mechanics of the&amp;nbsp;server.&lt;/p&gt;
&lt;p&gt;And since it&amp;#8217;s the async (I/O) in Rust that we&amp;#8217;re interested in,
let me now present you with an assorted collection of practical experiences with&amp;nbsp;it.&lt;/p&gt;
&lt;h5&gt;&amp;gt;0-cost&amp;nbsp;futures&lt;/h5&gt;
&lt;p&gt;If you read the docs&amp;#8217; preamble to &lt;a href="https://docs.rs/futures"&gt;the &lt;code&gt;futures&lt;/code&gt; crate&lt;/a&gt;,
you will see it mentioning the &amp;#8220;zero-cost&amp;#8221; aspect of the library.
Consistent with the philosophy behind Rust,
it proclaims to deliver its abstractions without any&amp;nbsp;overhead.&lt;/p&gt;
&lt;p&gt;Thing is, I&amp;#8217;m not sure how this promise can be delivered on in&amp;nbsp;practice.&lt;/p&gt;
&lt;p&gt;Flip through &lt;a href="https://tokio.rs/docs/getting-started/simple-server/"&gt;the introductory tutorial to Tokio&lt;/a&gt;,
for example, and you will already find plenty of compromises.
Without the crucial (but nightly-only)
&lt;a href="https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md"&gt;&lt;code&gt;impl Trait&lt;/code&gt; feature&lt;/a&gt;,
you are basically required to put all your futures in a &lt;code&gt;Box&lt;/code&gt;&lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="#fn:4" rel="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt;.
They even encourage it themselves, offering a convenient
&lt;a href="https://docs.rs/futures/0.1.13/futures/future/trait.Future.html#method.boxed"&gt;&lt;code&gt;Future::boxed&lt;/code&gt; method&lt;/a&gt;
exactly for this purpose, as well the matching
&lt;a href="https://docs.rs/futures/0.1.13/futures/future/type.BoxFuture.html"&gt;&lt;code&gt;BoxFuture&lt;/code&gt; typedef&lt;/a&gt;
right in the&amp;nbsp;crate.&lt;/p&gt;
&lt;p&gt;But hey, you can always just use nightly Rust, right?
&lt;code&gt;impl Trait&lt;/code&gt; will stabilize eventually, so your code should be, ahem, &lt;em&gt;future-proof&lt;/em&gt; either&amp;nbsp;way.&lt;/p&gt;
&lt;p&gt;Unfortunately, this assumes all the futures that you&amp;#8217;re building your request handlers from
shall never cross any thread boundaries.
(&lt;code&gt;BoxFuture&lt;/code&gt;, for example, automatically constrains them to be &lt;code&gt;Send&lt;/code&gt;).
As you&amp;#8217;ve likely guessed, this doesn&amp;#8217;t jive very well with computationally intensive tasks
which are best relegated to a separate&amp;nbsp;thread.&lt;/p&gt;
&lt;p&gt;To deal with them properly, you&amp;#8217;re going to need a thread pool-based executor,
which is currently implemented in the &lt;a href="https://docs.rs/futures-cpupool"&gt;&lt;code&gt;futures_cpupool&lt;/code&gt; crate&lt;/a&gt;.
Using it requires a lot of care, though,
and a deep understanding of &lt;em&gt;both&lt;/em&gt; types of concurrency&amp;nbsp;involved.&lt;/p&gt;
&lt;p&gt;Evidently, this was something that I lacked at the time,
which is why I encountered problems ensuring that my futures are properly &lt;code&gt;Send&lt;/code&gt;.
In the end, I settled on &lt;em&gt;making&lt;/em&gt; them &lt;code&gt;Send&lt;/code&gt; in the most straightforward
(and completely &lt;a href="https://github.com/Xion/rofld/commit/19d37cef4bb2e917e54c862ef138c7da4378d03e"&gt;unnecessary&lt;/a&gt;) manner:
by &lt;a href="https://github.com/Xion/rofld/blob/7e7d3b160594689d2e4c80b7328f90f34546b955/src/ext.rs#L39"&gt;wrapping them in &lt;code&gt;Arc&lt;/code&gt;/&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;.
That in itself wasn&amp;#8217;t
&lt;a href="https://github.com/Xion/rofld/commit/15bcd60f76a97badb9b90721179daa0845b139dd#diff-126a37e2b594610dd09c3f228d9d1717L52"&gt;without its perils&lt;/a&gt;,
but at least allowed me to move&amp;nbsp;forward.&lt;/p&gt;
&lt;p&gt;Ironically, this also shows an important, pragmatic property of the futures&amp;#8217; system:
sub-par hacks around it &lt;em&gt;are&lt;/em&gt; possible &amp;#8212;
a fact you&amp;#8217;ll be glad to know about on the proverbial day before a&amp;nbsp;deadline.&lt;/p&gt;
&lt;h5&gt;Templates-worthy error&amp;nbsp;messages&lt;/h5&gt;
&lt;p&gt;Other significant properties of the futures&amp;#8217; abstraction shall include
telling the programmer what&amp;#8217;s wrong with his code in the simplest,
most straightforward, and concise manner&amp;nbsp;possible.&lt;/p&gt;
&lt;p&gt;Here, let me show you an&amp;nbsp;example:&lt;/p&gt;
&lt;p align="center"&gt;
    &lt;img src="http://xion.io/images/rust-futures-error.png"&gt;&lt;br&gt;
    &lt;small&gt;
        &amp;#8230;which you can also behold in its
        &lt;a href="https://gist.github.com/Xion/df1fb7fffa1afb4bfbf2838b9c3fc4c1"&gt;
            gist form
        &lt;/a&gt;.
    &lt;/small&gt;
&lt;/p&gt;

&lt;p&gt;The reason you will encounter such incomprehensible messages
stems from the very building blocks of async&amp;nbsp;code.&lt;/p&gt;
&lt;p&gt;Right now, each chained operation on a future &amp;#8212; &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;and_then&lt;/code&gt;, &lt;code&gt;or_else&lt;/code&gt;, and so on &amp;#8212;
produces a &lt;em&gt;nested type&lt;/em&gt;.
Every subsequent application of those methods
&amp;#8220;contains&amp;#8221; (in terms of the type system) &lt;em&gt;all the previous ones&lt;/em&gt;.
Keep going, and it will eventually balloon into one big onion of &lt;code&gt;Chain&amp;lt;Map&amp;lt;OrElse&amp;lt;Chain&amp;lt;Map&amp;lt;...etc...&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p align="center"&gt;
    &lt;img src="http://xion.io/images/meme-yo-dawg.jpeg"&gt;&lt;br&gt;
    &lt;small&gt;Futures are like ogres.&lt;/small&gt;
&lt;/p&gt;

&lt;p&gt;I haven&amp;#8217;t personally hit any compiler limits in this regard,
but I&amp;#8217;m sure it is plausible for a complicated, real-world&amp;nbsp;program.&lt;/p&gt;
&lt;p&gt;It also gets &lt;em&gt;worse&lt;/em&gt; if you use nightly Rust with &lt;code&gt;impl Trait&lt;/code&gt;.
In this case, function boundaries no longer &amp;#8220;break&amp;#8221; type stacking
via &lt;code&gt;Box&lt;/code&gt;ing the results into trait objects.
Indeed, you can very well end up with some truly gigantic constructs
as the compiler tries represent the return types of your most complex&amp;nbsp;handlers.&lt;/p&gt;
&lt;p&gt;But even if rustc is up to snuff and can deal with those fractals just fine,
it doesn&amp;#8217;t necessarily mean the &lt;em&gt;programmer&lt;/em&gt; can.
Looking at those error messages,
I had vivid flashbacks from hacking on C++ templates with ancient compilers like &lt;span class="caps"&gt;VS2005&lt;/span&gt;.
The difference is, of course, that we&amp;#8217;re not trying any arcane metaprogramming here;
we just want to do some relatively mundane&amp;nbsp;I/O.&lt;/p&gt;
&lt;p&gt;I have no doubt the messaging will eventually improve,
and the mile-long types will at least get pretty-printed.
At the moment, however, prepare for some serious squinting and&amp;nbsp;bracket-counting.&lt;/p&gt;
&lt;h5&gt;Where is my (language)&amp;nbsp;support?&lt;/h5&gt;
&lt;p&gt;Sadly, those long, cryptic error messages are not the only way
in which the Rust compiler disappoints&amp;nbsp;us.&lt;/p&gt;
&lt;p&gt;I keep mentioning &lt;code&gt;impl Trait&lt;/code&gt; as a generally desirable language feature
for writers of asynchronous code.
This improvement is still a relatively long way from getting precisely
&lt;a href="https://github.com/aturon/rfcs/blob/expand-impl-trait/text/0000-expand-impl-trait.md"&gt;&lt;em&gt;defined&lt;/em&gt;&lt;/a&gt;,
much less stabilized.
And it is only a somewhat minor improvement in the async&amp;nbsp;ergonomics.&lt;/p&gt;
&lt;p&gt;The wishlist is vastly longer and even more&amp;nbsp;inchoate.&lt;/p&gt;
&lt;p&gt;Saying it bluntly, right now Rust doesn&amp;#8217;t really support the async style &lt;em&gt;at all&lt;/em&gt;.
All the combined &lt;span class="caps"&gt;API&lt;/span&gt; surface of futures/Tokio/Hyper/etc. is a clever,
but ultimately contrived design,
and it has no intentional backing in the Rust language&amp;nbsp;itself.&lt;/p&gt;
&lt;p&gt;This is a stark contrast with numerous other languages.
They often support asynchronous I/O as something of a first class feature.
The list includes at least
&lt;a href="https://msdn.microsoft.com/en-us/library/mt674882.aspx"&gt;C#&lt;/a&gt;,
&lt;a href="https://docs.python.org/3/library/asyncio-task.html"&gt;Python 3.5+&lt;/a&gt;,
&lt;a href="https://docs.hhvm.com/hack/async/awaitables"&gt;Hack/&lt;span class="caps"&gt;PHP&lt;/span&gt;&lt;/a&gt;,
&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function"&gt;&lt;span class="caps"&gt;ES8&lt;/span&gt; / JavaScript&lt;/a&gt;,
and basically all the functional languages.
They all have dedicated &lt;code&gt;async&lt;/code&gt;, &lt;code&gt;await&lt;/code&gt;, or equivalent constructs
that make the callback-based nature of asynchronous code essentially&amp;nbsp;transparent.&lt;/p&gt;
&lt;p&gt;The absence of similar support puts Rust in the same bucket as frontend JavaScript circa 2010,
where &lt;code&gt;.then&lt;/code&gt;-chaining of promises reigned supreme.
This is of course better than the callback hell of early Node,
but I wouldn&amp;#8217;t think that&amp;#8217;s a particularly high bar.
In this regard, Rust leaves plenty to be&amp;nbsp;desired.&lt;/p&gt;
&lt;p&gt;There are &lt;a href="https://github.com/vadimcn/rfcs/blob/coroutines2/text/0000-coroutines.md"&gt;proposals&lt;/a&gt;,
obviously, to bring async coroutines into Rust.
There is an even broader wish to make the language cross the &lt;span class="caps"&gt;OOP&lt;/span&gt;/&lt;span class="caps"&gt;FP&lt;/span&gt; fence already
and commit to the functional way; this would mean adding an equivalent of Haskell&amp;#8217;s &lt;code&gt;do&lt;/code&gt; notation.&lt;/p&gt;
&lt;p&gt;Either development could be sufficient.
Both, however, require significant amount of design and implementation work.
If solved now, this would easily be the most significant addition to the language
since its 1.0 release &amp;#8212; but the solution is currently in the &lt;span class="caps"&gt;RFC&lt;/span&gt; stages &lt;em&gt;at best&lt;/em&gt;.&lt;/p&gt;
&lt;h5&gt;Future&amp;lt;Ecosystem&amp;gt;&lt;/h5&gt;
&lt;p&gt;While the core language support is lacking,
the great as usual Rust community has been picking up some of the slack
by establishing and cultivating a steadily growing&amp;nbsp;ecosystem.&lt;/p&gt;
&lt;p&gt;The constellation of async-related crates clusters mostly around the two core libraries:
&lt;code&gt;futures&lt;/code&gt; crate itself and Tokio.
Any functionality you may need while writing asynchronous should likely be found
quite easily by searching for one of those two keywords (plus Rust, of course).
Another way of finding what you need is to look at
&lt;a href="https://tokio.rs/docs/going-deeper-tokio/third-party/"&gt;the list of Tokio-related crates&lt;/a&gt;&amp;nbsp;directly.&lt;/p&gt;
&lt;p&gt;To be fair, I can&amp;#8217;t really say much about the completeness of this ecosystem.
The project didn&amp;#8217;t really require too many external dependencies &amp;#8212;
the only relevant ones&amp;nbsp;were:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;futures_cpupool&lt;/code&gt; mentioned&amp;nbsp;before&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tokio-timer&lt;/code&gt; for imposing a timeout on caption&amp;nbsp;requests&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tokio-signal&lt;/code&gt; which handles &lt;span class="caps"&gt;SIGINT&lt;/span&gt;/Ctrl+C  and allows for a graceful&amp;nbsp;shutdown&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Normally, you&amp;#8217;d also want to research the async database drivers
for your storage system of choice.
I would not expect anything resembling the &lt;a href="http://diesel.rs"&gt;Diesel&lt;/a&gt; &lt;span class="caps"&gt;ORM&lt;/span&gt; crate, though,
nor a web framework comparable to &lt;a href="http://ironframework.io/"&gt;Iron&lt;/a&gt;,
&lt;a href="https://fengsp.github.io/pencil/pencil/"&gt;Pencil&lt;/a&gt;,
or &lt;a href="https://rocket.rs/"&gt;Rocket&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Conclusions&lt;/h4&gt;
&lt;p&gt;Alright, so what can we get from this overall&amp;nbsp;analysis?&lt;/p&gt;
&lt;p&gt;Given the rapid development of async Rust ecosystem so far,
it is clear the technology is very promising.
If the community maintains its usual enthusiasm and keeps funneling it into Tokio et al.,
it won&amp;#8217;t be long before it matures into something&amp;nbsp;remarkable.&lt;/p&gt;
&lt;p&gt;Right now, however, it exposes way too many rough edges to fully bet on it.
Still, there may be some applications
where you could get away with an async Rust backend even in production.
But personally, I wouldn&amp;#8217;t recommend it outside of non-essential services,
or tools internal to your&amp;nbsp;organization.&lt;/p&gt;
&lt;p&gt;If you do use async Rust for microservices,
I&amp;#8217;d also advise to take steps to ensure they remain &amp;#8220;micro&amp;#8221;.
Like I&amp;#8217;ve elaborated in the earlier sections,
there are several issues that make future-based Rust code scale poorly
with respect to maintainability.
Keeping it simple is therefore&amp;nbsp;essential.&lt;/p&gt;
&lt;p&gt;To sum up, async Rust is currently an option only for the adventurous and/or small.
Others should stick to a tried &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; tested solution:
something like Java (with &lt;a href="http://docs.paralleluniverse.co/quasar/"&gt;Quasar&lt;/a&gt;),
.&lt;span class="caps"&gt;NET&lt;/span&gt;, Go, or perhaps node.js at the very&amp;nbsp;least.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;It is also the crux of parallelism,
but &lt;a href="https://www.youtube.com/watch?v=cN_DpYBzKso"&gt;that&amp;#8217;s different&lt;/a&gt; and is not the focus here.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;Background&amp;#8221; here refers to the low level, innate concurrency of the &lt;span class="caps"&gt;OS&lt;/span&gt; kernel
(mediated with hardware interrupts), not the &lt;code&gt;epoll&lt;/code&gt;-based event loops on the application side.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;There is a great parallel to be drawn between a trivial echo/Hello world server,
and a 3D graphics program that only redraws an empty screen.
Both may start at some very high performance numbers (requests/frames per second)
but once you start adding practical stuff, those metrics must drop &lt;em&gt;hyperbolically&lt;/em&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;&lt;em&gt;Technically&lt;/em&gt;, you are not, but the alternative is extremely cumbersome.&lt;br&gt;
In short, you&amp;#8217;d have to follow an approach similar to custom &lt;code&gt;Iterator&lt;/code&gt;s:
define a new struct for each individual case
(possibly just &lt;a href="https://doc.rust-lang.org/book/structs.html#tuple-structs"&gt;newtype&lt;/a&gt;&amp;#8216;ing an existing one),
and then implement the necessary trait for it.&lt;br&gt;
For iterators, this works reasonably well,
and you don&amp;#8217;t need custom ones that often anyway.
But futures, by their very nature, are meant to encapsulate &lt;em&gt;any&lt;/em&gt; computation.
For them, &amp;#8220;each individual case&amp;#8221; is literally &lt;em&gt;every asynchronous function&lt;/em&gt; in your code.&amp;#160;&lt;a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="Rust"></category><category term="async"></category><category term="Tokio"></category><category term="futures"></category><category term="HTTP"></category></entry></feed>