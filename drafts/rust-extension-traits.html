<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/font-awesome.min.css">

    <link href="http://xion.io/style.css" rel="stylesheet">




  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

<meta name="author" content="Karol Kuczmarski" />
<meta name="description" content="In a few object-oriented languages, it is possible to add methods to a class after it’s already been defined. This feature arises quite naturally if the language has a dynamic type system that’s modifiable at runtime. In those cases, even replacing existing methods is perfectly possible1. In addition to that, some statically typed languages — most notably in C# — offer extension methods as a dedicated feature of their type systems. The premise is that you would write standalone functions whose first argument is specially designated (usually by this keyword) as a receiver of the resulting method call: public static int WordCount(this String str) { return str.Split(new char[] { &#39; &#39;, &#39;.&#39;, &#39;?&#39; }, StringSplitOptions.RemoveEmptyEntries).Length; } At the call site, the new method is indistinguishable from any of the existing ones: string s = &#34;Alice has a cat.&#34;; int n = s.WordCount(); That’s assuming you have imported both the original class (or it’s a built-in like String), as well as the module in which the extension method is defined. Rewrite it in Rust The curious thing about Rust‘s type system is that it permits extension methods solely as a side effect of its core building block: traits. In this post, I’m going to describe a certain design pattern in Rust which involves third-party types and user-defined traits. Several popular crates — like itertools or unicode-normalization — utilize it very successfully to add new, useful methods to the language standard types. I’m not sure if this pattern has an official or widely accepted name. Personally, I’ve taken to calling it extension traits. Let’s have a look at how they are commonly implemented. Ingredients We can use the extension trait pattern if we want to have additional methods in a type that we don’t otherwise control (or don’t want to modify). Common cases include: Rust standard library types, like Iterator, String, or anything else inside the std namespace types imported from third-party libraries types from the current crate if additional methods only make sense in certain scenarios (e.g. conditional compilation / testing)2 The crux of this technique is really simple. Like with most design patterns, however, it involves a certain degree of boilerplate and duplication. So without further ado… In order to “patch” some new method(s) into an external type you will need to: Define a trait with signatures of all the methods you want to add. Implement it for the external type. There is no step three. As an important note on the usage side, the calling code needs to import your new trait in addition to the external type. Once that’s done, it can proceed to use the new methods is if they were there to begin with. I’m sure you are keen on seeing some examples! Broadening your Options We’re going to add two new methods to Rust’s standard Option type. The goal is to make it more convenient to operate on mutable Options by allowing to easily replace an existing value with another one3. Here’s the appropriate extension trait4: /// Additional mutation methods for `Option`. pub trait OptionMutExt&lt;T&gt; { /// Replace the existing `Some` value with a new one. /// /// Returns the previous value if it was present, or `None` if no replacement was made. fn replace(&amp;mut self, val: T) -&gt; Option&lt;T&gt;; /// Replace the existing `Some` value with the result of given closure. /// /// Returns the previous value if it was present, or `None` if no replacement was made. fn replace_with&lt;F: FnOnce() -&gt; T&gt;(&amp;mut self, f: F) -&gt; Option&lt;T&gt;; } It may feel at little bit weird to implement it. You will basically have to pretend you are inside the Option type itself: impl&lt;T&gt; OptionMutExt&lt;T&gt; for Option&lt;T&gt; { fn replace(&amp;mut self, val: T) -&gt; Option&lt;T&gt; { self.replace_with(move || val) } fn replace_with&lt;F: FnOnce() -&gt; T&gt;(&amp;mut self, f: F) -&gt; Option&lt;T&gt; { if self.is_some() { let result = self.take(); *self = Some(f()); result } else { None } } } Unfortunately, this is just an illusion. Extension traits grant no special powers that’d allow you to bypass any of the regular visibility rules. All you can use inside the new methods is still just the public interface of the type you’re augmenting (here, Option). In our case, however, this is good enough, mostly thanks to the recently introduced Option::take. To use our shiny new methods in other places, all we have to do is import the extension trait: use ext::rust::OptionMutExt; // assuming you put it in ext/rust.rs // ...somewhere... let mut opt: Option&lt;u32&gt; = ...; match opt.replace(42) { Some(x) =&gt; debug!(&#34;Option had a value of {} before replacement&#34;, x), None =&gt; assert_eq!(None, opt), } It doesn’t matter where it was defined either, meaning we can ship it away to crates.io and let it accrue as many happy users as Itertools has ;-) Are you hyper::Body ready? Our second example will demonstrate attaching more methods to a third-party type. This week, there was a new release of Hyper, a popular Rust framework for HTTP servers &amp; clients. It was notable because it marked a switch from synchronous, straightforward API to a more complex, asynchronous one (which I incidentally wrote about a few weeks ago). Predictably, there has been some confusion among its new and existing users. We’re going to help by pinning a more convenient interface on hyper’s Body type. Body here is a struct representing the content of an HTTP request or response. After the ‘asyncatastrophe’, it doesn’t allow to access the raw incoming bytes as easily as it did before. Thanks to extension traits, we can fix this rather quickly: use std::error::Error; use futures::{BoxFuture, future, Future, Stream}; use hyper::{self, Body}; pub trait BodyExt { /// Collect all the bytes from all the `Chunk`s from `Body` /// and return it as `Vec&lt;u8&gt;`. fn into_bytes(self) -&gt; BoxFuture&lt;Vec&lt;u8&gt;, hyper::Error&gt;; /// Collect all the bytes from all the `Chunk`s from `Body`, /// decode them as UTF8, and return the resulting `String`. fn into_string(self) -&gt; BoxFuture&lt;String, Box&lt;Error + Send&gt;&gt;; } impl BodyExt for Body { fn into_bytes(self) -&gt; BoxFuture&lt;Vec&lt;u8&gt;, hyper::Error&gt; { self.concat() .and_then(|bytes| future::ok::&lt;_, hyper::Error&gt;(bytes.to_vec())) .boxed() } fn into_string(self) -&gt; BoxFuture&lt;String, Box&lt;Error + Send&gt;&gt; { self.into_bytes() .map_err(|e| Box::new(e) as Box&lt;Error + Send&gt;) .and_then(|bytes| String::from_utf8(bytes) .map_err(|e| Box::new(e) as Box&lt;Error + Send&gt;)) .boxed() } } With these new methods in hand, it is relatively straightforward to implement, say, a simple character-counting service: use std::error::Error; use futures::{BoxFuture, future, Future}; use hyper::server::{Service, Request, Response}; use ext::hyper::BodyExt; // assuming the above is in ext/hyper.rs pub struct Length; impl Service for Length { type Request = Request; type Response = Response; type Error = Box&lt;Error + Send&gt;; type Future = BoxFuture&lt;Self::Response, Self::Error&gt;; fn call(&amp;self, request: Request) -&gt; Self::Future { let (_, _, _, _, body) = request.deconstruct(); body.into_string().and_then(|s| future::ok( Response::new().with_body(s.len().to_string()) )).boxed() } } Replacing Box&lt;Error + Send&gt; with an idiomatic error enum is left as an exercise for the reader :) Extra credit bonus explanation Reading this section is not necessary to use extension traits. So far, we have seen what extension traits are capable of. It is only right to mention what they cannot do. Indeed, this technique has some limitations. They are a conscious choice on the part of Rust authors, and they were decided upon in an effort to keep the type system coherent. Coherence isn’t an everyday topic in Rust, but it becomes important when working with traits and types that cross package boundaries. Rules of trait coherence (described briefly towards the end of this section of the Rust book) state that the following combinations of “local” (this crate) and “external” (other crates5) are legal: implement a local trait for a local type. This is common in larger programs that use polymorphic abstractions. implement an external trait for a local type. We do this often to integrate with third-party libraries and frameworks, just like with hyper above. implement a local trait for an external type. That’s extension traits for you! What is not possible, however, is to: implement an external trait for an external type This case is prohibited in order to make the choice of trait implementations more predictable, both for the compiler and for the programmer. Without this rule in place, you could introduce many instances of impl Trait for Type (same Trait and same Type), each one with different functionality, leaving the compiler to “guess” the right impl for any given situation6. The decision was thus made to disallow the impl ExternalTrait for ExternalType case altogether. If you like, you can read some more extensive backstory behind it. Bear in mind, however, that this isn’t the unequivocally “correct” solution. Some languages choose to allow this so-called orphan case, and try to resolve the potential ambiguities in various different ways. It is a genuinely useful feature, too, as it makes easier it to glue together two unrelated libraries7. Thankfully for extension traits, the coherence restriction doesn’t apply as long as you keep those traits and their impls in the same crate. This practice is often referred to as monkeypatching, especially in Python and Ruby. ↩ In this case, a more common solution is to just open another impl Foo block, annotated with #[cfg(test)] or similar. An extension trait, however, makes it easier to extract Foo into a separate crate along with some handy, test-only API. ↩ Note that this is not the same as the unstable (as of 1.18) Option methods guarded behind the options_entry feature gate. ↩ My own convention is to call those traits FooExt if they are meant to enhance the interface of type Foo. The other practice is to mirror the name of the crate that the trait is packaged in; both Itertools and UnicodeNormalization are examples of this style. ↩ Standard library (std or core namespaces) counts as external crate for this purpose. ↩ Or throw an error. However, trait impls are always imported implicitly, so this could essentially prevent some combination of different modules/libraries in the ecosystem from being used together, and generally create an unfathomable mess. ↩ The usual workaround for coherence/orphan rules in Rust involves creating a wrapper around the external type in order to make it “local”, and therefore allow external trait impls for it. This is called the newtype pattern and there are some crates to support it. ↩" />
<meta name="keywords" content="Rust, C#, methods, extension methods, traits">
<meta property="og:site_name" content="Karol Kuczmarski's Blog"/>
<meta property="og:title" content="Extension traits in Rust"/>
<meta property="og:description" content="In a few object-oriented languages, it is possible to add methods to a class after it’s already been defined. This feature arises quite naturally if the language has a dynamic type system that’s modifiable at runtime. In those cases, even replacing existing methods is perfectly possible1. In addition to that, some statically typed languages — most notably in C# — offer extension methods as a dedicated feature of their type systems. The premise is that you would write standalone functions whose first argument is specially designated (usually by this keyword) as a receiver of the resulting method call: public static int WordCount(this String str) { return str.Split(new char[] { &#39; &#39;, &#39;.&#39;, &#39;?&#39; }, StringSplitOptions.RemoveEmptyEntries).Length; } At the call site, the new method is indistinguishable from any of the existing ones: string s = &#34;Alice has a cat.&#34;; int n = s.WordCount(); That’s assuming you have imported both the original class (or it’s a built-in like String), as well as the module in which the extension method is defined. Rewrite it in Rust The curious thing about Rust‘s type system is that it permits extension methods solely as a side effect of its core building block: traits. In this post, I’m going to describe a certain design pattern in Rust which involves third-party types and user-defined traits. Several popular crates — like itertools or unicode-normalization — utilize it very successfully to add new, useful methods to the language standard types. I’m not sure if this pattern has an official or widely accepted name. Personally, I’ve taken to calling it extension traits. Let’s have a look at how they are commonly implemented. Ingredients We can use the extension trait pattern if we want to have additional methods in a type that we don’t otherwise control (or don’t want to modify). Common cases include: Rust standard library types, like Iterator, String, or anything else inside the std namespace types imported from third-party libraries types from the current crate if additional methods only make sense in certain scenarios (e.g. conditional compilation / testing)2 The crux of this technique is really simple. Like with most design patterns, however, it involves a certain degree of boilerplate and duplication. So without further ado… In order to “patch” some new method(s) into an external type you will need to: Define a trait with signatures of all the methods you want to add. Implement it for the external type. There is no step three. As an important note on the usage side, the calling code needs to import your new trait in addition to the external type. Once that’s done, it can proceed to use the new methods is if they were there to begin with. I’m sure you are keen on seeing some examples! Broadening your Options We’re going to add two new methods to Rust’s standard Option type. The goal is to make it more convenient to operate on mutable Options by allowing to easily replace an existing value with another one3. Here’s the appropriate extension trait4: /// Additional mutation methods for `Option`. pub trait OptionMutExt&lt;T&gt; { /// Replace the existing `Some` value with a new one. /// /// Returns the previous value if it was present, or `None` if no replacement was made. fn replace(&amp;mut self, val: T) -&gt; Option&lt;T&gt;; /// Replace the existing `Some` value with the result of given closure. /// /// Returns the previous value if it was present, or `None` if no replacement was made. fn replace_with&lt;F: FnOnce() -&gt; T&gt;(&amp;mut self, f: F) -&gt; Option&lt;T&gt;; } It may feel at little bit weird to implement it. You will basically have to pretend you are inside the Option type itself: impl&lt;T&gt; OptionMutExt&lt;T&gt; for Option&lt;T&gt; { fn replace(&amp;mut self, val: T) -&gt; Option&lt;T&gt; { self.replace_with(move || val) } fn replace_with&lt;F: FnOnce() -&gt; T&gt;(&amp;mut self, f: F) -&gt; Option&lt;T&gt; { if self.is_some() { let result = self.take(); *self = Some(f()); result } else { None } } } Unfortunately, this is just an illusion. Extension traits grant no special powers that’d allow you to bypass any of the regular visibility rules. All you can use inside the new methods is still just the public interface of the type you’re augmenting (here, Option). In our case, however, this is good enough, mostly thanks to the recently introduced Option::take. To use our shiny new methods in other places, all we have to do is import the extension trait: use ext::rust::OptionMutExt; // assuming you put it in ext/rust.rs // ...somewhere... let mut opt: Option&lt;u32&gt; = ...; match opt.replace(42) { Some(x) =&gt; debug!(&#34;Option had a value of {} before replacement&#34;, x), None =&gt; assert_eq!(None, opt), } It doesn’t matter where it was defined either, meaning we can ship it away to crates.io and let it accrue as many happy users as Itertools has ;-) Are you hyper::Body ready? Our second example will demonstrate attaching more methods to a third-party type. This week, there was a new release of Hyper, a popular Rust framework for HTTP servers &amp; clients. It was notable because it marked a switch from synchronous, straightforward API to a more complex, asynchronous one (which I incidentally wrote about a few weeks ago). Predictably, there has been some confusion among its new and existing users. We’re going to help by pinning a more convenient interface on hyper’s Body type. Body here is a struct representing the content of an HTTP request or response. After the ‘asyncatastrophe’, it doesn’t allow to access the raw incoming bytes as easily as it did before. Thanks to extension traits, we can fix this rather quickly: use std::error::Error; use futures::{BoxFuture, future, Future, Stream}; use hyper::{self, Body}; pub trait BodyExt { /// Collect all the bytes from all the `Chunk`s from `Body` /// and return it as `Vec&lt;u8&gt;`. fn into_bytes(self) -&gt; BoxFuture&lt;Vec&lt;u8&gt;, hyper::Error&gt;; /// Collect all the bytes from all the `Chunk`s from `Body`, /// decode them as UTF8, and return the resulting `String`. fn into_string(self) -&gt; BoxFuture&lt;String, Box&lt;Error + Send&gt;&gt;; } impl BodyExt for Body { fn into_bytes(self) -&gt; BoxFuture&lt;Vec&lt;u8&gt;, hyper::Error&gt; { self.concat() .and_then(|bytes| future::ok::&lt;_, hyper::Error&gt;(bytes.to_vec())) .boxed() } fn into_string(self) -&gt; BoxFuture&lt;String, Box&lt;Error + Send&gt;&gt; { self.into_bytes() .map_err(|e| Box::new(e) as Box&lt;Error + Send&gt;) .and_then(|bytes| String::from_utf8(bytes) .map_err(|e| Box::new(e) as Box&lt;Error + Send&gt;)) .boxed() } } With these new methods in hand, it is relatively straightforward to implement, say, a simple character-counting service: use std::error::Error; use futures::{BoxFuture, future, Future}; use hyper::server::{Service, Request, Response}; use ext::hyper::BodyExt; // assuming the above is in ext/hyper.rs pub struct Length; impl Service for Length { type Request = Request; type Response = Response; type Error = Box&lt;Error + Send&gt;; type Future = BoxFuture&lt;Self::Response, Self::Error&gt;; fn call(&amp;self, request: Request) -&gt; Self::Future { let (_, _, _, _, body) = request.deconstruct(); body.into_string().and_then(|s| future::ok( Response::new().with_body(s.len().to_string()) )).boxed() } } Replacing Box&lt;Error + Send&gt; with an idiomatic error enum is left as an exercise for the reader :) Extra credit bonus explanation Reading this section is not necessary to use extension traits. So far, we have seen what extension traits are capable of. It is only right to mention what they cannot do. Indeed, this technique has some limitations. They are a conscious choice on the part of Rust authors, and they were decided upon in an effort to keep the type system coherent. Coherence isn’t an everyday topic in Rust, but it becomes important when working with traits and types that cross package boundaries. Rules of trait coherence (described briefly towards the end of this section of the Rust book) state that the following combinations of “local” (this crate) and “external” (other crates5) are legal: implement a local trait for a local type. This is common in larger programs that use polymorphic abstractions. implement an external trait for a local type. We do this often to integrate with third-party libraries and frameworks, just like with hyper above. implement a local trait for an external type. That’s extension traits for you! What is not possible, however, is to: implement an external trait for an external type This case is prohibited in order to make the choice of trait implementations more predictable, both for the compiler and for the programmer. Without this rule in place, you could introduce many instances of impl Trait for Type (same Trait and same Type), each one with different functionality, leaving the compiler to “guess” the right impl for any given situation6. The decision was thus made to disallow the impl ExternalTrait for ExternalType case altogether. If you like, you can read some more extensive backstory behind it. Bear in mind, however, that this isn’t the unequivocally “correct” solution. Some languages choose to allow this so-called orphan case, and try to resolve the potential ambiguities in various different ways. It is a genuinely useful feature, too, as it makes easier it to glue together two unrelated libraries7. Thankfully for extension traits, the coherence restriction doesn’t apply as long as you keep those traits and their impls in the same crate. This practice is often referred to as monkeypatching, especially in Python and Ruby. ↩ In this case, a more common solution is to just open another impl Foo block, annotated with #[cfg(test)] or similar. An extension trait, however, makes it easier to extract Foo into a separate crate along with some handy, test-only API. ↩ Note that this is not the same as the unstable (as of 1.18) Option methods guarded behind the options_entry feature gate. ↩ My own convention is to call those traits FooExt if they are meant to enhance the interface of type Foo. The other practice is to mirror the name of the crate that the trait is packaged in; both Itertools and UnicodeNormalization are examples of this style. ↩ Standard library (std or core namespaces) counts as external crate for this purpose. ↩ Or throw an error. However, trait impls are always imported implicitly, so this could essentially prevent some combination of different modules/libraries in the ecosystem from being used together, and generally create an unfathomable mess. ↩ The usual workaround for coherence/orphan rules in Rust involves creating a wrapper around the external type in order to make it “local”, and therefore allow external trait impls for it. This is called the newtype pattern and there are some crates to support it. ↩"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://xion.io/drafts/rust-extension-traits.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2017-06-17 17:10:00+00:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="http://xion.io/">
<meta property="article:section" content="Code"/>
<meta property="article:tag" content="Rust"/>
<meta property="article:tag" content="C#"/>
<meta property="article:tag" content="methods"/>
<meta property="article:tag" content="extension methods"/>
<meta property="article:tag" content="traits"/>
<meta property="og:image" content="http://xion.io/logo.jpeg">
  <title>Karol Kuczmarski's Blog &ndash; Extension traits in Rust</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://xion.io">
        <img src="http://xion.io/logo.jpeg" alt="Karol Kuczmarski" title="Karol Kuczmarski">
      </a>
      <h1><a href="http://xion.io">Karol Kuczmarski</a></h1>
      <p>fn(Tea) -> Code</p>
      <nav>
        <ul class="list">
          <li><a href="http://xion.io/page/about.html#about">About</a></li>
          <li><a href="http://xion.io/page/projects.html#projects">Projects</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-github" href="http://github.com/Xion" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-stack-overflow" href="http://stackoverflow.com/users/434799/xion" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
        <li><a class="sc-twitter" href="http://twitter.com/Xion__" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-google" href="https://plus.google.com/+KarolKuczmarski" target="_blank"><i class="fa fa-google"></i></a></li>
        <li><a class="sc-rss" href="/feeds/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="http://xion.io">Home</a>
      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>
      <a href="http://xion.org.pl/">Old blog</a>
    </nav>

<article>
  <header>
    <h1 id="rust-extension-traits">Extension traits in&nbsp;Rust</h1>
    <p>Posted on Sat 17 June 2017 in <a href="http://xion.io/category/code.html">Code</a></p>
  </header>
  <div>
    <p>In a few object-oriented languages,
it is possible to add methods to a class <em>after</em> it&#8217;s already been&nbsp;defined.</p>
<p>This feature arises quite naturally if the language has a dynamic type system
that&#8217;s modifiable at runtime.
In those cases, even <em>replacing</em> existing methods is perfectly possible<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>.</p>
<p>In addition to that,
some statically typed languages &#8212; most notably in C# &#8212;
offer <em>extension methods</em> as a <a href="cs-ext-methods">dedicated feature</a> of their type systems.
The premise is that you would write standalone functions whose
first argument is specially designated (usually by <code>this</code> keyword)
as a receiver of the resulting method&nbsp;call:</p>
<div class="highlight"><pre><span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">WordCount</span><span class="p">(</span><span class="k">this</span> <span class="n">String</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">str</span><span class="p">.</span><span class="n">Split</span><span class="p">(</span><span class="k">new</span> <span class="kt">char</span><span class="p">[]</span> <span class="p">{</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">,</span> <span class="sc">&#39;?&#39;</span> <span class="p">},</span>
                     <span class="n">StringSplitOptions</span><span class="p">.</span><span class="n">RemoveEmptyEntries</span><span class="p">).</span><span class="n">Length</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>At the call site,
the new method is indistinguishable from any of the existing&nbsp;ones:</p>
<div class="highlight"><pre><span class="kt">string</span> <span class="n">s</span> <span class="p">=</span> <span class="s">&quot;Alice has a cat.&quot;</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">WordCount</span><span class="p">();</span>
</pre></div>


<p>That&#8217;s assuming you have imported both the original class
(or it&#8217;s a built-in like <code>String</code>),
as well as the module in which the extension method is&nbsp;defined.</p>
<h4>Rewrite it in&nbsp;Rust</h4>
<p>The curious thing about <a href="http://rust-lang.org">Rust</a>&#8216;s type system is
that it permits extension methods solely as a side effect of its core building block: <em>traits</em>.</p>
<p>In this post, I&#8217;m going to describe a certain design pattern in Rust
which involves third-party types and user-defined traits.
Several popular crates &#8212;
like <a href="https://docs.rs/itertools">itertools</a> or <a href="https://docs.rs/unicode-normalization/">unicode-normalization</a> &#8212;
utilize it very successfully to add new, useful methods to the language standard&nbsp;types.</p>
<p>I&#8217;m not sure if this pattern has an official or widely accepted name.
Personally, I&#8217;ve taken to calling it <strong>extension traits</strong>.</p>
<p>Let&#8217;s have a look at how they are commonly&nbsp;implemented.</p>
<h4>Ingredients</h4>
<p>We can use the extension trait pattern if we want to have additional methods in a type
that we don&#8217;t otherwise control (or don&#8217;t want to&nbsp;modify).</p>
<p>Common cases&nbsp;include:</p>
<ul>
<li>Rust standard library types, like <code>Iterator</code>, <code>String</code>,
  or anything else inside the <code>std</code> namespace</li>
<li>types imported from <a href="https://crates.io">third-party&nbsp;libraries</a></li>
<li>types from the current crate if additional methods only make sense in certain scenarios
  (e.g. conditional compilation / testing)<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup></li>
</ul>
<p>The crux of this technique is really simple.
Like with most design patterns, however,
it involves a certain degree of boilerplate and&nbsp;duplication.</p>
<p>So without further ado&#8230;
In order to &#8220;patch&#8221; some new method(s) into an external type you will need&nbsp;to:</p>
<ol>
<li>Define a trait with signatures of all the methods you want to&nbsp;add.</li>
<li>Implement it for the external&nbsp;type.</li>
<li><em>There is no step three</em>.</li>
</ol>
<p>As an important note on the usage side,
the calling code needs to <em>import your new trait</em> in addition to the external type.
Once that&#8217;s done, it can proceed to use the new methods is if they were there to begin&nbsp;with.</p>
<p>I&#8217;m sure you are keen on seeing some&nbsp;examples!</p>
<h4>Broadening your <code>Option</code>s</h4>
<p>We&#8217;re going to add two new methods to Rust&#8217;s <a href="https://doc.rust-lang.org/std/option/enum.Option.html">standard <code>Option</code> type</a>.
The goal is to make it more convenient to operate on mutable <code>Option</code>s
by allowing to easily replace an existing value with another one<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>.</p>
<p>Here&#8217;s the appropriate extension trait<sup id="fnref:4"><a class="footnote-ref" href="#fn:4" rel="footnote">4</a></sup>:</p>
<div class="highlight"><pre><span class="c-Doc">/// Additional mutation methods for `Option`.</span>
<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">OptionMutExt</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c-Doc">/// Replace the existing `Some` value with a new one.</span>
<span class="w">    </span><span class="c-Doc">///</span>
<span class="w">    </span><span class="c-Doc">/// Returns the previous value if it was present, or `None` if no replacement was made.</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c-Doc">/// Replace the existing `Some` value with the result of given closure.</span>
<span class="w">    </span><span class="c-Doc">///</span>
<span class="w">    </span><span class="c-Doc">/// Returns the previous value if it was present, or `None` if no replacement was made.</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">replace_with</span><span class="o">&lt;</span><span class="n">F</span><span class="o">:</span><span class="w"> </span><span class="n">FnOnce</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>It may feel at little bit weird to implement it.<br>
You will basically have to pretend you are <em>inside the <code>Option</code> type itself</em>:</p>
<div class="highlight"><pre><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">OptionMutExt</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">replace_with</span><span class="p">(</span><span class="n">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">replace_with</span><span class="o">&lt;</span><span class="n">F</span><span class="o">:</span><span class="w"> </span><span class="n">FnOnce</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">is_some</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">take</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">f</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="n">result</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Unfortunately, this is just an illusion.
Extension traits grant no special powers
that&#8217;d allow you to bypass any of the regular visibility rules.
All you can use inside the new methods is still
just the <em>public interface</em> of the type you&#8217;re augmenting (here, <code>Option</code>).</p>
<p>In our case, however, this is good enough,
mostly thanks to <a href="option_take">the recently introduced <code>Option::take</code></a>.</p>
<p>To use our shiny new methods in other places,
all we have to do is import the extension&nbsp;trait:</p>
<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">ext</span><span class="o">::</span><span class="n">rust</span><span class="o">::</span><span class="n">OptionMutExt</span><span class="p">;</span><span class="w">  </span><span class="c1">// assuming you put it in ext/rust.rs</span>

<span class="c1">// ...somewhere...</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">opt</span><span class="o">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="k">match</span><span class="w"> </span><span class="n">opt</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">debug</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Option had a value of {} before replacement&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="nb">None</span><span class="p">,</span><span class="w"> </span><span class="n">opt</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>It doesn&#8217;t matter where it was defined either,
meaning we can ship it away to <a href="https://crates.io">crates.io</a>
and let it accrue as many happy users as <code>Itertools</code> has&nbsp;;-)</p>
<h4>Are you <code>hyper::Body</code> ready?</h4>
<p>Our second example will demonstrate attaching more methods to a third-party&nbsp;type.</p>
<p>This week, there was a new release of <a href="https://hyper.rs/">Hyper</a>,
a popular Rust framework for <span class="caps">HTTP</span> servers <span class="amp">&amp;</span> clients.
It was notable because it marked a switch from synchronous, straightforward <span class="caps">API</span>
to a more complex, asynchronous one
(which I incidentally <a href="http://xion.io/post/programming/rust-async-closer-look.html">wrote about a few weeks ago</a>).</p>
<p>Predictably, <a href="https://www.reddit.com/r/rust/comments/6hksa0/problems_with_understanding_hypers_async/">there has been some confusion</a>
among its new and existing&nbsp;users.</p>
<p>We&#8217;re going to help by pinning a more convenient interface on
<a href="https://hyper.rs/hyper/master/hyper/struct.Body.html">hyper&#8217;s <code>Body</code> type</a>.
<code>Body</code> here is a struct representing the content of an <span class="caps">HTTP</span> request or response.
After the &#8216;asyncatastrophe&#8217;,
it doesn&#8217;t allow to access the raw incoming bytes as easily as it did&nbsp;before.</p>
<p>Thanks to extension traits, we can fix this rather&nbsp;quickly:</p>
<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">Error</span><span class="p">;</span><span class="w"></span>

<span class="kn">use</span><span class="w"> </span><span class="n">futures</span><span class="o">::</span><span class="p">{</span><span class="n">BoxFuture</span><span class="p">,</span><span class="w"> </span><span class="n">future</span><span class="p">,</span><span class="w"> </span><span class="n">Future</span><span class="p">,</span><span class="w"> </span><span class="n">Stream</span><span class="p">};</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">hyper</span><span class="o">::</span><span class="p">{</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">Body</span><span class="p">};</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">BodyExt</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c-Doc">/// Collect all the bytes from all the `Chunk`s from `Body`</span>
<span class="w">    </span><span class="c-Doc">/// and return it as `Vec&lt;u8&gt;`.</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">into_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">BoxFuture</span><span class="o">&lt;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">hyper</span><span class="o">::</span><span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c-Doc">/// Collect all the bytes from all the `Chunk`s from `Body`,</span>
<span class="w">    </span><span class="c-Doc">/// decode them as UTF8, and return the resulting `String`.</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">into_string</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">BoxFuture</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">BodyExt</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Body</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">into_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">BoxFuture</span><span class="o">&lt;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">hyper</span><span class="o">::</span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">concat</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">bytes</span><span class="o">|</span><span class="w"> </span><span class="n">future</span><span class="o">::</span><span class="n">ok</span><span class="o">::&lt;</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">hyper</span><span class="o">::</span><span class="n">Error</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bytes</span><span class="p">.</span><span class="n">to_vec</span><span class="p">()))</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">boxed</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">into_string</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">BoxFuture</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">into_bytes</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">bytes</span><span class="o">|</span><span class="w"> </span><span class="n">String</span><span class="o">::</span><span class="n">from_utf8</span><span class="p">(</span><span class="n">bytes</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">boxed</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>With these new methods in hand,
it is relatively straightforward to implement, say, a simple character-counting&nbsp;service:</p>
<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">Error</span><span class="p">;</span><span class="w"></span>

<span class="kn">use</span><span class="w"> </span><span class="n">futures</span><span class="o">::</span><span class="p">{</span><span class="n">BoxFuture</span><span class="p">,</span><span class="w"> </span><span class="n">future</span><span class="p">,</span><span class="w"> </span><span class="n">Future</span><span class="p">};</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">hyper</span><span class="o">::</span><span class="n">server</span><span class="o">::</span><span class="p">{</span><span class="n">Service</span><span class="p">,</span><span class="w"> </span><span class="n">Request</span><span class="p">,</span><span class="w"> </span><span class="n">Response</span><span class="p">};</span><span class="w"></span>

<span class="kn">use</span><span class="w"> </span><span class="n">ext</span><span class="o">::</span><span class="n">hyper</span><span class="o">::</span><span class="n">BodyExt</span><span class="p">;</span><span class="w">  </span><span class="c1">// assuming the above is in ext/hyper.rs</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="n">Length</span><span class="p">;</span><span class="w"></span>
<span class="k">impl</span><span class="w"> </span><span class="n">Service</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Length</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="n">Request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Request</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="n">Response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Response</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BoxFuture</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">::</span><span class="n">Response</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span><span class="o">::</span><span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">call</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">request</span><span class="o">:</span><span class="w"> </span><span class="n">Request</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="o">::</span><span class="n">Future</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">request</span><span class="p">.</span><span class="n">deconstruct</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">body</span><span class="p">.</span><span class="n">into_string</span><span class="p">().</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="n">future</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">Response</span><span class="o">::</span><span class="n">new</span><span class="p">().</span><span class="n">with_body</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">().</span><span class="n">to_string</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">)).</span><span class="n">boxed</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Replacing <code>Box&lt;Error + Send&gt;</code> with an idiomatic <a href="https://docs.rs/crate/derive-error/">error enum</a>
is left as an exercise for the reader&nbsp;:)</p>
<h4>Extra credit bonus&nbsp;explanation</h4>
<p><small>Reading this section is not necessary to use extension traits.</small></p>
<p>So far, we have seen what extension traits are capable of.
It is only right to mention what they <em>cannot do</em>.</p>
<p>Indeed, this technique has some limitations.
They are a conscious choice on the part of Rust authors,
and they were decided upon in an effort to keep the type system <em>coherent</em>.</p>
<p>Coherence isn&#8217;t an everyday topic in Rust,
but it becomes important when working with traits and types that cross package boundaries.
Rules of trait coherence
(described briefly towards the end of <a href="coherence-in-book">this section of the Rust book</a>)
state that the following combinations of &#8220;local&#8221; (this crate) and &#8220;external&#8221; (other crates<sup id="fnref:5"><a class="footnote-ref" href="#fn:5" rel="footnote">5</a></sup>) are&nbsp;legal:</p>
<ul>
<li>implement a <em>local</em> trait for a <em>local</em> type.<br>
  This is common in larger programs that use polymorphic&nbsp;abstractions.</li>
<li>implement an <em>external</em> trait for a <em>local</em> type.<br>
  We do this often to integrate with third-party libraries and frameworks,
  just like with <code>hyper</code> above.</li>
<li>implement a <em>local</em> trait for an <em>external</em> type.<br>
  That&#8217;s extension traits for&nbsp;you!</li>
</ul>
<p>What is <em>not</em> possible, however, is&nbsp;to:</p>
<ul>
<li>implement an <em>external</em> trait for an <em>external</em>&nbsp;type</li>
</ul>
<p>This case is prohibited in order to make the choice of trait implementations more predictable,
both for the compiler and for the programmer.
Without this rule in place, you could introduce many instances of <code>impl Trait for Type</code>
(same <code>Trait</code> and same <code>Type</code>),
each one with different functionality,
leaving the compiler to &#8220;guess&#8221; the right <code>impl</code> for any given situation<sup id="fnref:6"><a class="footnote-ref" href="#fn:6" rel="footnote">6</a></sup>.</p>
<p>The decision was thus made to disallow the <code>impl ExternalTrait for ExternalType</code> case altogether.
If you like, you can read <a href="rust-orphans">some more extensive backstory</a> behind&nbsp;it.</p>
<p>Bear in mind, however, that this isn&#8217;t the unequivocally &#8220;correct&#8221; solution.
<a href="hs-orphans">Some languages</a> choose to allow this so-called <em>orphan</em> case,
and try to resolve the potential ambiguities in various different ways.
It is a genuinely useful feature, too, as it makes easier it to glue together two unrelated libraries<sup id="fnref:7"><a class="footnote-ref" href="#fn:7" rel="footnote">7</a></sup>.</p>
<p>Thankfully for extension traits,
the coherence restriction doesn&#8217;t apply as long as you keep those traits and their <code>impl</code>s in the same&nbsp;crate.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>This practice is often referred to as <em>monkeypatching</em>, especially in Python and Ruby.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>In this case, a more common solution is to just open another <code>impl Foo</code> block,
annotated with <code>#[cfg(test)]</code> or similar.
An extension trait, however, makes it easier
to extract <code>Foo</code> into a separate crate along with some handy, test-only <span class="caps">API</span>.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>Note that this is <em>not</em> the same as the unstable (as of 1.18) <code>Option</code> methods
guarded behind <a href="https://github.com/rust-lang/rust/issues/39288">the <code>options_entry</code> feature gate</a>.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>My own convention is to call those traits <code>FooExt</code>
if they are meant to enhance the interface of type <code>Foo</code>.
The other practice is to mirror the name of the crate that the trait is packaged in;
both <code>Itertools</code> and <code>UnicodeNormalization</code> are examples of this style.&#160;<a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:5">
<p>Standard library (<code>std</code> or <code>core</code> namespaces) counts as external crate for this purpose.&#160;<a class="footnote-backref" href="#fnref:5" rev="footnote" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:6">
<p>Or throw an error. However, trait <code>impl</code>s are always imported implicitly,
so this could essentially prevent some combination of different modules/libraries in the ecosystem from being used together,
and generally create an unfathomable mess.&#160;<a class="footnote-backref" href="#fnref:6" rev="footnote" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:7">
<p>The usual workaround for coherence/orphan rules in Rust involves creating a wrapper
around the external type in order to make it &#8220;local&#8221;, and therefore allow external trait <code>impl</code>s for it.
This is called <a href="https://github.com/rust-unofficial/patterns/blob/master/patterns/newtype.md">the <em>newtype</em> pattern</a>
and there are <a href="https://docs.rs/newtype_derive">some crates</a> to support it.&#160;<a class="footnote-backref" href="#fnref:7" rev="footnote" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
</ol>
</div>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="http://xion.io/tag/rust.html">Rust</a>
      <a href="http://xion.io/tag/c.html">C#</a>
      <a href="http://xion.io/tag/methods.html">methods</a>
      <a href="http://xion.io/tag/extension-methods.html">extension methods</a>
      <a href="http://xion.io/tag/traits.html">traits</a>
    </p>
  </div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'xionblog';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</article>

    <footer>
<p>
  &copy; Karol Kuczmarski 2017 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-27379564-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "Extension traits in Rust",
  "headline": "Extension traits in Rust",
  "datePublished": "2017-06-17 17:10:00+00:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "Karol Kuczmarski",
    "url": "http://xion.io/"
  },
  "image": "http://xion.io/logo.jpeg",
  "url": "http://xion.io/drafts/rust-extension-traits.html",
  "description": "In a few object-oriented languages, it is possible to add methods to a class after it’s already been defined. This feature arises quite naturally if the language has a dynamic type system that’s modifiable at runtime. In those cases, even replacing existing methods is perfectly possible1. In addition to that, some statically typed languages — most notably in C# — offer extension methods as a dedicated feature of their type systems. The premise is that you would write standalone functions whose first argument is specially designated (usually by this keyword) as a receiver of the resulting method call: public static int WordCount(this String str) { return str.Split(new char[] { ' ', '.', '?' }, StringSplitOptions.RemoveEmptyEntries).Length; } At the call site, the new method is indistinguishable from any of the existing ones: string s = "Alice has a cat."; int n = s.WordCount(); That’s assuming you have imported both the original class (or it’s a built-in like String), as well as the module in which the extension method is defined. Rewrite it in Rust The curious thing about Rust‘s type system is that it permits extension methods solely as a side effect of its core building block: traits. In this post, I’m going to describe a certain design pattern in Rust which involves third-party types and user-defined traits. Several popular crates — like itertools or unicode-normalization — utilize it very successfully to add new, useful methods to the language standard types. I’m not sure if this pattern has an official or widely accepted name. Personally, I’ve taken to calling it extension traits. Let’s have a look at how they are commonly implemented. Ingredients We can use the extension trait pattern if we want to have additional methods in a type that we don’t otherwise control (or don’t want to modify). Common cases include: Rust standard library types, like Iterator, String, or anything else inside the std namespace types imported from third-party libraries types from the current crate if additional methods only make sense in certain scenarios (e.g. conditional compilation / testing)2 The crux of this technique is really simple. Like with most design patterns, however, it involves a certain degree of boilerplate and duplication. So without further ado… In order to “patch” some new method(s) into an external type you will need to: Define a trait with signatures of all the methods you want to add. Implement it for the external type. There is no step three. As an important note on the usage side, the calling code needs to import your new trait in addition to the external type. Once that’s done, it can proceed to use the new methods is if they were there to begin with. I’m sure you are keen on seeing some examples! Broadening your Options We’re going to add two new methods to Rust’s standard Option type. The goal is to make it more convenient to operate on mutable Options by allowing to easily replace an existing value with another one3. Here’s the appropriate extension trait4: /// Additional mutation methods for `Option`. pub trait OptionMutExt<T> { /// Replace the existing `Some` value with a new one. /// /// Returns the previous value if it was present, or `None` if no replacement was made. fn replace(&mut self, val: T) -> Option<T>; /// Replace the existing `Some` value with the result of given closure. /// /// Returns the previous value if it was present, or `None` if no replacement was made. fn replace_with<F: FnOnce() -> T>(&mut self, f: F) -> Option<T>; } It may feel at little bit weird to implement it. You will basically have to pretend you are inside the Option type itself: impl<T> OptionMutExt<T> for Option<T> { fn replace(&mut self, val: T) -> Option<T> { self.replace_with(move || val) } fn replace_with<F: FnOnce() -> T>(&mut self, f: F) -> Option<T> { if self.is_some() { let result = self.take(); *self = Some(f()); result } else { None } } } Unfortunately, this is just an illusion. Extension traits grant no special powers that’d allow you to bypass any of the regular visibility rules. All you can use inside the new methods is still just the public interface of the type you’re augmenting (here, Option). In our case, however, this is good enough, mostly thanks to the recently introduced Option::take. To use our shiny new methods in other places, all we have to do is import the extension trait: use ext::rust::OptionMutExt; // assuming you put it in ext/rust.rs // ...somewhere... let mut opt: Option<u32> = ...; match opt.replace(42) { Some(x) => debug!("Option had a value of {} before replacement", x), None => assert_eq!(None, opt), } It doesn’t matter where it was defined either, meaning we can ship it away to crates.io and let it accrue as many happy users as Itertools has ;-) Are you hyper::Body ready? Our second example will demonstrate attaching more methods to a third-party type. This week, there was a new release of Hyper, a popular Rust framework for HTTP servers & clients. It was notable because it marked a switch from synchronous, straightforward API to a more complex, asynchronous one (which I incidentally wrote about a few weeks ago). Predictably, there has been some confusion among its new and existing users. We’re going to help by pinning a more convenient interface on hyper’s Body type. Body here is a struct representing the content of an HTTP request or response. After the ‘asyncatastrophe’, it doesn’t allow to access the raw incoming bytes as easily as it did before. Thanks to extension traits, we can fix this rather quickly: use std::error::Error; use futures::{BoxFuture, future, Future, Stream}; use hyper::{self, Body}; pub trait BodyExt { /// Collect all the bytes from all the `Chunk`s from `Body` /// and return it as `Vec<u8>`. fn into_bytes(self) -> BoxFuture<Vec<u8>, hyper::Error>; /// Collect all the bytes from all the `Chunk`s from `Body`, /// decode them as UTF8, and return the resulting `String`. fn into_string(self) -> BoxFuture<String, Box<Error + Send>>; } impl BodyExt for Body { fn into_bytes(self) -> BoxFuture<Vec<u8>, hyper::Error> { self.concat() .and_then(|bytes| future::ok::<_, hyper::Error>(bytes.to_vec())) .boxed() } fn into_string(self) -> BoxFuture<String, Box<Error + Send>> { self.into_bytes() .map_err(|e| Box::new(e) as Box<Error + Send>) .and_then(|bytes| String::from_utf8(bytes) .map_err(|e| Box::new(e) as Box<Error + Send>)) .boxed() } } With these new methods in hand, it is relatively straightforward to implement, say, a simple character-counting service: use std::error::Error; use futures::{BoxFuture, future, Future}; use hyper::server::{Service, Request, Response}; use ext::hyper::BodyExt; // assuming the above is in ext/hyper.rs pub struct Length; impl Service for Length { type Request = Request; type Response = Response; type Error = Box<Error + Send>; type Future = BoxFuture<Self::Response, Self::Error>; fn call(&self, request: Request) -> Self::Future { let (_, _, _, _, body) = request.deconstruct(); body.into_string().and_then(|s| future::ok( Response::new().with_body(s.len().to_string()) )).boxed() } } Replacing Box<Error + Send> with an idiomatic error enum is left as an exercise for the reader :) Extra credit bonus explanation Reading this section is not necessary to use extension traits. So far, we have seen what extension traits are capable of. It is only right to mention what they cannot do. Indeed, this technique has some limitations. They are a conscious choice on the part of Rust authors, and they were decided upon in an effort to keep the type system coherent. Coherence isn’t an everyday topic in Rust, but it becomes important when working with traits and types that cross package boundaries. Rules of trait coherence (described briefly towards the end of this section of the Rust book) state that the following combinations of “local” (this crate) and “external” (other crates5) are legal: implement a local trait for a local type. This is common in larger programs that use polymorphic abstractions. implement an external trait for a local type. We do this often to integrate with third-party libraries and frameworks, just like with hyper above. implement a local trait for an external type. That’s extension traits for you! What is not possible, however, is to: implement an external trait for an external type This case is prohibited in order to make the choice of trait implementations more predictable, both for the compiler and for the programmer. Without this rule in place, you could introduce many instances of impl Trait for Type (same Trait and same Type), each one with different functionality, leaving the compiler to “guess” the right impl for any given situation6. The decision was thus made to disallow the impl ExternalTrait for ExternalType case altogether. If you like, you can read some more extensive backstory behind it. Bear in mind, however, that this isn’t the unequivocally “correct” solution. Some languages choose to allow this so-called orphan case, and try to resolve the potential ambiguities in various different ways. It is a genuinely useful feature, too, as it makes easier it to glue together two unrelated libraries7. Thankfully for extension traits, the coherence restriction doesn’t apply as long as you keep those traits and their impls in the same crate. This practice is often referred to as monkeypatching, especially in Python and Ruby. ↩ In this case, a more common solution is to just open another impl Foo block, annotated with #[cfg(test)] or similar. An extension trait, however, makes it easier to extract Foo into a separate crate along with some handy, test-only API. ↩ Note that this is not the same as the unstable (as of 1.18) Option methods guarded behind the options_entry feature gate. ↩ My own convention is to call those traits FooExt if they are meant to enhance the interface of type Foo. The other practice is to mirror the name of the crate that the trait is packaged in; both Itertools and UnicodeNormalization are examples of this style. ↩ Standard library (std or core namespaces) counts as external crate for this purpose. ↩ Or throw an error. However, trait impls are always imported implicitly, so this could essentially prevent some combination of different modules/libraries in the ecosystem from being used together, and generally create an unfathomable mess. ↩ The usual workaround for coherence/orphan rules in Rust involves creating a wrapper around the external type in order to make it “local”, and therefore allow external trait impls for it. This is called the newtype pattern and there are some crates to support it. ↩"
}
</script></body>
</html>