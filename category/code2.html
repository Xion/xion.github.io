<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/font-awesome.min.css">

    <link href="http://xion.io/style.css" rel="stylesheet">




  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

    <meta name="author" content="Karol Kuczmarski" />
    <meta name="description" content="" />
<meta property="og:site_name" content="Karol Kuczmarski's Blog"/>
<meta property="og:type" content="blog"/>
<meta property="og:title" content="Karol Kuczmarski's Blog"/>
<meta property="og:description" content=""/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://xion.io"/>
<meta property="og:image" content="http://xion.io/logo.jpeg">

  <title>Karol Kuczmarski's Blog &ndash; Category: Code</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://xion.io">
        <img src="http://xion.io/logo.jpeg" alt="Karol Kuczmarski" title="Karol Kuczmarski">
      </a>
      <h1><a href="http://xion.io">Karol Kuczmarski</a></h1>
      <p>fn(Tea) -> Code</p>
      <nav>
        <ul class="list">
          <li><a href="http://xion.io/page/about.html#about">About</a></li>
          <li><a href="http://xion.io/page/projects.html#projects">Projects</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-github" href="http://github.com/Xion" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-stack-overflow" href="http://stackoverflow.com/users/434799/xion" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
        <li><a class="sc-twitter" href="http://twitter.com/Xion__" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-google" href="https://plus.google.com/+KarolKuczmarski" target="_blank"><i class="fa fa-google"></i></a></li>
        <li><a class="sc-rss" href="/feeds/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="http://xion.io">Home</a>
      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>
      <a href="http://xion.org.pl/">Old blog</a>
    </nav>

<article>
  <header>
    <h2><a href="http://xion.io/post/code/python3-primer.html#python3-primer">The brave &#8220;new&#8221; world of Python&nbsp;3</a></h2>
    <p>
      Posted on Mon 15 August 2016 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/python.html">Python</a>,      <a href="http://xion.io/tag/python-3.html">Python 3</a>,      <a href="http://xion.io/tag/unicode.html">Unicode</a>,      <a href="http://xion.io/tag/lazy-evaluation.html">lazy evaluation</a>,      <a href="http://xion.io/tag/iterables.html">iterables</a>      &#8226; <a href="http://xion.io/post/code/python3-primer.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>I&#8217;ll blurt it straight up: I&#8217;m not a big fan of Python&nbsp;3.</p>
<p>For a long time, I resisted the appeal of various incremental improvements
that early 3.x releases offered.
And the world agreed with me:
a mere two years ago, Python 3 wasn&#8217;t even <a href="https://alexgaynor.net/2014/jan/03/pypi-download-statistics/">a blip on the PyPI radar</a>.</p>
<p>Lately, however, things seem to be picking up some&nbsp;steam.</p>
<p>As if to compensate for years of &#8220;good enough&#8221;,
Python 3 development team has given in to a steadily accelerating feature creep.
Sure, some of it results in <a href="https://www.python.org/dev/peps/pep-0498/">bad ideas</a>
(or even <a href="https://www.python.org/dev/peps/pep-0628/">ideas you&#8217;d hope are jokes</a>),
but it nevertheless causes an increasingly wide functional gap
between the 2.x and 3.x&nbsp;series.</p>
<p>Starting from around Python 3.5, this gap becomes really noticeable,
even when partially bridged with many excellent backports.
The ecosystem support is also mostly there,
at least insofar as &#8220;not breaking horribly when a package is used in Python&nbsp;3&#8221;.</p>
<p>And then, of course, there is <a href="https://hg.python.org/peps/rev/76d43e52d978">the 2.7 EoL date</a> looming ever&nbsp;closer.</p>
<p>Given all those portents,
even old curmudg&#8230; ahem&#8230; <em>seasoned developers</em> cannot really ignore Python 3 anymore.
For better or for worse, 3.x is how Python will look like in the coming years and decades.
Might as well prepare for&nbsp;it.</p>
<p>In this post, I will discuss some important issues
one should be aware of before trying to switch from Python 2 to 3.
I won&#8217;t be talking about all the minute changes and additions,
but cover the more significant, broader concepts
that mark the divide between the 2.x and 3.x&nbsp;generations.</p>
<p>The two concepts I&#8217;ll be mentioning here are
<em>Unicode</em> (obviously) and <em>lazy vs. eager computation</em>.</p>
<h4>Unicode&nbsp;handling</h4>
<p>You have probably heard it before.
Python 3 was going to solve your Unicode problems once and for all.
You haven&#8217;t believed it, of course,
like you wouldn&#8217;t believe in any other silver&nbsp;bullet.</p>
<p>Still, it may be rather surprising to learn
that in Python 3, you&#8217;ll actually see much <em>more</em> Unicode-related&nbsp;errors.</p>
<p>And strange as it may sound, it is  a <em>good</em>&nbsp;thing.</p>
<p>In any case, either version of Python gets the most important thing about Unicode right.
They both distinguish, at the type level,
between <em>strings</em> (of Unicode codepoints) and their <em>encodings</em> (sequences of bytes).
The type that holds the latter is called <code>bytes</code> in both versions,
while strings are stored within the <code>str</code> type in Python 3 and <code>unicode</code> in Python&nbsp;2.</p>
<p>It is from this crucial distinction &#8212; or rather, failing to account for it &#8212;
where all the dreaded Unicode errors ultimately&nbsp;stem.</p>
<p>But where Python 2 does poorly is in the choice of defaults.
You probably know all too well that <code>bytes</code> there is just an alias for <code>str</code>.
That <code>str</code> is a fully functional string type,
even though it can only contain <span class="caps">ASCII</span> characters.
Moreover, it is also the <em>default</em>:
quoted string literals, for example, will be of this type unless specially&nbsp;marked.</p>
<p>This poor choice of defaults is the primary source of latent Unicode bugs in Python 2&nbsp;programs.</p>
<p>What Python 3 does here is to help <em>expose those bugs</em> sooner.
If you already deal with Unicode correctly in your programs
&#8212; maybe because you watched <a href="https://www.youtube.com/watch?v=sgHbC6udIqc">this excellent talk by Ned Batchelder</a> &#8212;
your main benefit will be not having to write that <code>u""</code> quotes anymore.
Otherwise, it&#8217;ll force you to consider the issue from the very beginning,
rather than letting you write &#8220;working&#8221; programs
that crash the moment they have to process some non-<span class="caps">ASCII</span>&nbsp;input.</p>
<h4>Laziness by&nbsp;default</h4>
<p>The second major change that Python 3 brings is of similar nature.
It is also a change of <em>defaults</em>, but the impetus for it is much less&nbsp;evident.</p>
<p>What&#8217;s different in Python 3 is that many built-in functions and methods which used to return <code>list</code>s
are now giving out bespoke objects that only <em>mostly</em> behave like <code>list</code>s.
Included in these are functions like <code>map</code> or <code>filter</code>,
as well as common <code>dict</code>ionary methods such as <code>keys</code> or <code>values</code>.</p>
<p>This change is usually presented as removal of unnecessary&nbsp;cruft:</p>
<ul>
<li><code>itertools.ifilter</code> is now just <code>filter</code></li>
<li><code>xrange</code> is now just <code>range</code></li>
<li><code>dict.iteritems</code> is now just <code>dict.items</code></li>
</ul>
<p>and so&nbsp;on.</p>
<p>In some cases, this is exactly what happens.
For example, there is virtually no downside to the new implementation of <code>range</code>,
especially considering the way it is used most&nbsp;often.</p>
<p>But not every built-in managed to preserve all the functionality of <code>list</code>s.
Indeed, many have <a href="https://docs.python.org/3/library/functions.html?highlight=iterator#map">downgraded</a>
their <span class="caps">API</span> guaratees to those of mere <em>generators</em>,
i.e. the most simplistic and limited flavor of Python iterables.
Working with them is trickier and more error-prone than with lists,
which is due to <a href="http://xion.org.pl/2012/02/08/generator-pitfalls/">various pitfalls</a>
that generators expose us&nbsp;to.</p>
<p>Navigating around those gotchas used to be something that Python code had to opt-in to,
by explicitly importing <a href="https://docs.python.org/2.7/library/itertools.html">the <code>itertools</code> module</a>
and using its functions in place of the built-ins.
What you could gain in return was increased performance, and a lesser memory footprint.
All those benefits came from making the computations <em>lazy</em>
and refraining from storage of the intermediate&nbsp;results.</p>
<p>In Python 3, however, laziness is <em>preordained</em>.
Even if we don&#8217;t need or care about the aforementioned perks,
we have to devise some way of dealing with the pervasive&nbsp;generators.</p>
<p>One option is to embrace lazy evaluation fully,
and adapt to handling unspecified iterables throughout our code bases.<br>
The risk is an increased frequency of bugs stemming from generator misuse &#8212;
including a common mistake of trying to iterate over lazy <code>foos</code> the second time,
deeper down a long function, after it&#8217;s been already&nbsp;exhausted.</p>
<p>The alternative is to engage in a lot of &#8220;defensive <code>list</code>ing&#8221;:
wrapping of unknown (or known-but-lazy) iterables in <code>list()</code> calls
in order to &#8220;sanitize&#8221; them for later (re)use.<br>
Examples include immediate <code>list</code>ification of a generator&nbsp;object:</p>
<div class="highlight"><pre><span class="n">primes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">is_prime</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">)))</span>
</pre></div>


<p>or preemptive conversion of an incoming iterable&nbsp;argument:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">do_something</span><span class="p">(</span><span class="n">foos</span><span class="p">):</span>
    <span class="n">foos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">foos</span><span class="p">)</span>
    <span class="c"># ...the rest of a long function...</span>
</pre></div>


<p>Even if you choose the first path, and somehow use lazy generators everywhere,
conversions are still required at the serialization&nbsp;boundaries:</p>
<div class="highlight"><pre><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;foo&#39;</span><span class="p">:</span> <span class="mi">42</span><span class="p">}</span>
<span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s">&#39;keys&#39;</span><span class="p">:</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()})</span>  <span class="c"># TypeError: dict_keys([&#39;foo&#39;]) is not JSON serializable</span>
<span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s">&#39;keys&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">())})</span>  <span class="c"># works</span>
</pre></div>


<p>At least in this case, the lazy iterable will vocally fail with an exception,
rather than silently doing nothing (in case of repeated iteration)
or always posing as truthy even when it&#8217;s empty (in <code>if iterable:</code> checks).</p>
<h4>from __future__ import&nbsp;doubts</h4>
<p>So, here they are: the highlights of Python 3.
If you are disappointed they all turned out to be mixed blessings,
don&#8217;t worry: you are
<a href="http://lucumr.pocoo.org/2011/12/7/thoughts-on-python3/">in</a>
<a href="http://lucumr.pocoo.org/2014/1/5/unicode-in-2-and-3/">a</a>
<a href="http://lucumr.pocoo.org/2014/5/12/everything-about-unicode/">good</a>
<a href="http://lucumr.pocoo.org/2014/8/16/the-python-i-would-like-to-see/">company</a>.</p>
<p>The truth is that Python 3 is more finnicky, less forgiving,
and much less beginner-friendly than its predecessor.
Its various <a href="https://www.python.org/dev/peps/pep-0237/">superficial simplifications</a> are almost squarely balanced
by many new concerns that are thrust upon an unsuspecting programmer from the very&nbsp;beginning.</p>
<p>In one possible view, this is simply a sign that the language has <em>matured</em>.
Perhaps it&#8217;s not a coincidence
that almost exactly <a href="http://python-history.blogspot.com/2009/01/brief-timeline-of-python.html">18 years</a>
has passed between the first public version of Python (0.9)
and the release of Python 3.0.
By no conceivable means it is a toy language anymore,
and it&#8217;s adequately equipped to tackle challenges presented by the computing world of&nbsp;today.</p>
<p>But on the other hand, it&#8217;s clear something is being gradually lost in the&nbsp;process.</p>
<p>It&#8217;s becoming harder to claim the language favors simplicity
over <a href="https://www.python.org/dev/peps/pep-0492/">complexity</a>.<br>
It is no longer so easy to pick <a href="https://www.python.org/dev/peps/pep-3101/">which way</a>
is the <em>obvious</em> way to do it.<br>
It is increasingly often that <a href="https://www.python.org/dev/peps/pep-3113/">ugly replaces beautiful</a>
and <a href="https://www.python.org/dev/peps/pep-3108/">nested replaces flat</a>.</p>
<p>Little by little, Python itself is becoming less and less <em>pythonic</em>.
The pace isn&#8217;t breakneck, but it&#8217;s definitely noticeable.
But who knows? Maybe after two decades,
a wholesale redefinition of the language&#8217;s core principles really <em>is</em> in&nbsp;order.</p>
<p>&#8230;Well, certainly that&#8217;s necessary if some of the <a href="https://www.python.org/dev/peps/pep-0526/">latest ideas</a>
are about to get&nbsp;in!</p>
      <a class="btn" href="http://xion.io/post/code/python3-primer.html#python3-primer">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-for-loop.html#rust-for-loop">for loops in&nbsp;Rust</a></h2>
    <p>
      Posted on Tue 26 July 2016 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/loops.html">loops</a>,      <a href="http://xion.io/tag/iterators.html">iterators</a>      &#8226; <a href="http://xion.io/post/code/rust-for-loop.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>In this post, I&#8217;m going to talk about the <code>for</code> loop construct in <a href="https://rust-lang.org">Rust</a>,
as well as the related concepts of <em>iterators</em> and&nbsp;&#8220;iterables&#8221;.</p>
<p>Depending on your programming language background,
they may seem somewhat familiar in terms of syntax <span class="amp">&amp;</span> semantics,
or rather mysterious and surprising.
Their closest analogues exist in Python,
but programmers of Java, C#, or (modern) C++ should recognize many relevant features and ideas as&nbsp;well.</p>
<h4>Basics</h4>
<p>The syntax of a <code>for</code> loop is so modest it&#8217;s almost spartan<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="s">&quot;1&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;3&quot;</span><span class="p">];</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>As you would expect, <a href="https://is.gd/qtxqLD">this prints three lines</a> with <code>1</code>, <code>2</code>, <code>3</code>.
What is probably not as obvious is that
over the course of this loop the <code>v</code> vector was <em>expended</em>.
Trying to <a href="https://is.gd/1mv7RV">use it</a> after the iteration,
we&#8217;ll get a borrow checker&nbsp;error:</p>
<div class="highlight"><pre>&lt;anon&gt;:6:22: 6:23 error: use of moved value: `v` [E0382]
&lt;anon&gt;:4         println!(&quot;{}&quot;, x);
&lt;anon&gt;:5     }
&lt;anon&gt;:6     println!(&quot;{:?}&quot;, v);
                              ^
</pre></div>


<p>In Rust jargon, the vector has been <strong>moved</strong> into the loop.
Its ownership &#8212; and that of its individual elements &#8212; has been transfered there permanently.
While definitely surprising when compared to other languages,
this behavior is consistent with Rust&#8217;s ubiquitous policy of moving values by&nbsp;default.</p>
<p>Still, you may not expect it here
because moving ownership is mostly seen at the function call boundaries.
For most intents and purposes, however,
you can picture a <code>for_each</code> function like this to be the equivalent of the <code>for</code> loop&nbsp;above:</p>
<div class="highlight"><pre><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">));</span><span class="w"></span>
</pre></div>


<p>This also gives us a hint on how we could prevent the move from happening.
Rather than taking the vector itself,
the function could accept only a reference to&nbsp;it:</p>
<div class="highlight"><pre><span class="n">for_each_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">));</span><span class="w"></span>
</pre></div>


<p>After we translate this <a href="https://is.gd/Zrq0JL">back to the looping syntax</a>:</p>
<div class="highlight"><pre><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
</pre></div>


<p>we won&#8217;t get any more objections from the&nbsp;compiler.</p>
<h4>Iterators and &#8220;iterables&#8221; in&nbsp;Rust</h4>
<p>It is important to emphasize that this new ampersand symbol (<code>&amp;</code>)
is by no means a part of the syntax of the <code>for</code> loop itself.
We have actually changed <em>what object</em> we&#8217;re iterating here.
It is no longer <code>Vec&lt;T&gt;</code> &#8212; a vector itself &#8212; but <code>&amp;Vec&lt;T&gt;</code>, an immutable reference to it.
As a consequence, <code>x</code> is not a <code>T</code> (the element type) anymore,
but a <code>&amp;T</code> &#8212; a <em>reference</em> to an element<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>.</p>
<p>So it seems that in Rust, both <code>Vec&lt;T&gt;</code> and <code>&amp;Vec&lt;T&gt;</code> are what we would call &#8220;iterables&#8221;:
collections (or other objects) that we can get iterate over.
The usual way this is implemented in various programming languages
is by introducing an <em>iterator</em>&nbsp;object.</p>
<p>The iterator keeps track of what element it&#8217;s currently pointing to
and supports at least the following basic&nbsp;operations:</p>
<ul>
<li>getting the current&nbsp;element</li>
<li>advancing to the next&nbsp;element</li>
<li>signaling when no more elements are&nbsp;available</li>
</ul>
<p>Some languages provide separate iterator methods for each of those tasks,
but Rust chooses to combine them all into one.
You can see that when looking at the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code> trait</a>:
<code>next</code> is the only method to be provided by its&nbsp;implementations.</p>
<h4>Desugaring with&nbsp;into-iterators</h4>
<p>How is the iterator object created,&nbsp;though?</p>
<p>In a typical Rust manner, this job is delegated to another trait.
This one is called <code>IntoIterator</code>,
and it roughly corresponds to the &#8220;iterable&#8221; concept I&#8217;ve alluded to&nbsp;earlier:</p>
<div class="highlight"><pre><span class="c1">// (simplified)</span>
<span class="k">trait</span><span class="w"> </span><span class="n">IntoIterator</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">into_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>What is uniquely Rusty is the fact that <code>into_iter</code> &#8212; the sole method of this trait &#8212;
doesn&#8217;t just create a new iterator for the collection.
Instead, it effectively <em>consumes</em> the whole thing,
leaving the new iterator as its only remnant and the only way to access the items<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>.</p>
<p>This, of course, is a direct manifestation of the Rust&#8217;s move-by-default policy.
In this case, it protects us from the common problem of <strong>iterator invalidation</strong>
which is probably all-too-familiar to C++ programmers.
Because the collection is essentially &#8220;converted&#8221; to an iterator here, it is&nbsp;impossible:</p>
<ul>
<li>for more than one iterator to exist at a&nbsp;time</li>
<li>to modify the collection while any iterators are in&nbsp;scope</li>
</ul>
<p>Doesn&#8217;t all this &#8220;moving&#8221; and &#8220;consuming&#8221; sound familiar, by the way?
I&#8217;ve mentioned earlier that when we iterate over a vector with a <code>for</code> loop,
we essentially move it &#8220;into the&nbsp;loop&#8221;.</p>
<p>As you can probably deduce by now,
what really happens is that <code>IntoIterator::into_iter</code> is invoked on the vector.
Its result &#8212; the iterator object &#8212; is then repeatedly <code>next</code><span class="quo">&#8216;</span>ed until it returns <code>None</code>.</p>
<p>In a way, a <code>for</code> loop like&nbsp;this:</p>
<div class="highlight"><pre><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// body</span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>is therefore nothing else but a syntactic sugar for the following expanded&nbsp;version:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IntoIterator</span><span class="o">::</span><span class="n">into_iter</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// body</span>
<span class="w">        </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">break</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>You can see quite clearly that <code>v</code> is unusable not only after the loop ends,
but before it even <em>begins</em>.
This is because it has been moved into <code>iter</code> &#8212; into an iterator &#8212;
through an <code>into_iter</code> method&#8230; of <code>IntoIterator</code>!</p>
<p>Simple, huh?&nbsp;:)</p>
<blockquote>
<p><code>for</code> loop is just a syntactic sugar for an <code>IntoIterator::into_iter</code> invocation,
followed by repeated calling of <code>Iterator::next</code>.</p>
</blockquote>
<h4>The&nbsp;ampersand</h4>
<p>On a more serious note, this move isn&#8217;t something that we&#8217;d always want to happen.
Fortunately, we know a way to prevent it.
Rather than iterating over the vector itself, use a <em>reference</em> to&nbsp;it:</p>
<div class="highlight"><pre><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// body</span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>The great thing about this syntax is that everything said above still applies,
up to and including the desugaring procedure.
The <code>into_iter</code> method is still being invoked,
except that this time it is done on the <em>reference to the collection</em> &#8212;
<code>&amp;Vec&lt;T&gt;</code> rather than <code>Vec&lt;T&gt;</code>:</p>
<div class="highlight"><pre><span class="c1">// (simplified)</span>
<span class="k">impl</span><span class="w"> </span><span class="n">IntoIterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">into_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=&amp;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>The result is therefore an iterator that yields <em>references</em> to the elements (<code>&amp;T</code>),
rather than elements themselves (<code>T</code>).
And because <code>self</code> above is also a reference,
the collection isn&#8217;t really moved anywhere,
which is why we can freely access it after the loop&nbsp;ends.</p>
<p>The exact same thing happens when looping over a <em>mutable</em>&nbsp;reference:</p>
<div class="highlight"><pre><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// body</span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>except that this time <code>into_iter</code> is called for <code>&amp;mut Vec&lt;T&gt;</code>.
Result is therefore of type <code>Iterator&lt;Item=&amp;mut T&gt;</code>,
enabling us to modify the elements as we go through&nbsp;them.</p>
<p>No further compiler machinery is required to support those two cases,
because everything is already handled by the same&nbsp;trait.</p>
<blockquote>
<p>The <code>IntoIterator</code> desugaring works the same way for collections
<em>and</em> both immutable and mutable references to&nbsp;them.</p>
</blockquote>
<h4>What about the iter()&nbsp;method?</h4>
<p>So far, we&#8217;ve talked about regular <code>for</code> loops,
and the very imperative style of computation they&nbsp;represent.</p>
<p>If you are more inclined towards functional programming, though,
you may have seen and written rather different constructs,
combining various &#8220;fluent&#8221; methods into expressions such as this&nbsp;one:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">doubled_odds</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numbers</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
</pre></div>


<p>Methods like <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map"><code>map</code></a>
and <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter"><code>filter</code></a> here
are called <em>iterator adapters</em>,
and they are all defined on the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code> trait</a>.
Not only are they very powerful and numerous,
but they can also be supplemented through several <a href="https://crates.io/crates/itertools">third-party crates</a>.</p>
<p>In order to take advantage of the adapters, however,
we need to obtain an iterator for our collection first.
We know that <code>into_iter</code> is the way loops normally do it,
so in principle we could follow the same approach&nbsp;here:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">doubled_odds</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IntoIterator</span><span class="o">::</span><span class="n">into_iter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numbers</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
</pre></div>


<p>To spare us the verbosity of this explicit syntax,
collections normally offer an <code>iter</code> method which is exactly equivalent<sup id="fnref:4"><a class="footnote-ref" href="#fn:4" rel="footnote">4</a></sup>.
This method is what you will normally see in chained expressions like the one&nbsp;above.</p>
<blockquote>
<p><code>v.iter()</code> is just a shorthand for <code>IntoIterator::into_iter(&amp;v)</code>.</p>
</blockquote>
<h4>Why not&nbsp;both?</h4>
<p>The last thing to note is that Rust mandates neither loops nor iterator adapters
when writing code that operates on collections of elements.
When optimizations are turned on in the <a href="http://doc.crates.io/manifest.html#the-profile-sections">release mode</a>,
both versions should compile to equally efficient machine code,
with closures inlined and loops unrolled where&nbsp;necessary.</p>
<p>Choosing one style over the other is therefore a matter of convention and style.
Sometimes the right choice may actually be a <em>mix</em> of both approaches,
and Rust allows it without any&nbsp;complaints:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">print_prime_numbers_upto</span><span class="p">(</span><span class="n">n</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Prime numbers lower than {}:&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mf">2.</span><span class="p">.</span><span class="n">n</span><span class="p">).</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="n">is_prime</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Like before, this is possible through the same <code>for</code> loop desugaring
that involves the <code>IntoIterator</code> trait.
In this case, Rust will simply use a
<a href="https://github.com/rust-lang/rust/blob/bbfcb471db0799a7d92d62e66cf44bbd68051675/src/libcore/iter/traits.rs#L253">no-op implementation</a>
of this trait, &#8220;converting&#8221; any existing <code>Iterator</code> <span class="dquo">&#8220;</span>into&#8221;&nbsp;itself.</p>
<blockquote>
<p>Iterators themselves are also &#8220;iterables&#8221;,
implementing <code>IntoIterator::into_iter</code> as a&nbsp;pass-through.</p>
</blockquote>
<h4>Looping&nbsp;around</h4>
<p>If you want to know even more about iterators and loops in Rust,
the best source at this point is probably just
<a href="http://doc.rust-lang.org/std/iter/index.html#for-loops-and-intoiterator">the official documentation</a>.
And although mastering all the iterator adapters is of course not necessary to write effective Rust code,
taking a careful look at least at
<a href="http://doc.rust-lang.org/std/iter/index.html#for-loops-and-intoiterator">the <code>collect</code> method</a>
(and the associated <a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code>FromIterator</code> trait</a>)
is definitely&nbsp;helpful.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>The &#8220;two-semicolon&#8221; variant of the <code>for</code> loop doesn&#8217;t exist in Rust. Just like in Python, the equivalent is
iterating over a <a href="http://rustbyexample.com/flow_control/for.html">range object</a>, or using a regular <code>while</code> loop
for more complex cases.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>This shift is completely transparent in the loop&#8217;s body. The way it works is based on Rust&#8217;s special mechanism
called <a href="https://doc.rust-lang.org/book/deref-coercions.html">the <code>Deref</code> coercions</a>.
Without going into too much detail (as it is way out of scope for this post),
this feature allows us to treat references to objects (<code>&amp;T</code>) as if they were the objects themselves (<code>T</code>).
The compiler will perform the necessary <em>derefencing</em> where possible,
or signal an error in case of a (rare) ambiguity.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>How do we know that? It&#8217;s because <code>into_iter</code> takes <code>self</code> (rather than <code>&amp;self</code> or <code>&amp;mut self</code>)
as its first parameter. It means that the entire object for which this method is called is moved <em>into</em> its body
(hence the method&#8217;s name).&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>Curiously enough, this equivalence isn&#8217;t encoded in the type system in any way,
making it technically just a convention. It is followed consistently at least in the standard library, though.&#160;<a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/rust-for-loop.html#rust-for-loop">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/python-startswith-tuple.html#python-startswith-tuple">str.startswith() with tuple&nbsp;argument</a></h2>
    <p>
      Posted on Tue 28 June 2016 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/python.html">Python</a>,      <a href="http://xion.io/tag/strings.html">strings</a>,      <a href="http://xion.io/tag/tuples.html">tuples</a>      &#8226; <a href="http://xion.io/post/code/python-startswith-tuple.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>Here&#8217;s a little known trick that&#8217;s applicable to Python&#8217;s <a href="http://bugs.python.org/issue1491485"><code>startswith</code></a>
and <a href="http://bugs.python.org/issue1491485"><code>endswith</code></a> methods of <code>str</code> (and <code>unicode</code>).</p>
<p>Suppose you&#8217;re checking whether a string starts with some&nbsp;prefix:</p>
<div class="highlight"><pre><span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;http://&#39;</span><span class="p">):</span>
    <span class="c"># totally an URL</span>
</pre></div>


<p>You eventually add more possible prefixes (or suffixes) to your&nbsp;condition:</p>
<div class="highlight"><pre><span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;http://&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;https://&#39;</span><span class="p">):</span>
    <span class="c"># ...</span>
</pre></div>


<p>Later on you notice the repetition and refactor it into something like&nbsp;this:</p>
<div class="highlight"><pre><span class="n">SCHEMES</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;http://&#39;</span><span class="p">,</span> <span class="s">&#39;https://&#39;</span><span class="p">,</span> <span class="s">&#39;ftp://&#39;</span><span class="p">,</span> <span class="s">&#39;git://&#39;</span><span class="p">]</span>
<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">SCHEMES</span><span class="p">):</span>
    <span class="c"># ...</span>
</pre></div>


<p>or if you&#8217;re feeling extra&nbsp;functional:</p>
<div class="highlight"><pre><span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">,</span> <span class="n">SCHEMES</span><span class="p">)):</span>
    <span class="c"># ...</span>
</pre></div>


<p>Turns out, however, that <code>startswith</code> (and <code>endswith</code>) support this use case natively.
Rather than passing just a single string as the argument,
you can provide a <em>tuple</em> of strings&nbsp;instead:</p>
<div class="highlight"><pre><span class="n">SCHEMES</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;http://&#39;</span><span class="p">,</span> <span class="s">&#39;https://&#39;</span><span class="p">,</span> <span class="s">&#39;ftp://&#39;</span><span class="p">,</span> <span class="s">&#39;git://&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">SCHEMES</span><span class="p">):</span>
    <span class="c"># ...</span>
</pre></div>


<p>Either method will then check the original string against every element of the passed tuple.
Both will only return <code>True</code> if <em>at least one</em> of the strings is recognized as prefix/suffix.
As you can see, that&#8217;s exactly what we would previously do with <code>any</code>.</p>
<p>Somewhat surprisingly, however, the feature only works for actual <em>tuples</em>.
Trying to pass a seemingly equivalent iterable &#8212; a <code>list</code> or <code>set</code>, for example &#8212;
will be met with interpreter&#8217;s&nbsp;refusal:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">is_jpeg</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">([</span><span class="s">&#39;.jpg&#39;</span><span class="p">,</span> <span class="s">&#39;.jpeg&#39;</span><span class="p">])</span>
</pre></div>


<!---->

<div class="highlight"><pre>TypeError: endswith first arg must be str, unicode, or tuple, not list
</pre></div>


<p>If you dig into it, there doesn&#8217;t seem to be a compelling reason for this behavior.
The <a href="http://bugs.python.org/issue1491485">relevant feature request</a> talks about
consistency with the built-in <code>isinstance</code> function,
but it&#8217;s quite difficult to see how those two are&nbsp;related.</p>
<p>In any case, this can be worked around without much&nbsp;difficulty:</p>
<div class="highlight"><pre><span class="n">PROTOCOLS</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;http&#39;</span><span class="p">,</span> <span class="s">&#39;https&#39;</span><span class="p">,</span> <span class="s">&#39;ftp&#39;</span><span class="p">,</span> <span class="s">&#39;git&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="s">&#39;://&#39;</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">PROTOCOLS</span><span class="p">)):</span>
    <span class="c"># ...</span>
</pre></div>


<p>though ideally, you&#8217;d want to pack the prefixes in a tuple to begin&nbsp;with.</p>
      <a class="btn" href="http://xion.io/post/code/python-startswith-tuple.html#python-startswith-tuple">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/python-or-lambda.html#python-or-lambda">&#8230;or&nbsp;lambda?</a></h2>
    <p>
      Posted on Mon 20 June 2016 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/python.html">Python</a>,      <a href="http://xion.io/tag/syntax.html">syntax</a>,      <a href="http://xion.io/tag/lambda.html">lambda</a>,      <a href="http://xion.io/tag/operators.html">operators</a>      &#8226; <a href="http://xion.io/post/code/python-or-lambda.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p><em>a.k.a. Curious Facts about Python&nbsp;Syntax</em></p>
<p>In Python 3.3,
a new method has been <a href="https://docs.python.org/3/library/stdtypes.html#str.casefold">added</a> to the <code>str</code> type: <code>casefold</code>.
Its purpose is to return a &#8220;sanitized&#8221; version of the string
that&#8217;s suitable for case-insensitive comparison.
For older versions of Python,
an alternative way that&#8217;s <em>mostly</em> compatible is to use the <code>str.lower</code> method,
which simply changes all letters in the string to&nbsp;lowercase.</p>
<h4>Syntax is&nbsp;hard</h4>
<p>Easy enough for a compatibility shim, right?
That&#8217;s exactly what I thought when I came up with&nbsp;this:</p>
<div class="highlight"><pre><span class="n">casefold</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="s">&#39;casefold&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</pre></div>


<p>Let&#8217;s ignore for a moment
the fact that for a correct handling of <code>unicode</code> objects in Python 2,
a <a href="http://stackoverflow.com/a/32838944/434799">much more sophisticated approach</a> is necessary.
What&#8217;s rather more pertinent is that this simple code <em>doesn&#8217;t parse</em>:</p>
<div class="highlight"><pre>  File &quot;foo.py&quot;, line 42
    getattr(str, &#39;casefold&#39;, None) or lambda s: s.lower()
                                      ^
SyntaxError: invalid syntax
</pre></div>


<p>It&#8217;s not very often that you would produce a <code>SyntaxError</code> with code
that looks perfectly valid to most pythonistas.
The <a href="http://xion.org.pl/2012/04/16/the-infernal-comma/">last time I had it happen</a>,
the explanation was rather surprising and not exactly trivial to come&nbsp;by.</p>
<p>Fortunately, there is always one place
where we can definitively resolve any syntactic confusion.
That place is the <a href="https://docs.python.org/2/reference/grammar.html">full grammar specification</a>
of the Python&nbsp;language.</p>
<p>It may be a little intimidating at first,
especially if you&#8217;re not familiar with the <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form"><span class="caps">ENBF</span> notation</a> it uses.
All the Python&#8217;s language constructs are there, though,
so the <code>SyntaxError</code> from above should be traceable to a some rule of the grammar<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>.</p>
<h4>The&nbsp;culprit</h4>
<p>And indeed, the offending bit is right&nbsp;here:</p>
<div class="highlight"><pre>or_test: and_test (&#39;or&#39; and_test)*
and_test: not_test (&#39;and&#39; not_test)*
...
</pre></div>


<p>It says, essentially, that Python defines the <code>or</code> expression (<code>or_test</code>)
as a sequence of <code>and</code> expressions (<code>and_test</code>).
If you follow the syntax definition further, however,
you will notice that <code>and_test</code> expands to
comparisons (<code>a &lt; b</code>, etc.),
arithmetic expressions (<code>x + y</code>, etc.),
<code>list</code> <span class="amp">&amp;</span> <code>dict</code> constructors (<code>[foo, bar]</code>, etc.),
and finally to <em>atoms</em> such as literal strings and&nbsp;numbers.</p>
<p>What you <em>won&#8217;t</em> see along the way are lambda&nbsp;definitions:</p>
<div class="highlight"><pre>lambdef: &#39;lambda&#39; [varargslist] &#39;:&#39; test
</pre></div>


<p>In fact, the branch to allow them is directly above the <code>or_test</code>:</p>
<div class="highlight"><pre>test: or_test [&#39;if&#39; or_test &#39;else&#39; test] | lambdef
</pre></div>


<p>As you can see, the rule puts lambdas at the same syntactical level as conditional expressions
(<code>x if a else b</code>), which is <em>very</em> high up.
The only thing you can do with a <code>lambda</code> to make a larger expression
is to add a <code>yield</code> keyword before it<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>, or follow it with a comma to create a tuple<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>.</p>
<p>You cannot, however, pass it as an argument to a binary operator,
even if it otherwise makes sense and even <em>looks</em> unambiguous.
This is also why the nonsensical expressions such as this&nbsp;one:</p>
<div class="highlight"><pre><span class="mi">1</span> <span class="o">+</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">None</span>
</pre></div>


<p>will fail not with <code>TypeError</code>, but also with <code>SyntaxError</code>,
as they won&#8217;t even be&nbsp;evaluated.</p>
<h4>More&nbsp;parentheses</h4>
<p>Savvy readers may have noticed that this phenomenon is very much reminiscent
of the issue of <em>operator precedence</em>.</p>
<p>Indeed, in Python and in many other languages it is the grammar
that ultimately specifies the order of operations.
It does so simply by defining how expressions can be&nbsp;constructed.</p>
<p>Addition, for example, will be of lower priority than multiplication
simply because a <em>sum</em> is said to comprise of terms that are <em>products</em>:</p>
<div class="highlight"><pre>arith_expr: term ((&#39;+&#39;|&#39;-&#39;) term)*
term: factor ((&#39;*&#39;|&#39;/&#39;|&#39;%&#39;|&#39;//&#39;) factor)*
</pre></div>


<p>This makes operator precedence a syntactic feature,
and its resolution is baked into the language parser and handled implicitly<sup id="fnref:4"><a class="footnote-ref" href="#fn:4" rel="footnote">4</a></sup>.</p>
<p>We know, however, that precedence can be worked around where necessary
by enclosing the operator and its arguments in a pair of parenthesis.
On the syntax level, this means creating an entirely new, top-level&nbsp;expression:</p>
<div class="highlight"><pre>atom: &#39;(&#39; [yield_expr|testlist_comp] &#39;)&#39; |  # parenthesized expression
       &#39;[&#39; [listmaker] &#39;]&#39; |
       &#39;{&#39; [dictorsetmaker] &#39;}&#39; |
       &#39;`&#39; testlist1 &#39;`&#39; |
       NAME | NUMBER | STRING+)
</pre></div>


<p>There, it is again possible to use even the highest-level constructs,
including also the silly stuff such as trying to add a number to a&nbsp;function:</p>
<div class="highlight"><pre><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">None</span><span class="p">)</span>
</pre></div>


<p>This expression will now parse correctly,
 and produce <code>TypeError</code> as&nbsp;expected.</p>
<p>In the end, the resolution of our initial dilemma is therefore rather&nbsp;simple:</p>
<div class="highlight"><pre><span class="n">casefold</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="s">&#39;casefold&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
</pre></div>


<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Such rules are sometimes called <em>productions</em> of the grammar,
a <a href="https://en.wikipedia.org/wiki/Production_%28computer_science%29">term</a> from computational linguistics.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Yes, <code>yield foo</code> is an expression.
Its result is the value sent <em>to</em> the generator by outer code via the <code>send</code> method.
Since most generators are used as iterables, typically no values are passed this way
so the result of a <code>yield</code> expression is <code>None</code>.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>There are also a legacy corner cases of lambdas in <code>list</code>/<code>dict</code>/etc. comprehensions,
but those only apply under Python 2.x.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>This saying, there are languages where the order is resolved at later stage,
after the expressions have already been parsed. They usually allow the programmer
to change the precedence of their own operators,
as it&#8217;s the case in <a href="https://www.haskell.org/tutorial/functions.html#sect3.2.2">Haskell</a>.&#160;<a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/python-or-lambda.html#python-or-lambda">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-patterns-ref.html#rust-patterns-ref">& vs. ref in Rust&nbsp;patterns</a></h2>
    <p>
      Posted on Thu 02 June 2016 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/pattern-matching.html">pattern matching</a>,      <a href="http://xion.io/tag/borrowing.html">borrowing</a>,      <a href="http://xion.io/tag/references.html">references</a>      &#8226; <a href="http://xion.io/post/code/rust-patterns-ref.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>Rust is one of those nice languages with <em>pattern matching</em>.
If you don&#8217;t know, it can be thought of as a generalization of the <code>switch</code> statement:
comparing objects not just by value (or overloaded equality operator, etc.)
but by <em>structure</em>:</p>
<div class="highlight"><pre><span class="k">match</span><span class="w"> </span><span class="n">hashmap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">do_something_with</span><span class="p">(</span><span class="n">value</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Oh noes!&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>It doesn&#8217;t end here. As you can see above, objects can also be
<em>destructured</em> during the match (<code>Some(value)</code>),
their parts assigned to <em>bindings</em> (<code>value</code>),
and those bindings can subsequently be used in the <code>match</code> branch.</p>
<p>Neat? Definitely.
In Rust, pattern matching is bread-and-butter of not only the <code>match</code> statement,
but also <code>for</code>, (<code>if</code>)<code>let</code>, and even ordinary function&nbsp;arguments.</p>
<h4>Mixing in Rust&nbsp;semantics</h4>
<p>For a long time, however, I was somewhat confused as to what happens
when references and borrowing is involved in matching.
The two &#8220;operators&#8221; that often occur there are <code>&amp;</code> (ampersand) and <code>ref</code>.</p>
<p>You should readily recognize the first one,
as it is used pervasively in Rust to create references (and reference types).
The second one quite obviously hints towards references as well.
Yet those two constructs serve <em>very</em> different purposes when used within a&nbsp;pattern.</p>
<p>To add to the confusion, they are quite often encountered&nbsp;together:</p>
<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">hyper</span><span class="o">::</span><span class="n">Url</span><span class="p">;</span><span class="w"></span>

<span class="c1">// print query string params of some URL</span>
<span class="kd">let</span><span class="w"> </span><span class="n">url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Url</span><span class="o">::</span><span class="n">parse</span><span class="p">(</span><span class="n">some_url</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">query_params</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">url</span><span class="p">.</span><span class="n">query_pairs</span><span class="p">().</span><span class="n">unwrap_or</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[]);</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">query_params</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}={}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Lack of one or the other will be (at best) pointed out to you by the compiler,
along with a suggestion where to add it.
But addressing problems in this manner can only go so far.
So how about we delve deeper and see what it&#8217;s really&nbsp;about?</p>
<h4>Part of the reference, part of the&nbsp;pattern</h4>
<p>Rust is very flexible as to what value can be a subject of pattern matching.
You would be very hard pressed to find anything that <em>cannot</em> be used within a <code>match</code> statement, really.
Both actual objects and references to objects are perfectly&nbsp;allowed:</p>
<div class="highlight"><pre><span class="k">struct</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="kt">i32</span><span class="p">);</span><span class="w"></span>
<span class="c1">// ...</span>
<span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Foo</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span><span class="w"></span>
<span class="k">match</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Matched!&quot;</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>In the latter case, however, we aren&#8217;t typically interested in the reference itself (like above).
Instead, we want to determine some facts about the object it <em>points</em>&nbsp;to:</p>
<div class="highlight"><pre><span class="k">match</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">Foo</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Matched with number {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>As you can see, this is where the ampersand comes into play.
Just like a type constructor (<code>Some</code>, <code>Ok</code>, or <code>Foo</code> above),
the <code>&amp;</code> operator informs the Rust compiler what kind of value we&#8217;re expecting from the match.
When it sees the ampersand, it knows we&#8217;re looking for <em>references</em> to certain objects,
and not for the objects&nbsp;themselves.</p>
<p>Why is the distinction between an object and its reference important, though?
In many other places, Rust is perfectly happy to blur the gap between references and actual objects<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup> &#8212;
for example when calling most of their&nbsp;methods.</p>
<p>Pattern matching, however,
due to its ability to unpack values into their constituent parts,
is a <em>destructive</em> operation. Anything we apply <code>match</code> (or similar construct) to
will be <em>moved</em> into the block by&nbsp;default:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">maybe_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;Alice&quot;</span><span class="p">));</span><span class="w"></span>
<span class="c1">// ...</span>
<span class="k">match</span><span class="w"> </span><span class="n">maybe_name</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Hello, {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{},</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">do_something_with</span><span class="p">(</span><span class="n">maybe_name</span><span class="p">)</span><span class="w"></span>
</pre></div>


<p>Following the typical <a href="https://doc.rust-lang.org/book/ownership.html">ownership semantics</a>,
this will prevent any subsequent moves and essentially consume the&nbsp;value:</p>
<div class="highlight"><pre>error: use of partially moved value: `maybe_name` [E0382]
    do_something_with(maybe_name);
                      ^~~~~~~~~~
</pre></div>


<p>So just like the aforementioned type constructors (<code>Some</code>, etc.),
the ampersand operator is simply <em>part of the pattern</em> that we match against.
And just like with <code>Some</code> and friends, there is an obvious symmetry here:
if <code>&amp;</code> was used to create the value, it needs to be used when unpacking&nbsp;it.</p>
<blockquote>
<p>The syntax used in a pattern that destructures an object
is analogous to one used by the expression which created&nbsp;it.</p>
</blockquote>
<h4>Preventing the&nbsp;move</h4>
<p>Errors like the one above often contain helpful&nbsp;notes:</p>
<div class="highlight"><pre>note: `(maybe_name:core::option::Option::Some).0` moved here because it has type `collections::string::String`, which is moved by default
         Some(n) =&gt; println!(&quot;Hello, {}&quot;, n),
              ^
</pre></div>


<p>as well as hints for resolving&nbsp;them:</p>
<div class="highlight"><pre>help: if you would like to borrow the value instead, use a `ref` binding as shown:
        Some(ref n) =&gt; println!(&quot;Hello, {}&quot;, n),
</pre></div>


<p>Here&#8217;s where <code>ref</code> enters the&nbsp;scene.</p>
<p>The message tells us that if we add a <code>ref</code> keyword in the suggested spot,
we will switch from moving to <em>borrowing</em> for the <code>match</code> binding that follows (here, <code>n</code>).
It will still capture its value exactly as before,
but it will no longer assume <em>ownership</em> of&nbsp;it.</p>
<p>This is the crucial&nbsp;difference.</p>
<p>Unlike the ampersand, <code>ref</code> is <strong>not</strong> something we match against.
It doesn&#8217;t affect what values match the pattern it&#8217;s in, and what values don&#8217;t<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>.</p>
<p>The only thing it changes is how parts of the matched value
are <em>captured</em> by the pattern&#8217;s&nbsp;bindings:</p>
<ul>
<li>by default, without <code>ref</code>, they are <em>moved</em> into the <code>match</code> arms</li>
<li>with <code>ref</code>, they are <em>borrowed</em> instead and represented as&nbsp;references</li>
</ul>
<p>Looking at our example, the <code>n</code> binding in <code>Some(n)</code> is of type <code>String</code>:
the actual field type from the matched structure.
By contrast, the other <code>n</code> in <code>Some(ref n)</code> is a <code>&amp;String</code> &#8212;
that is, a <em>reference</em> to the&nbsp;field.</p>
<p>One is a move, the other one is a&nbsp;borrow.</p>
<blockquote>
<p><code>ref</code> annotates pattern bindings to make them borrow rather than move.
It is <em>not</em> a part of the pattern as far as matching is&nbsp;concerned.</p>
</blockquote>
<h4>Used&nbsp;together</h4>
<p>To finish off, let&#8217;s untangle the confusing example from the beginning of this&nbsp;post:</p>
<div class="highlight"><pre><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">query_params</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}={}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Since we know <code>ref</code> doesn&#8217;t affect whether or not the pattern matches,
we could just as well have something like <code>&amp;(a, b)</code>.
And this should be quite a bit easier to read:
it clearly denotes we expect a reference to a 2-tuple of simple objects.
Not coincidentally,
such tuples are items from the vector we&#8217;re iterating&nbsp;over.</p>
<p>Problem is,
without the <code>ref</code>s we will attempt to <em>move</em> those items into the loop scope.
But due to the way the vector is iterated over (<code>&amp;query_params</code>),
we&#8217;re only <em>borrowing</em> each item, so this is actually impossible.
In fact, it would be a classic attempt to move out of a borrowed&nbsp;context.</p>
<p>It is also wholly unnecessary.
The only thing this loop does is printing the items out,
so accessing them through references is perfectly&nbsp;fine.</p>
<p>And this is exactly what the <code>ref</code> operator gives us.
Adding the keyword back,
we will switch from moving the values to just borrowing them&nbsp;instead.</p>
<h4>To sum&nbsp;up</h4>
<ul>
<li>
<p><code>&amp;</code> denotes that your pattern <strong>expects a reference</strong> to an object.
Hence <code>&amp;</code> is a part of said pattern:
<code>&amp;Foo</code> matches <em>different</em> objects than <code>Foo</code> does.</p>
</li>
<li>
<p><code>ref</code> indicates that you want a <strong>reference to an unpacked value</strong>.
It is <em>not</em> matched against:
<code>Foo(ref foo)</code> matches <em>the same</em> objects as <code>Foo(foo)</code>. </p>
</li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>The technical term for this is
a <a href="https://doc.rust-lang.org/book/deref-coercions.html"><em><code>Deref</code> coercion</em></a>.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>We can say that it doesn&#8217;t affect the <em>satisfiability</em>
(or conversely, <em>refutability</em>) of the pattern.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/rust-patterns-ref.html#rust-patterns-ref">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/python-mock-configure.html#python-mock-configure">Mock.configure_mock fix for&nbsp;Python</a></h2>
    <p>
      Posted on Sat 07 May 2016 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/python.html">Python</a>,      <a href="http://xion.io/tag/mock.html">mock</a>,      <a href="http://xion.io/tag/patching.html">patching</a>      &#8226; <a href="http://xion.io/post/code/python-mock-configure.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>Python&#8217;s <a href="https://docs.python.org/3/library/unittest.mock.html">mocking library</a> is rather uncomplicated.
Most of what it does is creating <em>mock objects</em>: veritable sponges that absorb every interaction with any code
that we pass them&nbsp;to.</p>
<p>This simplicity is also surfaced in the <span class="caps">API</span>, especially in the main part of it &#8212; the <code>mock.Mock</code> constructor:</p>
<div class="highlight"><pre><span class="n">some_mock</span> <span class="o">=</span> <span class="n">mock</span><span class="o">.</span><span class="n">Mock</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s">&#39;http://example.com&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">some_mock</span><span class="o">.</span><span class="n">url</span> <span class="o">==</span> <span class="s">&#39;http://example.com&#39;</span>
</pre></div>


<p>Any arguments that we pass there become attributes on the resulting mock object. This is really useful when
<a href="https://docs.python.org/3/library/unittest.mock.html#the-patchers">patching</a>, because it allows us to completely specify
the replacement object within a <code>@mock.patch</code> decorator:</p>
<div class="highlight"><pre><span class="nd">@patch.object</span><span class="p">(</span><span class="n">requests</span><span class="p">,</span> <span class="s">&#39;get&#39;</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="n">Mock</span><span class="p">(</span><span class="n">status_code</span><span class="o">=</span><span class="mi">400</span><span class="p">)))</span>
<span class="k">def</span> <span class="nf">test_404</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">NotFoundError</span><span class="p">):</span>
        <span class="n">do_stuff</span><span class="p">()</span>
</pre></div>


<p>You have to keep in mind, however, that the <code>mock.Mock</code> class also has some
<a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock">constructor arguments</a> of its own.
For this reason, there exists some potential for name collision: some of the <code>Mock</code><span class="quo">&#8216;</span>s own arguments may have the same
names as the <em>attributes</em> we&#8217;d like to set on the mock&nbsp;object:</p>
<div class="highlight"><pre><span class="n">some_mock</span> <span class="o">=</span> <span class="n">mock</span><span class="o">.</span><span class="n">Mock</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;John Doe&quot;</span><span class="p">)</span>  <span class="c"># doesn&#39;t set the `name` attribute</span>
<span class="k">assert</span> <span class="n">some_mock</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&quot;John Doe&quot;</span>  <span class="c"># blows up!</span>
</pre></div>


<p>Here, the <code>name</code> argument is inherent to the <code>Mock</code> class. Its constructor will interpret it in a special way,
and so it <em>won&#8217;t</em> set a <code>name</code> attribute on the resulting mock. Other possible culprits include the <code>spec</code> and <code>wraps</code>
parameters, both of which have relatively common names that we may want to use as object attributes<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>.</p>
<h4>Collision&nbsp;avoidance</h4>
<p>It&#8217;s trivial to fix the issue, of&nbsp;course:</p>
<div class="highlight"><pre><span class="n">some_mock</span> <span class="o">=</span> <span class="n">mock</span><span class="o">.</span><span class="n">Mock</span><span class="p">()</span>
<span class="n">some_mock</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;John Doe&quot;</span>
<span class="k">assert</span> <span class="n">sock_mock</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&quot;John Doe&quot;</span>
</pre></div>


<p>but this approach has a downside. Creating and configuring a mock is no longer a single expression, which means we cannot
use it with patchers as easily as&nbsp;before:</p>
<div class="highlight"><pre><span class="nd">@patch.object</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="s">&#39;bar&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test_something</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mock_bar</span><span class="p">):</span>
    <span class="n">mock_bar</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;John Doe&quot;</span>
    <span class="c"># (...rest of the test...)</span>
</pre></div>


<p>We can either configure the mock after patching, like above, or perhaps introduce some utility functions to be called
inside the <code>@patch</code> decorator.</p>
<h4>The almost-there&nbsp;method</h4>
<p>In any case, this is somewhat disappointing. And it is even more so when we discover that there is
<a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.configure_mock">a method called <code>configure_mock</code></a>
which <em>looks</em> like it was designed to solve this very issue. Its arguments are always interpreted as attributes
of the mock: it has no &#8220;special&#8221; or &#8220;reserved&#8221; names. Indeed, this method is what allows us to actually
write the mock setup as a single&nbsp;expression:</p>
<div class="highlight"><pre><span class="n">some_mock</span><span class="o">.</span><span class="n">configure_mock</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;John Doe&quot;</span><span class="p">)</span>
</pre></div>


<p>Problem is, this expression returns <code>None</code>.</p>
<p>Yes, <code>configure_mock</code> returns nothing.<br>
Or in other words, it doesn&#8217;t return anything.<br>
In fact, it has <a href="https://github.com/testing-cabal/mock/blob/286792b2cd5b5baa8338260538ed207391280e34/mock/mock.py#L671">no <code>return</code> statement</a>&nbsp;whatsoever.</p>
<p>Most importantly, it doesn&#8217;t have the <code>return self</code> line that&#8217;d enable us to write&nbsp;this:</p>
<div class="highlight"><pre><span class="n">some_mock</span> <span class="o">=</span> <span class="n">mock</span><span class="o">.</span><span class="n">Mock</span><span class="p">()</span><span class="o">.</span><span class="n">configure_mock</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;John Doe&quot;</span><span class="p">)</span>
</pre></div>


<p>Well, that is <em>quite</em> a&nbsp;let-down.</p>
<h4>Fixing&nbsp;it</h4>
<p>But hey, this is Python! Shortcomings like that don&#8217;t necessarily mean we have to fork whole libraries.
Let&#8217;s just add the missing <code>return</code>, shall&nbsp;we?</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">mock</span> <span class="kn">import</span> <span class="n">Mock</span> <span class="k">as</span> <span class="n">_Mock</span>

<span class="k">class</span> <span class="nc">Mock</span><span class="p">(</span><span class="n">_Mock</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">configure_mock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Mock</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">configure_mock</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>  <span class="c"># &lt;-- there!</span>
</pre></div>


<p>Whew, that was&nbsp;quick!</p>
<p>&#8230;Alright, that&#8217;s actually the <em>whole</em> fix, but it&#8217;s close. To complete it, we need to apply the same treatment to
three more <code>Mock</code> classes: <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.MagicMock"><code>MagicMock</code></a>,
<a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.NonCallableMock"><code>NonCallableMock</code></a>,
and <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.NonCallableMagicMock"><code>NonCallableMagicMock</code></a>.</p>
<p>A complete solution can be seen in <a href="https://gist.github.com/Xion/8b98733d4b6be354be0ebae815ebd22d">this gist</a>.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Collision may also occur with <code>mock.patch</code> constructs. The most likely offender there is probably
the <a href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch"><code>new</code> parameter</a>.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/python-mock-configure.html#python-mock-configure">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/python-get-lambda-code.html#python-get-lambda-code">Source code of a Python&nbsp;lambda</a></h2>
    <p>
      Posted on Tue 19 April 2016 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/python.html">Python</a>,      <a href="http://xion.io/tag/functions.html">functions</a>,      <a href="http://xion.io/tag/ast.html">AST</a>,      <a href="http://xion.io/tag/bytecode.html">bytecode</a>      &#8226; <a href="http://xion.io/post/code/python-get-lambda-code.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p><em>&#8230;or: The Most Hideous Hack I&#8217;ve (Almost)&nbsp;Done</em></p>
<p>In <a href="http://github.com/Xion/callee">callee</a>, the <a href="http://callee.readthedocs.org">argument matcher library for Python</a> that
<a href="http://xion.io/post/news/callee-intro.html">I released recently</a>, there is this lovely
<a href="https://github.com/Xion/callee/blob/f695ff4e1c45bfd45445ebb8014a202029a93dce/callee/general.py#L55"><code>TODO</code> note</a>
for a seemingly simple feature. When using the
<a href="http://callee.readthedocs.org/en/stable/reference/general.html#callee.general.Matching"><code>Matching</code> construct</a>
with a simple <code>lambda</code> predicate:</p>
<div class="highlight"><pre><span class="n">mock_foo</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="n">Matching</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>


<p>it would be great to see its <em>code</em> in the error message if the assertion fails. Right now it&#8217;s just going to say
something like <code>&lt;Matching &lt;function &lt;lambda&gt; at 0x7f5d8a06eb18&gt;&gt;</code>. Provided you don&#8217;t possess a supernatural ability
of dereferencing pointers in your head, this won&#8217;t give you any immediate hint as to what went wrong. Wouldn&#8217;t it be nice
if it read as, say, <code>&lt;Matching \x: x % 2&gt;</code> instead?<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup></p>
<p>So I thought: why not try and implement such a mechanism? This is Python, after all &#8212; a language where you can spawn
<a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/#simple-metaclass-use">completely new classes</a>
at runtime, walk the stack <a href="https://docs.python.org/2/library/inspect.html#the-interpreter-stack">backwards</a>
(or even <a href="https://docs.python.org/2/library/sys.html#sys.settrace">forward</a>) and read the local variables,
or change the behavior of the <a href="http://xion.org.pl/2012/05/06/hacking-python-imports/">import system itself</a>.
Surely it would be possible &#8212; nay, easy &#8212; to get the source code of a short lambda function,&nbsp;right?</p>
<p>Boy, was I <em>wrong</em>.</p>
<p>Make no mistake, though: the task turned out to be absolutely doable, at least in the scope I wanted it done.
But what would you think of a solution that involves not just the usual Python hackery, but also <span class="caps">AST</span> inspection,
transformations of the source code as text, <em>and</em> bytecode&nbsp;shenanigans?&#8230;</p>
<h4>The code, all the code, and&#8230; much more than the&nbsp;code</h4>
<p>Let&#8217;s start from the beginning, though. Here&#8217;s a short lambda function, the kind of which we&#8217;d like to obtain
the source code&nbsp;of:</p>
<div class="highlight"><pre><span class="n">is_even</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>


<p>If the documentation for Python standard library is to be believed, this should be pretty easy.
In the <a href="https://docs.python.org/2/library/inspect.html"><code>inspect</code> module</a>,
there is a function called no different than
<a href="https://docs.python.org/2/library/inspect.html#inspect.getsource"><code>getsource</code></a>. For our purposes, however,
<a href="https://docs.python.org/2/library/inspect.html#inspect.getsourcelines"><code>getsourcelines</code></a> is a little more
convienient, because we can easily tell when the lambda is too&nbsp;long:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">get_short_lambda_source</span><span class="p">(</span><span class="n">lambda_func</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">source_lines</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">lambda_func</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_lines</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">source_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</pre></div>


<p>Of course if you programmed in Python for any longer period of time, you know very well that the standard docs
are <em>not</em> to be trusted. And it&#8217;s not just that the <code>except</code> clause should also include <code>TypeError</code>, because it
will be thrown when you try to pass any of the Python builtins to <code>getsourcelines</code>.</p>
<p>More important is the ambiguity of what does &#8220;source lines for an object&#8221; actually mean. &#8220;Source lines <em>containing</em>
the object definition&#8221; would be much more accurate, and this seemingly small distinction is rather crucial here.
Passing a lambda function to either <code>getsourcelines</code> or <code>getsource</code>, we&#8217;ll get its source <em>and everything else</em>
that the returned lines&nbsp;included.</p>
<p>That&#8217;s right. Say hello to the complete <code>is_even =</code> assignment, and the entire <code>assert_called_with</code> invocation!
And in case you are wondering: yes, the result will also include any end-of-line comments. No token left&nbsp;behind!</p>
<h4>Trim&nbsp;left</h4>
<p>Clearly this is more than we&#8217;ve bargained for. Maybe there is a way to strip away the unnecessary cruft? Python does
know how to parse itself, after all: the standard <a href="https://docs.python.org/2/library/ast.html"><code>ast</code> module</a>
is a manifestation of this knowledge. Perhaps we can use it to retrieve the <code>lambda</code> <span class="caps">AST</span> node in order to turn it &#8212;
and just it &#8212; back into Python&nbsp;code?&#8230;</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">get_short_lambda_ast_node</span><span class="p">(</span><span class="n">lambda_func</span><span class="p">):</span>
    <span class="n">source_text</span> <span class="o">=</span> <span class="n">get_short_lambda_source</span><span class="p">(</span><span class="n">lambda_func</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">source_text</span><span class="p">:</span>
        <span class="n">source_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source_text</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">((</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">ast</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">source_ast</span><span class="p">)</span>
                     <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Lambda</span><span class="p">)),</span> <span class="bp">None</span><span class="p">)</span>
</pre></div>


<p>But as it turns out, getting the source text back this way is only <em>mostly</em>&nbsp;possible.</p>
<p>See, every substantial <span class="caps">AST</span> node &#8212; which is either an expression (<code>ast.expr</code>) or a statement (<code>ast.stmt</code>) &#8212;
has two common attributes: <code>lineno</code> and <code>col_offset</code>. When combined, they point to a place in the original source code
where the node was parsed from. This is how we can find out where to look for the definition of our lambda&nbsp;function.</p>
<p>Looks promising, right? The only problem is we don&#8217;t know when to <em>stop</em> looking.
That&#8217;s right: nodes created by <code>ast.parse</code> are annotated with their start offset, but not with length nor the end offset.
As a result, the best we can do when it comes to carving out the lambda source from the very first example is&nbsp;this:</p>
<div class="highlight"><pre><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>


<p>So close! Those hanging parentheses are evidently just taunting us, but how can we remove them? <code>lambda</code> is basically
just a Python expression, so in principle it can be followed by almost anything. This is doubly true for lambdas inside
the <code>Matching</code> construct, as they may be a part of some larger mock&nbsp;assertion:</p>
<div class="highlight"><pre><span class="n">mock_foo</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="n">Matching</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="n">Integer</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">GreaterThan</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
</pre></div>


<p>Here, the extraneous suffix is the entirety of <code>), Integer() &amp; GreaterThan(42))</code>, quite a lot of more than just <code>))</code>.
And that&#8217;s of course nowhere near the limit of possiblities: for one, there may be more <code>lambda</code>s in there,&nbsp;too!</p>
<h4>Back off, <em>slowly</em></h4>
<p>It seems, however, that there is one thing those troublesome tails have in common: <em>they aren&#8217;t syntactically valid</em>.</p>
<p>Intuitively, a <code>lambda</code> node nested within some other syntactical constructs will have their closing fragments (e.g. <code>)</code>)
appear somewhere after its end. Without the corresponding openings (e.g. <code>Matching(</code>), those fragments won&#8217;t&nbsp;parse.</p>
<p>So here&#8217;s the crazy idea. What we have is invalid Python, but only because of some unspecified number of extra characters.
How about we just try and remove them, one by one, until we get something that <em>is</em> syntactically correct?
If we are not mistaken, this will finally be our lambda and nothing&nbsp;else.</p>
<p>The fortune favors the brave, so let&#8217;s go ahead and try&nbsp;it:</p>
<div class="highlight"><pre><span class="c"># ... continuing get_short_lambda_source() ...</span>

<span class="n">source_text</span> <span class="o">=</span> <span class="n">source_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="n">lambda_node</span> <span class="o">=</span> <span class="n">get_short_lambda_ast_node</span><span class="p">(</span><span class="n">lambda_func</span><span class="p">)</span>

<span class="n">lambda_text</span> <span class="o">=</span> <span class="n">source_text</span><span class="p">[</span><span class="n">lambda_node</span><span class="o">.</span><span class="n">col_offset</span><span class="p">:]</span>
<span class="n">min_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="s">&#39;lambda:_&#39;</span><span class="p">)</span>  <span class="c"># shortest possible lambda expression</span>
<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">lambda_text</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">min_length</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">lambda_text</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lambda_text</span>
    <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
        <span class="n">lambda_text</span> <span class="o">=</span> <span class="n">lambda_text</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="k">return</span> <span class="bp">None</span>
</pre></div>


<p>Considering that we&#8217;re basically taking lessons from the dusty old tomes in the Restricted Section of Hogwarts library,
the magic here looks quite simple. As long as there is something that can pass for a lambda definition,
we try to parse it and see if it succeeds. The line that says <code>except SyntaxError:</code> is obviously not something for
the faint of heart, but at least we are specifying
<a href="https://docs.python.org/2/howto/doanddont.html#except"><em>what</em> exception</a> we anticipate&nbsp;catching.</p>
<p>And the kicker? It <em>works</em>. By that I mean it doesn&#8217;t return garbage results for a few obvious and not so obvious
test cases, which is already more than you would normally expect from hacks of this magnitude.
All the lambdas defined until this paragraph, for example, can have their source code extracted without&nbsp;issue.</p>
<h4>Just one more&nbsp;thing</h4>
<p>So&#8230; victory? Not quite. Astute readers may recall my promise of some bytecode arcana, and now&#8217;s the time for&nbsp;it.</p>
<p>Despite the initial success of our gradual, character dropping approach, there are cases where it doesn&#8217;t produce
the correct result. Consider, for example, a lambda definition that&#8217;s nestled within a tuple<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span> <span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_short_lambda_source</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span> <span class="mi">0</span>
</pre></div>


<p>We would of course expect the result to be <code>lambda _: True</code>, without a comma or&nbsp;zero.</p>
<p>Unfortunately, here&#8217;s where our earlier assumption fails rather spectacularly. The line of code extracted from <span class="caps">AST</span>
is syntactically valid even <em>with</em> the extra characters. As a result, <code>ast.parse</code> succeeds too early and returns an
incorrect definition. It should have been of a lambda contained within a tuple, but tuple is apparently what the lambda
<em>returns</em>.</p>
<p>You may say that this is the sharp end of a narrow edge case, and anyone who defines functions like that deserves all
the trouble they get. And sure, I wouldn&#8217;t mind if we just threw hands in the air and told them we&#8217;re simply unable
to retrieve the source here. But my opinion is that it doesn&#8217;t justify serving them obviously <em>wrong</em>&nbsp;results!</p>
<h4>A halting&nbsp;problem</h4>
<p>Not if we can help it, anyway. Have a look at the expected source code and the one we&#8217;ve extracted, side by&nbsp;side:</p>
<div class="highlight"><pre><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="bp">True</span>
<span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span> <span class="mi">0</span>
</pre></div>


<p>The second line isn&#8217;t just longer: it is also <em>doing more</em>. It isn&#8217;t just defining a lambda; it defines it,
conjures up a constant <code>0</code>, and then packs them both into a tuple. That&#8217;s at least two additional steps compared to
the&nbsp;original.</p>
<p>Those steps have a more precise name, too: they are the <em>bytecode instructions</em>. Every piece of Python source is compiled
to a binary bytecode before it&#8217;s executed, because the interpreter can only work with this representation.
Compilation typically happens when a Python module is first imported, producing a <em>.pyc</em> file corresponding to its
<em>.py</em> file. Subsequent imports will simply reuse the cached&nbsp;bytecode.</p>
<p>Moreover, any function or class object has its bytecode accessible (read-only) at runtime. There is even a
<a href="http://late.am/post/2012/03/26/exploring-python-code-objects.html">dedicated data type</a> to hold it &#8212; called simply
<code>code</code> &#8212; with a buffer of raw bytes under one of its&nbsp;attributes.</p>
<p>Finally, the bytecode compiler itself is also available to Python programs as a built-in
<a href="https://docs.python.org/2/library/functions.html#compile"><code>compile</code> function</a>. You don&#8217;t see it used as often as its
counterparts <a href="https://docs.python.org/2/library/functions.html#eval"><code>eval</code></a>
and <a href="https://docs.python.org/2/reference/simple_stmts.html#exec"><code>exec</code></a> (which hopefully are a rare sight themselves!),
but it taps into the same internal machinery of&nbsp;Python.</p>
<p>So how does it all add up? The idea is, basically, to cross-check the alleged source code of the lambda with its own
<em>byte</em>code. Any junk that&#8217;s still left to trim &#8212; even if syntactically valid &#8212; will surface as a divergence after
compilation. Thus we can simply continue dropping characters until the bytecodes&nbsp;match:</p>
<div class="highlight"><pre><span class="n">lambda_text</span> <span class="o">=</span> <span class="n">source_text</span><span class="p">[</span><span class="n">lambda_node</span><span class="o">.</span><span class="n">col_offset</span><span class="p">:]</span>
<span class="n">lambda_body_text</span> <span class="o">=</span> <span class="n">source_text</span><span class="p">[</span><span class="n">lambda_node</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">col_offset</span><span class="p">:]</span>
<span class="n">min_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="s">&#39;lambda:_&#39;</span><span class="p">)</span>  <span class="c"># shortest possible lambda expression</span>
<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">lambda_text</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">min_length</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">code</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">lambda_body_text</span><span class="p">,</span> <span class="s">&#39;&lt;unused filename&gt;&#39;</span><span class="p">,</span> <span class="s">&#39;eval&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">code</span><span class="o">.</span><span class="n">co_code</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lambda_func</span><span class="o">.</span><span class="n">__code__</span><span class="o">.</span><span class="n">co_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">lambda_text</span>
    <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">lambda_text</span> <span class="o">=</span> <span class="n">lambda_text</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">lambda_body_text</span> <span class="o">=</span> <span class="n">lambda_body_text</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="k">return</span> <span class="bp">None</span>
</pre></div>


<p>Okay, maybe not the exact bytes<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>, but stopping at the identical bytecode <em>length</em> is good enough a strategy.
As an obvious bonus, <code>compile</code> will also take care of detecting syntax errors in the candidate source code,
so we don&#8217;t need the <code>ast</code> parsing&nbsp;anymore.</p>
<h4>That escalated&nbsp;quickly!</h4>
<p>Believe it or not, but there aren&#8217;t any more objections to this solution, You can view it in its glorious entirety
by looking at <a href="https://gist.github.com/Xion/617c1496ff45f3673a5692c3b0e3f75a">this gist</a>.</p>
<p>Does it mean it is also making its cameo in the <a href="https://github.com/Xion/callee"><em>callee</em> library</a>?&#8230;</p>
<p>No, I&#8217;m afraid&nbsp;not.</p>
<p>Normally, I&#8217;m not the one to shy away from, ahem, <em>bold</em> solutions to tough problems. But in this case, the magnitude
of hackery required is just too great, the result not satisfactory enough, the feature&#8217;s priority isn&#8217;t really
all that high, and the maintenance burden it&#8217;d introduce is most likely too&nbsp;large.</p>
<p>In the end, it was great fun figuring it out: yet another example of how you can fiddle with Python to do basically
anything. Still, we must not get too preoccupied with whether or not we can as to forget if we <em>should</em>.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Backslash (<code>\</code>) is how lambda functions are denoted in Haskell. We want to be short and sweet, so it feels
like a natural choice.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>This isn&#8217;t an actual snippet from a Python <span class="caps">REPL</span>, because <code>inspect.getsourcelines</code> requires the object to be
defined in a <em>.py</em> file.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>Why we won&#8217;t always get an identical bytecode? The short answer is that some instructions may be swapped
for their approximate equivalents.<br/>
The long answer is that with <code>compile</code>, we aren&#8217;t able to replicate the exact closure environment of the original lambda.
When a function refers to an <em>free variable</em> (like <code>foo</code> in <code>lambda x: x + foo</code>), it is its closure where the value
for that variable comes from. For ad-hoc lambdas, this is typically the local scope of its <em>outer function</em>.</br>
Code produced by <code>compile</code>, however, isn&#8217;t associated with any such local scope. All free names are thus assumed
to refer to <em>global</em> variables. Because Python uses different bytecode instructions for referencing local and global
names (<code>LOAD_FAST</code> vs <code>LOAD_GLOBAL</code>), the result of <code>compile</code> may differ from a piece of bytecode produced in the regular
manner.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/python-get-lambda-code.html#python-get-lambda-code">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/shell-xargs-into-find.html#shell-xargs-into-find">Pipe `xargs` into&nbsp;`find`</a></h2>
    <p>
      Posted on Sun 03 April 2016 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/shell-scripting.html">shell scripting</a>,      <a href="http://xion.io/tag/bash.html">Bash</a>,      <a href="http://xion.io/tag/xargs.html">xargs</a>,      <a href="http://xion.io/tag/find.html">find</a>,      <a href="http://xion.io/tag/zsh.html">zsh</a>      &#8226; <a href="http://xion.io/post/code/shell-xargs-into-find.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>Here&#8217;s a trick that&#8217;s hardly new, but if you haven&#8217;t heard about, it will save you a trip to a man page or&nbsp;two.</p>
<p>Assuming you&#8217;re a person who mostly prefers the terminal over some fancy <span class="caps">GUI</span>, you&#8217;ve probably used the <code>find</code> command
along with <code>xargs</code> at least a few times. It&#8217;s very common, for example, to use the results of <code>find</code> as arguments
to some other program. It could something as simple as figuring out which modules in your project have grown
slightly too&nbsp;large:</p>
<div class="highlight"><pre>$ find . -name &#39;*.py&#39; | xargs wc -l | sort -hr
1467 total
 322 callee/base.py
 261 callee/general.py
 251 callee/collections.py
# etc.
</pre></div>


<p>We find them all first, and then use <code>xargs</code> to build a long <code>wc</code> invocation, and we finally display results
in the reverse order. Pretty easy stuff: I don&#8217;t usually have to try more than a dozen times to get it right!<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup></p>
<p>But how about the opposite situation? Let&#8217;s say you have a list of <em>directories</em> you want to search through with <code>find</code>.
Doing so may seem easy enough<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>:</p>
<div class="highlight"><pre>$ cat packagedirs.txt | xargs find -name &#39;__init__.py&#39;
</pre></div>


<p>Except it&#8217;s not going to work. Like a few other Unix commands, <code>find</code> is very particular about the order of arguments
it receives. Not only are the predicate flags (like <code>-name</code>) considered in sequence, but they also have to appear
<em>after</em> the directories we want to search&nbsp;through.</p>
<p>But in the <code>xargs</code> invocation above, essentially the opposite is going to&nbsp;happen.</p>
<h4>The replacement&nbsp;flag</h4>
<p>So how to remedy this? Enter the <code>-I</code> flag to <code>xargs</code>:</p>
<div class="highlight"><pre>$ cat packagedirs.txt | xargs -I{} find {} -name &#39;__init__.py&#39;
</pre></div>


<p>This flag will tell <code>xargs</code> quite a few&nbsp;things.</p>
<p>The most important one is to stop putting the arguments at the end of the command invocation.
Instead, it shall place them wherever it sees the <em>replacement string</em> &#8212; here, pair of braces<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>: <code>{}</code>.
And because we placed the braces where <code>find</code> is normally expecting the list of directories to search through,
the command will now get us exactly the results we&nbsp;wanted.</p>
<p>What&#8217;s almost impossible to see, however, is that it may not use the exact <em>way</em> we intended to obtain those results.
The difference is easier to spot when we replace <code>find</code> with <code>echo</code>:</p>
<div class="highlight"><pre>$ cat &gt;/tmp/list
foo
bar
$ cat /tmp/list | xargs echo
foo bar
$ cat /tmp/list | xargs -I{} echo {}
foo
bar
</pre></div>


<p>or, better yet, use <code>xargs</code> with the <code>-t</code> flag to print the commands on stderr before executing&nbsp;them:</p>
<div class="highlight"><pre>$ cat packagedirs.txt | xargs -I{} -t find {} -name &#39;__init__.py&#39; &gt;/dev/null
find callee -name &#39;__init__.py&#39;
find tests -name &#39;__init__.py&#39;
</pre></div>


<p>As you can see, we actually have more than one <code>find</code> invocation&nbsp;here!</p>
<p>This is the second effect of <code>-I</code>: it causes <code>xargs</code> to execute given command line <em>for each argument separately</em>.
It so happens that it doesn&#8217;t really make any difference for our usage of <code>find</code>, which is why it wasn&#8217;t at all obvious
we were running it multiple&nbsp;times.</p>
<p>To avoid problems, though, you should definitely be cognizant of this fact when calling other programs with <code>xargs -I</code>.</p>
<h4>Make arguments spaced&nbsp;again</h4>
<p>Incidentally, I&#8217;m not aware of any method that&#8217;d actually make <code>xargs</code> produce <code>find foo bar -name ...</code> calls.
If you need this exact form, probably the easiest way is to use plain old shell&nbsp;variables:</p>
<div class="highlight"><pre>$ (d=$(cat packagedirs.txt); find $d -name &#39;*.py&#39;)
</pre></div>


<p>This takes advantage of the <a href="http://mywiki.wooledge.org/WordSplitting">word splitting</a> feature of Bash and a few other
compatible shells. Caveat is, you may be using a shell where this behavior is disabled by default. The result would be
making <code>find</code> interpret the content of <code>$d</code> as a <em>single</em> directory name: <code>foo bar</code> rather than <code>foo</code> and <code>bar</code>.</p>
<p>zsh is one such shell. Although <a href="http://zsh.sourceforge.net/FAQ/zshfaq03.html#l18">probably a good thing overall</a>,
in times like these you&#8217;d want to bring the &#8220;normal&#8221; behavior back. In zsh, it&#8217;s fortunately pretty&nbsp;simple:</p>
<div class="highlight"><pre>$ (d=$(cat packagedirs.txt); find ${=d} -name &#39;*.py&#39;)
</pre></div>


<p>What about a portable solution? As far as I can tell, the only certain way you can ensure word splitting occurs
is to use <code>eval</code>. Here, the <code>xargs</code> command can actually come in handy again, albeit only as a&nbsp;prop:</p>
<div class="highlight"><pre>$ (d=$(cat packagedirs.txt | xargs echo); eval &quot;find $d -name &#39;*.py&#39;&quot;)
</pre></div>


<p>One would hope such hacks aren&#8217;t needed very&nbsp;often.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>A completely kosher version would also use the <code>-print0</code> flag to <code>find</code> and the <code>-0</code> flag to <code>xargs</code>.
It&#8217;s not necessary here because Python module files cannot contain spaces.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Purists shall excuse my use of <code>cat</code> here, it&#8217;s merely for illustrative purposes.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>This use of braces in <code>find</code> has of course nothing to do with the <em>other</em> possible occurrences of <code>{}</code> there,
like in the <code>-exec</code> flag. Since you cannot force <code>find</code> to expect a different placeholder, you should use something else
for <code>xargs</code> in those cases, .e.g: <code>xargs -I^ find ^ -name '__main__.py' -exec 'python {}' \;</code>.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/shell-xargs-into-find.html#shell-xargs-into-find">Continue reading</a>
  </div>
</article>

  <div class="pagination">
    <a class="btn" href="http://xion.io/category/code3.html">
      <i class="fa fa-angle-left"></i> Older Posts
    </a>
    <a class="btn float-right" href="http://xion.io/category/code.html">
      Newer Posts <i class="fa fa-angle-right"></i>
    </a>
  </div>

    <footer>
<p>
  &copy; Karol Kuczmarski 2017 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-27379564-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Karol Kuczmarski's Blog ",
  "url" : "http://xion.io",
  "image": "http://xion.io/logo.jpeg",
  "description": ""
}
</script><script type="text/javascript">
    var disqus_shortname = 'xionblog';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>