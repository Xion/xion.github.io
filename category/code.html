<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/font-awesome.min.css">

    <link href="http://xion.io/style.css" rel="stylesheet">




  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

    <meta name="author" content="Karol Kuczmarski" />
    <meta name="description" content="" />
<meta property="og:site_name" content="Karol Kuczmarski's Blog"/>
<meta property="og:type" content="blog"/>
<meta property="og:title" content="Karol Kuczmarski's Blog"/>
<meta property="og:description" content=""/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://xion.io"/>
<meta property="og:image" content="http://xion.io/logo.jpeg">

  <title>Karol Kuczmarski's Blog &ndash; Category: Code</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://xion.io">
        <img src="http://xion.io/logo.jpeg" alt="Karol Kuczmarski" title="Karol Kuczmarski">
      </a>
      <h1><a href="http://xion.io">Karol Kuczmarski</a></h1>
      <p>fn(Tea) -> Code</p>
      <nav>
        <ul class="list">
          <li><a href="http://xion.io/page/about.html#about">About</a></li>
          <li><a href="http://xion.io/page/projects.html#projects">Projects</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-github" href="http://github.com/Xion" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-stack-overflow" href="http://stackoverflow.com/users/434799/xion" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
        <li><a class="sc-twitter" href="http://twitter.com/Xion__" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-google" href="https://plus.google.com/+KarolKuczmarski" target="_blank"><i class="fa fa-google"></i></a></li>
        <li><a class="sc-rss" href="/feeds/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="http://xion.io">Home</a>
      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>
      <a href="http://xion.org.pl/">Old blog</a>
    </nav>

<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-string-args.html#rust-string-args">Taking string arguments in&nbsp;Rust</a></h2>
    <p>
      Posted on Tue 24 December 2019 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/strings.html">strings</a>,      <a href="http://xion.io/tag/arguments.html">arguments</a>,      <a href="http://xion.io/tag/borrowing.html">borrowing</a>,      <a href="http://xion.io/tag/ownership.html">ownership</a>      &#8226; <a href="http://xion.io/post/code/rust-string-args.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>Strings of text seem to always be a complicated topic when it comes to programming.
This counts double for low-level languages
which expose the programmer to the full complexity of memory management and&nbsp;allocation.</p>
<p>Rust is, obviously, one of those languages.
Strings in Rust are therefore represented using two distinct types:
<code>str</code> (the string <em>slice</em>) and <code>String</code> (the owned/allocated string).
Learning <a href="https://doc.rust-lang.org/book/second-edition/ch08-02-strings.html">how to juggle those types</a>
is something you need to do very early if you want to be productive in the&nbsp;language.</p>
<p>But even after you&#8217;ve programmed in Rust for some time,
you may still trip on some more subtle issues with string handling.
In this post, I will concentrate on just one common task:
writing a function that takes a <em>string argument</em>.
We&#8217;ll see that even there, we can encounter a fair number of&nbsp;gotchas.</p>
<h4>Just reading&nbsp;it</h4>
<p>Let&#8217;s start with a simple case:
a function which merely <em>reads</em> its string&nbsp;argument:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">hello</span><span class="p">(</span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Hello, {}!&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>As you&#8217;re probably well aware,
using <code>str</code> rather than <code>String</code> is the idiomatic approach here.
Because a <code>&amp;str</code> reference is essentially an address + length,
it can point to any string wheresoever:
a <code>'static</code> literal, a heap-allocated <code>String</code>, or any portion or substring&nbsp;thereof:</p>
<div class="highlight"><pre><span class="n">hello</span><span class="p">(</span><span class="s">&quot;world&quot;</span><span class="p">);</span><span class="w"></span>
<span class="n">hello</span><span class="p">(</span><span class="o">&amp;</span><span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;Alice&quot;</span><span class="p">));</span><span class="w"></span>
<span class="n">hello</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&quot;Dennis Ritchie&quot;</span><span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="mi">6</span><span class="p">]);</span><span class="w"></span>
</pre></div>


<p>Contrast this with an argument of type <code>&amp;String</code>:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">hello</span><span class="p">(</span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">String</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Hello, {}!&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>which mandates an actual, full-blown <code>String</code> object:</p>
<div class="highlight"><pre><span class="n">hello</span><span class="p">(</span><span class="o">&amp;</span><span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;Bob&quot;</span><span class="p">));</span><span class="w"></span>
<span class="c1">// (the other examples won&#39;t work)</span>
</pre></div>


<p>There are virtually no circumstances when you would want to do this,
as it potentially forces the caller to needlessly put the string on the heap.
Even if you anticipate all function calls to involve actual <code>String</code> objects,
the automatic <code>Deref</code> coercion from <code>&amp;String</code> to <code>&amp;str</code>
should still allow you to use the more universal, <code>str</code>-based <span class="caps">API</span>.</p>
<h4>Hiding the&nbsp;reference</h4>
<p>If <em>rustc</em> can successfully turn a <code>&amp;String</code> into <code>&amp;str</code>,
then perhaps it should also be possible to simply use <code>String</code> when that&#8217;s more&nbsp;convenient?</p>
<p>In general, this kind of &#8220;reverse <code>Deref</code>&#8221; doesn&#8217;t happen in Rust
outside of method calls with <code>&amp;self</code>.
It seems, however, that it would sometimes be desirable;
one reasonable use case involves chains of iterator adapters,
most importantly <code>map</code> and <code>for_each</code>:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">strings</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="s">&quot;Alice&quot;</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;Bob&quot;</span><span class="p">.</span><span class="n">into</span><span class="p">()];</span><span class="w"></span>
<span class="n">strings</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">for_each</span><span class="p">(</span><span class="n">hello</span><span class="p">);</span><span class="w"></span>
</pre></div>


<p>Since the compiler doesn&#8217;t take advantage of<code>Deref</code> coercions when inferring closure types,
their argument types have to match exactly.
As a result, we often need explicit <code>|x| foo(x)</code> closures
which suffer from poorer readability in long <code>Iterator</code> or <code>Stream</code>-based&nbsp;expressions.</p>
<p>We can make the above code work
&#8212; and also retain the ability to make calls like <code>hello("Charlie");</code> &#8212;
by using one of the built-in traits that generalize over the borrowing relationships.
The one that works best for accepting string arguments is called <code>AsRef</code><sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">hello</span><span class="o">&lt;</span><span class="n">N</span><span class="o">:</span><span class="w"> </span><span class="n">AsRef</span><span class="o">&lt;</span><span class="kt">str</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Hello, {}!&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">.</span><span class="n">as_ref</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Its sole method, <code>AsRef::as_ref</code>, returns a reference to the trait&#8217;s type parameter.
In the case above, that reference will obviously be of type <code>&amp;str</code>,
which circles back to our initial example, one with a direct <code>&amp;str</code> argument.</p>
<p>The difference is, however, that <code>AsRef&lt;str&gt;</code> is implemented
<a href="https://play.rust-lang.org/?gist=91f084a1ae0527f3af1cba3fca421da6&amp;version=stable">for all interesting string types</a>
&#8212; both in their owned and borrowed versions.
This obviates the need for <code>Deref</code> coercions and makes the <span class="caps">API</span> more&nbsp;convenient.</p>
<h4>Own&nbsp;it</h4>
<p>Things get a little more complicated when the string parameter is needed
for more than just reading. For storage and potential mutation,
a <code>&amp;str</code> reference is not enough: you need an actual, full-blown <code>String</code> object.</p>
<p>Now, you may think this is not a huge obstacle.
After all, it&#8217;s pretty easy to &#8220;turn&#8221; <code>&amp;str</code> into a <code>String</code>:</p>
<div class="highlight"><pre><span class="k">struct</span><span class="w"> </span><span class="n">Greetings</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">names</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Greetings</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Don&#39;t do this!</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">hello</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">names</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>But I strongly advise against this practice, at least in public APIs.
If you expose such function to your users, you are essentially tricking them
into thinking their input will only ever be read, not copied,
which has implications on both performance and memory&nbsp;usage.</p>
<p>Instead, if you need to take ownership of the resulting <code>String</code>,
it is much better to indicate this in the function signature&nbsp;directly:</p>
<div class="highlight"><pre><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">hello</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">String</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">names</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">name</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>This shifts the burden on creating the <code>String</code> onto the caller,
but that&#8217;s not necessarily a bad thing.
On their side, the added boilerplate can pretty&nbsp;minimal:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">greetings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Greetings</span><span class="o">::</span><span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="n">grettings</span><span class="p">.</span><span class="n">hello</span><span class="p">(</span><span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;Dylan&quot;</span><span class="p">));</span><span class="w">  </span><span class="c1">// uhm...</span>
<span class="n">greetings</span><span class="p">.</span><span class="n">hello</span><span class="p">(</span><span class="s">&quot;Eva&quot;</span><span class="p">.</span><span class="n">to_string</span><span class="p">());</span><span class="w">      </span><span class="c1">// somewhat better...</span>
<span class="n">grettings</span><span class="p">.</span><span class="n">hello</span><span class="p">(</span><span class="s">&quot;Frank&quot;</span><span class="p">.</span><span class="n">to_owned</span><span class="p">());</span><span class="w">     </span><span class="c1">// not too bad</span>
<span class="n">greetings</span><span class="p">.</span><span class="n">hello</span><span class="p">(</span><span class="s">&quot;Gene&quot;</span><span class="p">.</span><span class="n">into</span><span class="p">());</span><span class="w">          </span><span class="c1">// good enough</span>
</pre></div>


<p>while clearly indicating where does the memory allocation&nbsp;happen.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>It is also idiomatically used for functions taking <code>Path</code> parameters,
i.e. <code>AsRef&lt;Path&gt;</code>.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/rust-string-args.html#rust-string-args">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-examples.html#rust-examples">Add examples to your Rust&nbsp;libraries</a></h2>
    <p>
      Posted on Wed 28 February 2018 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/cargo.html">Cargo</a>,      <a href="http://xion.io/tag/examples.html">examples</a>,      <a href="http://xion.io/tag/documentation.html">documentation</a>,      <a href="http://xion.io/tag/packaging.html">packaging</a>      &#8226; <a href="http://xion.io/post/code/rust-examples.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>When you&#8217;re writing a library for other programs to depend on,
it is paramount to think how the developers are going to use it in their&nbsp;code.</p>
<p>The best way to ensure they have a pleasant experience
is to <em>put yourself in their shoes</em>.
Forget the internal details of your package, and consider only its outward interface.
Then, come up with a realistic use case and just <em>implement it</em>.</p>
<p>In other words, you should create complete, end-to-end,
and (somewhat) usable <em>example applications</em>.</p>
<h4>Examples are&nbsp;trouble</h4>
<p>You may think this is asking a lot, and I wouldn&#8217;t really disagree&nbsp;here.</p>
<p>In most languages and programming platforms,
it is indeed quite cumbersome to create example apps.
This happens for at least several different&nbsp;reasons:</p>
<ul>
<li>
<p><strong>It typically requires bootstrapping an entire project from scratch.</strong>
  If you are lucky, you will have something like <code>create-react-app</code>
  to get you going relatively quickly.
  Still, you need to wire up the new project so that it depends on the <em>source code</em> of your library
  rather than its published version,
  and this tends to be a non-standard option &#8212; if it is available at&nbsp;all.</p>
</li>
<li>
<p><strong>It&#8217;s unclear where should the example code live.</strong>
  Should you just throw it away, once it has served its immediate purpose?
  I&#8217;m sure this would discourage many people from creating examples in the first place.
  It&#8217;s certainly better to keep them in the version control,
  allowing their code to serve as additional documentation.
  <br><br>
  But if you intend to do this,
  you need to be careful not to deploy the example along with your library
  when you upload it to the package registry for your language.
  This may require maintaining an explicit blacklist and/or whitelist,
  in the vein of <a href="https://docs.python.org/2/distutils/sourcedist.html#the-manifest-in-template"><code>MANIFEST</code> files</a>
  in&nbsp;Python.</p>
</li>
<li>
<p><strong>Examples may break as the library changes.</strong>
  Although example apps aren&#8217;t integration tests that have a clear, expected outcome,
  they should at the very least <em>compile correctly</em>.
  <br><br>
  The only way to ensure that is to include them in the build/test pipeline of your library.
  To accomplish this, however, you may need to complicate your <abbr title="continuous integration"><span class="caps">CI</span></abbr> setup,
  perhaps by introducing additional languages like Bash or&nbsp;Python.</p>
</li>
<li>
<p><strong>It&#8217;s harder to maintain quality of example code.</strong>
  Any linters and static analyzers that you&#8217;re normally running will likely need to be configured
  to also apply to the examples.
  On the other hand, however, you probably don&#8217;t want those checkers to be <em>too strict</em>
  (it&#8217;s just example code, after all), so you may want to turn off some of the warnings,
  adjust the level of others, and so&nbsp;on.</p>
</li>
</ul>
<p>So essentially, writing examples involves quite a lot of hassle.
It would be great if the default tooling of your language
helped to lessen the burden at least a <em>little</em>&nbsp;bit.</p>
<p>Well, good news! If you&#8217;re a <a href="http://rust-lang.org">Rust</a> programmer,
the language has basically got you&nbsp;covered.</p>
<p>Cargo &#8212; the standard build tool and package manager for Rust &#8212;
has some dedicated features to support <em>examples</em> as a first-class concept.
While it doesn&#8217;t completely address all the pain points outlined above,
it goes a long way towards minimizing&nbsp;them.</p>
<h4>What are Cargo&nbsp;examples?</h4>
<p>In Cargo&#8217;s parlance, an <em>example</em> is nothing else
but a Rust source code of a standalone executable<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>
that typically resides in a single <code>.rs</code> file.
All such files should be places in the <code>examples/</code> directory,
at the same level as <code>src/</code> and the <code>Cargo.toml</code> manifest itself<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>.</p>
<p>Here&#8217;s the simplest example of, ahem, an <em>example</em>:</p>
<div class="highlight"><pre><span class="c1">// examples/hello.rs</span>
<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Hello from an example!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>You can run it through the typical <code>cargo run</code> command;
simply pass the example name after the <code>--example</code> flag:</p>
<div class="highlight"><pre>$ cargo run --example hello
Hello from an example!
</pre></div>


<p>It is also possible to run the example with some additional&nbsp;arguments:</p>
<div class="highlight"><pre>$ cargo run --example hello2 -- Alice
Hello, Alice!
</pre></div>


<p>which are relayed directly to the underlying&nbsp;binary:</p>
<div class="highlight"><pre><span class="c1">// examples/hello2.rs</span>
<span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">env</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span><span class="o">::</span><span class="n">args</span><span class="p">().</span><span class="n">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">next</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Hello, {}!&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">.</span><span class="n">unwrap_or</span><span class="p">(</span><span class="s">&quot;world&quot;</span><span class="p">.</span><span class="n">into</span><span class="p">()));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>As you can see, the way we run examples is very similar to how we&#8217;d run
<a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-project-layout">the <code>src/bin</code> binaries</a>,
which some people use as normal entry points to their Rust&nbsp;programs.</p>
<p>The important thing is that you don&#8217;t have to worry what to do with your example code anymore.
All you need to do is drop it in the <code>examples/</code> directory,
and let Cargo do the&nbsp;rest.</p>
<h4>Dependency&nbsp;included</h4>
<p>Of course in reality,
your examples will be at least a <em>little</em> more complicated than that.
For one, they will surely call into your library to use its <span class="caps">API</span>,
which means they need to depend on it <span class="amp">&amp;</span> import its&nbsp;symbols.</p>
<p>Fortunately, this doesn&#8217;t complicate things even one&nbsp;bit.</p>
<p>The library crate itself is already an <em>implied dependency</em> of any code
inside the <code>examples/</code> directory.
This is automatically handled by Cargo,
so you don&#8217;t have to modify <code>Cargo.toml</code> (or do anything else really)
to make it&nbsp;happen.</p>
<p>So without any additional effort,
you can just to link to your library crate in the usual manner,
i.e. by putting <code>extern crate</code> on top of the Rust&nbsp;file:</p>
<div class="highlight"><pre><span class="c1">// examples/real.rs</span>
<span class="k">extern</span><span class="w"> </span><span class="n">crate</span><span class="w"> </span><span class="n">mylib</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mylib</span><span class="o">::</span><span class="n">make_a_thing</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;I made a thing: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">thing</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>This goes even further, and extends to any dependency <em>of the library itself</em>.
All such third-party crates are automatically available to the example code,
which proves handy in common cases such as <a href="http://tokio.rs">Tokio</a>-based asynchronous&nbsp;APIs:</p>
<div class="highlight"><pre><span class="c1">// example/async.rs</span>
<span class="k">extern</span><span class="w"> </span><span class="n">crate</span><span class="w"> </span><span class="n">mylib</span><span class="p">;</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="n">crate</span><span class="w"> </span><span class="n">tokio_core</span><span class="p">;</span><span class="w">  </span><span class="c1">// assuming it&#39;s in mylib&#39;s [dependencies]</span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">core</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokio_core</span><span class="o">::</span><span class="n">reactor</span><span class="o">::</span><span class="n">Core</span><span class="o">::</span><span class="n">new</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">core</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">mylib</span><span class="o">::</span><span class="n">make_a_thing_asynchronously</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;I made a thing: {:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">thing</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<h4>More&nbsp;deps</h4>
<p>Sometimes, however, it is very useful to pull in an additional package or two,
just for the example&nbsp;code.</p>
<p>A typical case may involve <em>logging</em>.</p>
<p>If your library uses the usual <a href="https://docs.rs/log"><code>log</code> crate</a> to output debug messages,
you probably want to see them printed out when you run your examples.
Since the <code>log</code> crate is just a <a href="https://en.wikipedia.org/wiki/Facade_pattern">facade</a>,
it doesn&#8217;t offer any built-in way to pipe log messages to standard output.
To handle this part,
you need something like <a href="http://docs.rs/env_logger">the <code>env_logger</code> package</a>:</p>
<div class="highlight"><pre><span class="c1">// example/with_logging.rs</span>
<span class="k">extern</span><span class="w"> </span><span class="n">crate</span><span class="w"> </span><span class="n">env_logger</span><span class="p">;</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="n">crate</span><span class="w"> </span><span class="n">mylib</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">env_logger</span><span class="o">::</span><span class="n">init</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mylib</span><span class="o">::</span><span class="n">make_a_thing</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>To be able to import <code>env_logger</code> like this,
it natually has to be declared as a dependency in our <code>Cargo.toml</code>.</p>
<p>We won&#8217;t put it in the <code>[dependencies]</code> section of the manifest,
however, as it&#8217;s not needed by the library code.
Instead, we should place it in a
<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies">separate section</a>
called <code>[dev-dependencies]</code>:</p>
<div class="highlight"><pre><span class="k">[dev-dependencies]</span>
<span class="na">env_logger</span> <span class="o">=</span> <span class="s">&quot;0.5&quot;</span>
</pre></div>


<p>Packages listed there are shared by tests, benchmarks, and &#8212; yes, examples.
They are not, however, linked into regular builds of your library,
so you don&#8217;t have to worry about bloating it with unnecessary&nbsp;code.</p>
<h4>Growing&nbsp;bigger</h4>
<p>So far, we have seen examples that span just a single Rust file.
Practical applications tend to be bigger than that,
so it&#8217;d be nice if we could provide some multi-file examples as&nbsp;well.</p>
<p>This is easily done, although for some reason it doesn&#8217;t seem to be mentioned
in <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#examples">the official docs</a>.</p>
<p>In any case, the approach is identical to
<a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-project-layout">executables inside <code>src/bin/</code></a>.
Basically, if we have a single <code>foo.rs</code> file with executable code,
we can expand it to a <code>foo/</code> subdirectory with <code>foo/main.rs</code> as the entry point.
Then, we can add whatever other submodules we want &#8212;
just like we would do for a regular Rust binary&nbsp;crate:</p>
<div class="highlight"><pre><span class="c1">// examples/multifile/main.rs</span>
<span class="k">extern</span><span class="w"> </span><span class="n">crate</span><span class="w"> </span><span class="n">env_logger</span><span class="p">;</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="n">crate</span><span class="w"> </span><span class="n">mylib</span><span class="p">;</span><span class="w"></span>

<span class="kn">mod</span><span class="w"> </span><span class="n">util</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">env_logger</span><span class="o">::</span><span class="n">init</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ingredient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">util</span><span class="o">::</span><span class="n">create_ingredient</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mylib</span><span class="o">::</span><span class="n">make_a_thing_with</span><span class="p">(</span><span class="n">ingredient</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">thing</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<!-- -->

<div class="highlight"><pre><span class="c1">// examples/multifile/util.rs</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">create_ingredient</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="mi">42</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Of course, it won&#8217;t be often that examples this large are necessary.
Showing how a library can scale to bigger applications can, however,
be very encouraging to potential&nbsp;users.</p>
<h4>Maintaining&nbsp;maintainability</h4>
<p>Thus far, we have discussed how to create small and larger examples,
how to use additional third-party crates in example programs,
and how to easily build <span class="amp">&amp;</span> run them using built-in Cargo&nbsp;commands.</p>
<p>All this effort spent on writing examples would be of little use
if we couldn&#8217;t ensure that they <em>work</em>.</p>
<p>Like every type of code,
examples are prone to breakage whenever the underlying <span class="caps">API</span> changes.
If the library is actively developed, its interface represents a moving target.
It is quite expected that changes may sometimes cause old examples to stop&nbsp;compiling.</p>
<p>Thankfully, Cargo is very dilligent in reporting such breakages.
Whenever you&nbsp;run:</p>
<div class="highlight"><pre>$ cargo test
</pre></div>


<p><em>all examples are built</em> simultaneously with the execution of your regular test suite<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>.
You get the compilation guarantee for your examples essentially for free
&#8212; there is no need to even edit your <code>.travis.yml</code>,
or to adjust your continuous integration setup in any other&nbsp;way!</p>
<p>Pretty neat,&nbsp;right?</p>
<p>This saying, you should keep in mind that
simply compiling your examples on a regular basis is not a foolproof guarantee
that their code never becomes outdated.
Examples are <em>not</em> integration tests,
and they won&#8217;t catch important changes in your implementation
that aren&#8217;t breaking the&nbsp;interface.</p>
<h4>Examples-Driven&nbsp;Development?</h4>
<p>You may be wondering then, what&#8217;s exactly the point of writing examples?
If you got tests on one hand to verify correctness,
and documentation on the other hand to inform your users,
then having a bunch of dedicated executable examples may seem&nbsp;superfluous.</p>
<p>To me, however, an impeccable test suite and amazing docs
&#8212; which also remain comprehensive and awesome for an entire lifetime of the library! &#8212;
sound a bit too much like a perfect world :)
Adding examples to the mix can almost always improve things,
and their maintenance burden should, in most cases, be very&nbsp;minimal.</p>
<p>But I have also found out that starting off with examples early on
is a great way to <em>validate the interface design</em>.</p>
<p>Once the friction of creating small test programs has been eliminated,
they become indispensable for prototyping new features.
Wanna try out that new thing you&#8217;ve just added?
Simple: just make a quick example for it, run it, and see what&nbsp;happens!</p>
<p>In many ways, doing this feels similar to trying out things in a
<abbr title="Run Eval Print Loop"><span class="caps">REPL</span></abbr>
&#8212; something that&#8217;s almost exclusive to dynamic/interpreted languages.
But unlike mucking around in Python shell, examples are <em>not</em> throwaway code:
they become part of your project, and remain useful for both you <span class="amp">&amp;</span> your&nbsp;users.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>It is also possible to create examples
<a href="https://doc.rust-lang.org/cargo/reference/manifest.html#examples">which are themselves just libraries</a>.
I don&#8217;t think this is particularly useful, though,
since all you can do with such examples is build them,
so they don&#8217;t provide any additional value over normal tests
(and especially <a href="https://doc.rust-lang.org/beta/rustdoc/documentation-tests.html">doc tests</a>).&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Because they are outside of the <code>src/</code> directory,
examples do not become a part of your library&#8217;s code, and are not deployed to <a href="https://crates.io">crates.io</a>.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>You can also run <code>cargo build --examples</code> to only compile the examples,
without running any kind of tests.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/rust-examples.html#rust-examples">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-unfold-pagination.html#rust-unfold-pagination">Unfolding a Stream of paginated&nbsp;items</a></h2>
    <p>
      Posted on Wed 24 January 2018 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/tokio.html">Tokio</a>,      <a href="http://xion.io/tag/streams.html">streams</a>,      <a href="http://xion.io/tag/http.html">HTTP</a>      &#8226; <a href="http://xion.io/post/code/rust-unfold-pagination.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>My <a href="https://github.com/Xion/ezomyte">most recent Rust crate</a>
is an <span class="caps">API</span> client for <a href="https://www.pathofexile.com/developer/docs/api-resource-public-stash-tabs">the Path of Exile&#8217;s public stash tabs</a>.
One problem that I had to solve while writing it was to turn a sequence of <em>paginated</em> items
(in this case, player stash tabs) into a single, asynchronous <code>Stream</code>.</p>
<p>In this post, I&#8217;ll explain how to use
<a href="https://docs.rs/futures/0.1.17/futures/stream/trait.Stream.html">the <code>Stream</code> interface</a>,
along with functions from <a href="https://docs.rs/futures">the <code>futures</code> crate</a>,
to create a single <code>Stream</code> from multiple batches of&nbsp;entities.</p>
<h4>Pagination&nbsp;101</h4>
<p>To divide a long list of items into <em>pages</em>
is a very common pattern in many <span class="caps">HTTP</span>-based&nbsp;APIs.</p>
<p>If the client requests a sequence of entities
that would be too large to serve as a single response,
there has to be some way to split it over multiple <span class="caps">HTTP</span> roundtrips.
To accomplish that, <span class="caps">API</span> servers will often return a constant number of items at first (like 50),
followed by some form of <em>continuation token</em>:</p>
<div class="highlight"><pre>$ curl http://api.example.com/items
{
    &quot;items&quot;: [
        {...},
        {...},
        {...}
    ],
    &quot;continuationToken&quot;: &quot;e53c68db0ee412ac239173db147a02a0&quot;
}
</pre></div>


<p>Such token is preferably an opaque sequence of bytes,
though sometimes it can be an explicit offset (index) into the list of results<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>.
Regardless of its exact nature, clients need to pass the token with their next request
in order to obtain another batch of&nbsp;results:</p>
<div class="highlight"><pre>$ curl &#39;http://api.example.com/items?after=e53c68db0ee412ac239173db147a02a0&#39;
{
    &quot;items&quot;: [
        {...},
        {...}
    ],
    &quot;continuationToken&quot;: &quot;4e3986e4c7f591b8cb17cf14addd40a6&quot;
}
</pre></div>


<p>Repeat this procedure for as long as the response contains a continuation token,
and you will eventually go through the entire sequence.
If it&#8217;s really, <em>really</em> long (e.g. it&#8217;s a Twitter firehose for a popular hashtag),
then you may of course hit some problems due to the sheer number of requests.
For many datasets, however, this pagination scheme is absolutely sufficient
while remaining relatively simple for clients to&nbsp;implement.</p>
<h4>Stream it in&nbsp;Rust</h4>
<p>What the client code would typically do, however,
is to hide the pagination details completely
and present only the final, unified sequence of items.
Such abstraction is useful even for end-user applications,
but it&#8217;s definitely expected from any shared library that wraps the third-party <span class="caps">API</span>.</p>
<p>Depending on your programming language of choice,
this abstraction layer may be very simple to implement.
Here&#8217;s how it could be done in Python,
whose concepts of <em>iterables</em> and <em>generators</em> are a perfect fit for this task<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">requests</span>

<span class="k">def</span> <span class="nf">iter_items</span><span class="p">(</span><span class="n">after</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Yield items from an example API.</span>
<span class="sd">    :param after: Optional continuation token</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">url</span> <span class="o">=</span> <span class="s">&quot;http://api.example.com/items&quot;</span>
        <span class="k">if</span> <span class="n">after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">url</span> <span class="o">+=</span> <span class="s">&quot;?after=</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">after</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()[</span><span class="s">&#39;items&#39;</span><span class="p">]:</span>
            <span class="k">yield</span> <span class="n">item</span>
        <span class="n">after</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;continuationToken&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">after</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">break</span>

<span class="c"># consumer</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">iter_items</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</pre></div>


<p>In Rust, you can find their analogues in the <code>Iterator</code> and <code>Stream</code> traits,
so we&#8217;re off to a pretty good start.
What&#8217;s missing, however, is the equivalent of <code>yield</code>:
something to tell the consumer &#8220;Here, have the next item!&#8221;,
and then <em>go back</em> to the exact same place in the producer&nbsp;function.</p>
<p>This ability to jump back and forth between two (or more) functions
involves having a language support for <em>coroutines</em>.
Not many mainstream languages pass this requirement,
although Python and C# would readily come to mind.
In case of Rust, there have been some nightly
<a href="https://github.com/rust-lang/rfcs/blob/master/text/2033-experimental-coroutines.md">proposals</a>
and <a href="https://docs.rs/futures-await">experiments</a>,
but nothing seems to be stabilizing anytime&nbsp;soon.</p>
<h4><span class="caps">DIY</span>&nbsp;streaming</h4>
<p>But of course, if you do want a <code>Stream</code> of paginated items,
there is at least one straightforward solution:
just implement the <code>Stream</code> trait&nbsp;directly.</p>
<p>This is actually quite a viable approach, very similar to rolling out a custom <code>Iterator</code>.
Some minor differences stem mostly from a more complicated state management in <code>Stream::poll</code>
compared to <code>Iterator::next</code>.
While an iterator is either exhausted or not,
a stream can also be <a href="https://docs.rs/futures/0.1.17/futures/enum.Async.html">waiting</a>
for the next item to &#8220;arrive&#8221; (<code>Ok(Async::NotReady)</code>),
or have errored out permanently (<code>Err(e)</code>).
As a consequence, the return value of <code>Stream::poll</code> is
<a href="https://docs.rs/futures/0.1.17/futures/type.Poll.html">slightly more complex</a>
than just plain <code>Option</code>, but nevertheless quite&nbsp;manageable.</p>
<p>Irrespective of difficulty,
writing a custom <code>Stream</code> from scratch would inevitably involve a lot of boilerplate.
You may find it necessary in more complicated applications, of course,
but for something that&#8217;s basically a glorified <code>while</code> loop,
it doesn&#8217;t seem like a big ask to have a more concise&nbsp;solution.</p>
<h4>The stream&nbsp;unfolds</h4>
<p>Fortunately there is one!
Its crucial element is the standalone
<a href="https://docs.rs/futures/0.1.17/futures/stream/fn.unfold.html"><code>stream::unfold</code> function</a>
from the <code>futures</code> crate:</p>
<div class="highlight"><pre><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">unfold</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">Fut</span><span class="p">,</span><span class="w"> </span><span class="n">It</span><span class="o">&gt;</span><span class="p">(</span><span class="n">init</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Unfold</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">Fut</span><span class="o">&gt;</span><span class="w"> </span><span class="n">where</span><span class="w"></span>
<span class="w">    </span><span class="n">F</span><span class="o">:</span><span class="w"> </span><span class="n">FnMut</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Fut</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Fut</span><span class="o">:</span><span class="w"> </span><span class="n">IntoFuture</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">It</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
</pre></div>


<p>Reading through the signature of this function can be a little intimidating at first.
Part of it is Rust&#8217;s verbose syntax for anything
that involves both trait bounds and closures<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>,
making <code>stream::unfold</code> seem more complicated than it actually is.
Indeed, if you&#8217;ve ever used <code>Iterator</code> adapters like <code>.filter_map</code> or <code>.fold</code>,
the <code>unfold</code> function will be pretty easy to understand.
(And if you haven&#8217;t, don&#8217;t worry! It&#8217;s really quite simple&nbsp;:))</p>
<p>If you look closely, you&#8217;ll see that <code>stream::unfold</code> takes the following two&nbsp;arguments:</p>
<ul>
<li>first one is essentially an arbitrary initial value, called a <em>seed</em></li>
<li>second one is a <em>closure</em> that receives the seed and returns an optional <em>pair</em> of&nbsp;values</li>
</ul>
<p>What are those values?&#8230;
Well, the entire purpose of the <code>unfold</code> function is to create a <code>Stream</code>,
and a stream should inevitably produce some <em>items</em>.
Consequently, the first value in the returned pair will be the next item in the&nbsp;stream.</p>
<p>And what about the second value? That&#8217;s just the <em>next state</em> of the seed!
It will be received by the very same closure
when someone asks the <code>Stream</code> to produce its next item.
By passing around a useful value &#8212; say, a continuation token &#8212;
you can create something that&#8217;s effectively a <code>while</code> loop from the Python example&nbsp;above.</p>
<p><div class="graphviz" style="text-align: center;"><img src="data:image/png;base64,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xjpKL774YpyUjAorASo0YW05yk0CJEACJJA2ARgJY68xjNJgg1pspOzWk0o7M54QKAJUaALVHBSGBEiABEgg3wRgGAy7mnHjxukWFNgLjxuq5pt6/vOnQpN/xiyBBEiABEgggASwCjz2pqotq3HDDV4WVQyglBTJLwEqNH5JMR0JkAAJkEDREahevbqRleXVrRvbT/To0cN4t+wpugoXcYWo0BRx47JqJEACJEACqQlg7yjsJYW9oLBP1JFHHqn7uKU+kymCRIAKTZBag7KQAAmQAAkUjECHDh3M7NmzdZNjbHaJncwZwkOACk142oqSkgAJkAAJ5JkAdpDHTvNYWV42WTVTpkzJc4nMPlcEqNDkiiTzIQESIAESKAoC2DcKdjXHHXecLsZHY+FwNGuZ2vogHE1CKUmABEiABApNABvFPv300wab18JYeNmyZZGNiwstG8uPT4AKTXwujCUBEiABEijjBLBtwqBBg3RH9J49e5r169ebgQMHlnEqwa0+FZrgtg0lIwESIAESCACBCy+80FSpUsWcc8455vfff9cNLgMgFkWIIRBXoVmyZAl3I40BFeSfc+bMMS1btgyyiCllO/XUUw3ehhjKJoG5c+fq0H5Ya491S2A8yl2c/bXgTz/95C9hgFJ16dLFYBrqjDPOMBs2bDD33Xcf71kBah+IUkKh2WeffUyLFi0CJibFSUYAlviNGzdOliSwx3bZZRfTsWPHwMpHwUqHwIEHHmgaNWpUOoXluJS1a9fqarOFXozts88+M3///bfZc889c1zD3GfXtm1b06BBg9xnnOccO3XqZDbffHNVXNHe2OySL2J5hp5G9ptYCWmkZ1ISIAESIAEPgX79+umS+W+//bapU6eO50jpfsUoLQxYsUcRQ34JvPLKK7qx5fnnn2/uvvvu/BbG3H0ToNu2b1RMSAIkQAIlCdx4443m3XffLagyA6mwCFxYR7lKUg12DNy54QGFaadrrrkm2MKWIelKTDmVobqzqiRAAiSQNYEKFSro5oZZZ5RFBr/88otZsWKFadiwYRa58NR0CJx88sk65QRD4a222sr07ds3ndOZNg8EqNDkASqzJAESIIHSJOCW6OcITWlSN7o+DWyoLr74YlVqunfvXroCsLQoAlRoonDwBwmQAAmEjwAUGqxuu9NOO4VP+JBL3Lt3b7N69WrdpXvnnXc2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"></div></p>
<p>The last important bits about this pair of values is the&nbsp;wrapping.</p>
<p>First, it is actually a <code>Future</code>, allowing your stream to yield objects
that it doesn&#8217;t quite have yet &#8212;
for example, those which ultimately come from an <span class="caps">HTTP</span>&nbsp;response.</p>
<p>Secondly, its outermost layer is an <code>Option</code>.
This enables you to <em>terminate</em> the stream when the underlying source is exhausted
by simply returning <code>None</code>.
Until then, however, you should return <code>Some</code> with the (future of) aforementioned pair of&nbsp;values.</p>
<h4>Paginate!&nbsp;Paginate!</h4>
<p>If you have doubts about how all those pieces of <code>stream::unfold</code> fit in,
then looking at <a href="https://docs.rs/futures/0.1.17/futures/stream/fn.unfold.html#example">the usage example in the docs</a>
may give you <em>some</em> idea of what it enables you to do.
It&#8217;s a very artificial example, though:
the resulting <code>Stream</code> isn&#8217;t waiting for any asynchronous <code>Future</code>s,
which is the very reason you&#8217;d use a <code>Stream</code> over an <code>Iterator</code> in the first place<sup id="fnref:4"><a class="footnote-ref" href="#fn:4" rel="footnote">4</a></sup>.</p>
<p>We can find a more natural application for <code>unfold</code>
if we go back to our original problem.
To reiterate, we want to repeatedly query an <span class="caps">HTTP</span> <span class="caps">API</span> for a long list of items,
giving our callers a <code>Stream</code> of such items they can process at their leisure.
At the same time, all the details about pagination and handling of continuation tokens or offsets
should be completely hidden from the&nbsp;caller.</p>
<p>To employ <code>stream::unfold</code> for this task,
we need two things: the initial seed, and an appropriate&nbsp;closure.</p>
<p>I have hinted already at using the continuation token as our seed,
or the state that we pass around from one closure invocation to another.
What remains is mostly making the actual <span class="caps">HTTP</span> request and interpreting the <span class="caps">JSON</span> response,
for which we&#8217;ll use the <em>defacto</em> standard Rust crates:
<a href="https://docs.rs/hyper"><code>hyper</code></a>, <a href="https://serde.rs">Serde</a>,
and <a href="https://docs.rs/serde_json"><code>serde_json</code></a>:</p>
<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">Error</span><span class="p">;</span><span class="w"></span>

<span class="kn">use</span><span class="w"> </span><span class="n">futures</span><span class="o">::</span><span class="p">{</span><span class="n">future</span><span class="p">,</span><span class="w"> </span><span class="n">Future</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">Stream</span><span class="p">};</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">hyper</span><span class="o">::</span><span class="p">{</span><span class="n">Client</span><span class="p">,</span><span class="w"> </span><span class="n">Method</span><span class="p">};</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">hyper</span><span class="o">::</span><span class="n">client</span><span class="o">::</span><span class="n">Request</span><span class="p">;</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">serde_json</span><span class="p">;</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">tokio_core</span><span class="o">::</span><span class="n">reactor</span><span class="o">::</span><span class="n">Handle</span><span class="p">;</span><span class="w"></span>

<span class="kr">const</span><span class="w"> </span><span class="n">URL</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;http://api.example.com/items&quot;</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">items</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">handle</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Handle</span><span class="p">,</span><span class="w"> </span><span class="n">after</span><span class="o">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Stream</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">=</span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Client</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">stream</span><span class="o">::</span><span class="n">unfold</span><span class="p">(</span><span class="n">after</span><span class="p">,</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">cont_token</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">cont_token</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}?after={}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">URL</span><span class="p">,</span><span class="w"> </span><span class="n">ct</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">req</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Request</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">Method</span><span class="o">::</span><span class="n">Get</span><span class="p">,</span><span class="w"> </span><span class="n">url</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">client</span><span class="p">.</span><span class="n">request</span><span class="p">(</span><span class="n">req</span><span class="p">).</span><span class="n">from_err</span><span class="p">().</span><span class="n">and_then</span><span class="p">(</span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">resp</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">resp</span><span class="p">.</span><span class="n">status</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="n">resp</span><span class="p">.</span><span class="n">body</span><span class="p">().</span><span class="n">concat2</span><span class="p">().</span><span class="n">from_err</span><span class="p">().</span><span class="n">and_then</span><span class="p">(</span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">body</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">status</span><span class="p">.</span><span class="n">is_success</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">serde_json</span><span class="o">::</span><span class="n">from_slice</span><span class="o">::&lt;</span><span class="n">ItemsResponse</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">body</span><span class="p">)</span><span class="w"></span>
<span class="w">                        </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="n">Box</span><span class="o">::&lt;</span><span class="n">Error</span><span class="o">&gt;::</span><span class="n">from</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="nb">Err</span><span class="p">(</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;HTTP status: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">status</span><span class="p">).</span><span class="n">into</span><span class="p">())</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">})</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">items_resp</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="n">stream</span><span class="o">::</span><span class="n">iter_ok</span><span class="p">(</span><span class="n">items_resp</span><span class="p">.</span><span class="n">items</span><span class="p">),</span><span class="w"> </span><span class="n">items_resp</span><span class="p">.</span><span class="n">continuation_token</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">})</span><span class="w"></span>
<span class="w">        </span><span class="p">}))</span><span class="w"></span>
<span class="w">    </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">flatten</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[derive(Deserialize)]</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="n">ItemsResponse</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">items</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[serde(rename = </span><span class="s">&quot;continuationToken&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="n">continuation_token</span><span class="o">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>While <a href="https://play.rust-lang.org/?gist=556ff0d112272b3c2da36c3d03aac52e&amp;version=stable">this code</a>
may be a little challenging to decipher at first,
it&#8217;s not out of line compared to how working with <code>Future</code>s and <code>Stream</code>s looks like in general.
In either case, you can expect a lot of <code>.and_then</code> callbacks&nbsp;:)</p>
<p>There is one detail here that I haven&#8217;t mentioned previously, though.
It relates to the <code>stream::iter_ok</code> and <code>Stream::flatten</code> calls
which you may have already noticed.<br>
The issue with <code>stream::unfold</code> is that it only allows to yield an item <em>once</em> per closure invocation.
For us, this is too limiting: a single batch response from the <span class="caps">API</span> will contain many such items,
but we have no way of &#8220;splitting&#8221;&nbsp;them.</p>
<p>What we can do instead is to produce a <code>Stream</code> of entire <em>batches</em> of items,
at least at first, and then <code>flatten</code> it.
What <code>Stream::flatten</code> does here is to turn a nested <code>Stream&lt;Stream&lt;Item&gt;&gt;</code>
into a flat <code>Stream&lt;Item&gt;</code>. The latter is what we eventually want to return,
so all we need now is to create this nested <em>stream of streams</em>.</p>
<p>How? Well, that&#8217;s actually pretty&nbsp;easy.</p>
<p>We can already deserialize a <code>Vec&lt;Item&gt;</code>
from the <span class="caps">JSON</span> response &#8212; that&#8217;s our item batch! &#8212;
which is essentially an <em>iterable</em> of <code>Item</code>s<sup id="fnref:5"><a class="footnote-ref" href="#fn:5" rel="footnote">5</a></sup>.
Another utility function from the <code>stream</code> module,
namely <a href="https://docs.rs/futures/*/futures/stream/fn.iter_ok.html"><code>stream::iter_ok</code></a>,
can readily turn such iterable into a &#8220;immediate&#8221; <code>Stream</code>.
Such <code>Stream</code> won&#8217;t be asynchronous at all
&#8212; its items will have been ready from the very beginning &#8212;
but it will still conform to the <code>Stream</code> interface,
enabling it to be <code>flatten</code>ed as we&nbsp;request.</p>
<h4>But wait! There is a&nbsp;bug!</h4>
<p>So in the end, is this the solution we&#8217;re looking&nbsp;for?&#8230;</p>
<p>Well, almost. First, here&#8217;s the expected usage of the function we just&nbsp;wrote:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">core</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokio_core</span><span class="o">::</span><span class="n">reactor</span><span class="o">::</span><span class="n">Core</span><span class="o">::</span><span class="n">new</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="n">core</span><span class="p">.</span><span class="n">run</span><span class="p">({</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">continuation_token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span><span class="w">  </span><span class="c1">// start from the beginning</span>
<span class="w">    </span><span class="n">items</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core</span><span class="p">.</span><span class="n">handle</span><span class="p">(),</span><span class="w"> </span><span class="n">continuation_token</span><span class="p">).</span><span class="n">for_each</span><span class="p">(</span><span class="o">|</span><span class="n">item</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="w">    </span><span class="p">})</span><span class="w"></span>
<span class="p">}).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
</pre></div>


<p>While this is more complicated than the plain <code>for</code> loop in Python,
most of it is just Tokio boilerplate.
The notable part is the invocation of <code>items()</code>,
where we pass <code>None</code> as a continuation token to indicate that
we want the entire sequence, right from its&nbsp;beginning.</p>
<p>And since we&#8217;re talking about fetching long sequences,
we would indeed expect a <em>lot</em> of items.
So it is probably quite surprising to hear
that the stream we&#8217;ve created here will be completely <em>empty</em>.</p>
<p>&#8230;What?&nbsp;How?!</p>
<p>If you look again at the source code of <code>items()</code>,
the direct reason should be pretty easy to find.
The culprit lies in the <code>return None</code> branch of the first <code>match</code>.
If we don&#8217;t pass <code>Some(continuation_token)</code> as a parameter to <code>items()</code>,
this branch will be hit <em>immediately</em>,
terminating the stream before it had a chance to produce&nbsp;anything.</p>
<p>It may not be very clear how to fix this problem.
After all, the purpose of the <code>match</code> was to detect the <em>end</em> of the sequence,
but it apparently prevents us from <em>starting</em> it in the first&nbsp;place!</p>
<p>Looking at the problem from another angle,
we can see we&#8217;ve conflated two distinct states of our stream
&#8212; &#8220;before it has started&#8221; and &#8220;after it&#8217;s ended&#8221; &#8212; into a single one (&#8220;no continuation token&#8221;).
Since we obviously don&#8217;t want to make the <code>after</code> parameter mandatory
&#8212; users should be able to say &#8220;Give me everything!&#8221; &#8212;
we need another way of telling those two states&nbsp;apart.</p>
<p>In terms of Rust types, it seems that <code>Option&lt;String&gt;</code> is no longer sufficient
for encoding all possible states of our <code>Stream</code>.
Although we could try to fix that in some ad-hoc way (e.g. by adding another <code>bool</code> flag),
it feels cleaner to just define a new, dedicated type.
For one, this allows us to designate a name for each of the states in question,
improving the readability and maintainability of our&nbsp;code:</p>
<div class="highlight"><pre><span class="k">enum</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Start</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">Next</span><span class="p">(</span><span class="n">String</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">End</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Note that we can put this definition directly inside the <code>items()</code> function,
without cluttering the module namespace.
All the relevant details of our <code>Stream</code> are thus nicely contained
<a href="https://play.rust-lang.org/?gist=42af60531f18509e181c4e30a46eb077&amp;version=stable">within a single function</a>:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">items</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">handle</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Handle</span><span class="p">,</span><span class="w"> </span><span class="n">after</span><span class="o">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Stream</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">=</span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// (definition of State enum can go here)</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Client</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">stream</span><span class="o">::</span><span class="n">unfold</span><span class="p">(</span><span class="n">State</span><span class="o">::</span><span class="n">Start</span><span class="p">(</span><span class="n">after</span><span class="p">),</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">state</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">cont_token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">State</span><span class="o">::</span><span class="n">Start</span><span class="p">(</span><span class="n">opt_ct</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">opt_ct</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">State</span><span class="o">::</span><span class="n">Next</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">ct</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="n">State</span><span class="o">::</span><span class="n">End</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">cont_token</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}?after={}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">URL</span><span class="p">,</span><span class="w"> </span><span class="n">ct</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">URL</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">req</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Request</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">Method</span><span class="o">::</span><span class="n">Get</span><span class="p">,</span><span class="w"> </span><span class="n">url</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">client</span><span class="p">.</span><span class="n">request</span><span class="p">(</span><span class="n">req</span><span class="p">).</span><span class="n">from_err</span><span class="p">().</span><span class="n">and_then</span><span class="p">(</span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">resp</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">resp</span><span class="p">.</span><span class="n">status</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="n">resp</span><span class="p">.</span><span class="n">body</span><span class="p">().</span><span class="n">concat2</span><span class="p">().</span><span class="n">from_err</span><span class="p">().</span><span class="n">and_then</span><span class="p">(</span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">body</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">status</span><span class="p">.</span><span class="n">is_success</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">serde_json</span><span class="o">::</span><span class="n">from_slice</span><span class="o">::&lt;</span><span class="n">ItemsResponse</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">body</span><span class="p">)</span><span class="w"></span>
<span class="w">                        </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="n">Box</span><span class="o">::&lt;</span><span class="n">Error</span><span class="o">&gt;::</span><span class="n">from</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="nb">Err</span><span class="p">(</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;HTTP status: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">status</span><span class="p">).</span><span class="n">into</span><span class="p">())</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">})</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">move</span><span class="w"> </span><span class="o">|</span><span class="n">items_resp</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">next_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">items_resp</span><span class="p">.</span><span class="n">continuation_token</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="nb">Some</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">State</span><span class="o">::</span><span class="n">Next</span><span class="p">(</span><span class="n">ct</span><span class="p">),</span><span class="w"></span>
<span class="w">                    </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">State</span><span class="o">::</span><span class="n">End</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="p">};</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="n">stream</span><span class="o">::</span><span class="n">iter_ok</span><span class="p">(</span><span class="n">items_resp</span><span class="p">.</span><span class="n">items</span><span class="p">),</span><span class="w"> </span><span class="n">next_state</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">})</span><span class="w"></span>
<span class="w">        </span><span class="p">}))</span><span class="w"></span>
<span class="w">    </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">flatten</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Sure, there is a little more bookkeeping required now,
but at least all the items are being emitted by the <code>Stream</code> as&nbsp;intended.</p>
<hr />
<p>You can see the complete source in
<a href="https://play.rust-lang.org/?gist=42af60531f18509e181c4e30a46eb077&amp;version=stable">the playground here</a>.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Furthermore, the token doesn&#8217;t have to come as part of the <span class="caps">HTTP</span> response body.
Some <span class="caps">API</span> providers (such as GitHub) may use the <code>Link:</code> header
to point directly to the next <span class="caps">URL</span> to query.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>This example uses &#8220;traditional&#8221;, synchronous Python code.
However, it should be easy to convert it to the asynchronous equivalent
that works in Python 3.5 and above,
provided you can replace <code>requests</code> with some async <span class="caps">HTTP</span> library.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>If you are curious whether other languages could express it better,
you can check the
<a href="https://hackage.haskell.org/package/conduit-1.2.13/docs/Data-Conduit-List.html#v:unfold"><code>Data.Conduit.List.unfold</code> function</a>
from the Haskell&#8217;s <a href="https://hackage.haskell.org/package/conduit"><code>conduit</code> package</a>.
For most intents and purposes, it is their equivalent of <code>stream::unfold</code>.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>Coincidentally, you can create iterators in the very same manner
through the <a href="https://docs.rs/itertools/0.7.6/itertools/fn.unfold.html"><code>itertools::unfold</code> function</a>
from the <a href="https://docs.rs/itertools/"><code>itertools</code> crate</a>.&#160;<a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:5">
<p>In more technical Rust terms, it means <code>Vec</code> implements the <code>IntoIterator</code> trait,
allowing anyone to get an <code>Iterator</code> from it.&#160;<a class="footnote-backref" href="#fnref:5" rev="footnote" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/rust-unfold-pagination.html#rust-unfold-pagination">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-stream-terminate.html#rust-stream-terminate">Terminating a Stream in&nbsp;Rust</a></h2>
    <p>
      Posted on Sat 16 December 2017 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/streams.html">streams</a>,      <a href="http://xion.io/tag/tokio.html">Tokio</a>,      <a href="http://xion.io/tag/async.html">async</a>      &#8226; <a href="http://xion.io/post/code/rust-stream-terminate.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>Here&#8217;s a little trick that may be useful in dealing with
<a href="https://docs.rs/futures/0.1.17/futures/stream/trait.Stream.html">asynchronous <code>Stream</code>s</a> in&nbsp;Rust.</p>
<p>When you consume a <code>Stream</code> using
<a href="https://docs.rs/futures/0.1.17/futures/stream/trait.Stream.html#method.for_each">the <code>for_each</code> method</a>,
its default behavior is to finish early should an error be produced by the&nbsp;stream:</p>
<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">futures</span><span class="o">::</span><span class="n">prelude</span><span class="o">::*</span><span class="p">;</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">futures</span><span class="o">::</span><span class="n">stream</span><span class="p">;</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">tokio_core</span><span class="o">::</span><span class="n">reactor</span><span class="o">::</span><span class="n">Core</span><span class="p">;</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stream</span><span class="o">::</span><span class="n">iter_result</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="nb">Ok</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="kc">false</span><span class="p">),</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">3</span><span class="p">)]);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">fut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">for_each</span><span class="p">(</span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>
</pre></div>


<p>In more precise terms, it means that
<a href="https://docs.rs/futures/0.1.17/futures/future/trait.Future.html">the <code>Future</code></a>
returned by <code>for_each</code> will resolve with the first error
from the underlying&nbsp;stream:</p>
<div class="highlight"><pre><span class="c1">// Prints 1, 2, and then panics with &quot;false&quot;.</span>
<span class="n">Core</span><span class="o">::</span><span class="n">new</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">run</span><span class="p">(</span><span class="n">fut</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
</pre></div>


<p>For most purposes, this is perfectly alright;
errors are generally meant to propagate, after&nbsp;all.</p>
<p>Certain <em>kinds</em> of errors, however, are better off silenced.
Perhaps they are expected to pop up during normal program operation,
or maybe their occurrence should merely <em>affect</em> program execution in a particular way,
and not halt it outright.
In a simple case like above, you can of course check what <code>for_each</code> itself has returned,
but that doesn&#8217;t scale to building larger <code>Stream</code> pipelines.</p>
<p>I encountered a situation like this myself when using
<a href="https://docs.rs/crate/hubcaps/0.4.2">the <em>hubcaps</em> library</a>.
The code I was writing was meant to
<a href="https://docs.rs/hubcaps/0.4.2/hubcaps/search/struct.SearchIssues.html#method.iter">search for GitHub issues</a>
within a specific repository.
In GitHub <span class="caps">API</span>, this is accomplished by sending a search query like <code>repo:$OWNER/$NAME</code>,
which may result in a rather obscure <span class="caps">HTTP</span> error (<a href="https://httpstatuses.com/422">422 Unprocessable Entity</a>)
if the given repository doesn&#8217;t actually exist.
But I didn&#8217;t care about this error; should it occur, I&#8217;d simply return an empty stream,
because doing so was more convenient for the larger bit of logic that was consuming&nbsp;it.</p>
<p>Unfortunately, the <code>Stream</code> trait offers no interface that&#8217;d target this use case.
There are only a few methods that even allow to look at errors mid-stream,
and even fewer that can end it prematurely.
On the flip side, at least we don&#8217;t have to consider <em>too</em> many combinations
when looking for the solution&nbsp;;)</p>
<p>Indeed, it seems there are only two <code>Stream</code> methods that are worthy of our&nbsp;attention:</p>
<ul>
<li><a href="https://docs.rs/futures/0.1.17/futures/stream/trait.Stream.html#method.then"><code>Stream::then</code></a>,
  because it allows for a closure to receive all stream values (items <em>and</em>&nbsp;errors)</li>
<li><a href="https://docs.rs/futures/0.1.17/futures/stream/trait.Stream.html#method.take_while"><code>Stream::take_while</code></a>,
  because it accepts a closure that can end the stream early (but only based on items, not&nbsp;errors)</li>
</ul>
<p>Combining them both, we arrive at the following&nbsp;recipe:</p>
<ul>
<li>
<p>Inside a <code>.then</code> closure, look for <code>Err</code>ors that you consider non-fatal
  and replace them with a special item value.
  The natural choice for such a value is <code>None</code>.
  As a side effect, this forces us to convert the regular (&#8220;successful&#8221;) <code>item</code>s into <code>Some(item)</code>,
  effectively transforming a <code>Stream&lt;Item=T&gt;</code> into <code>Stream&lt;Item=Option&lt;T&gt;&gt;</code>.</p>
</li>
<li>
<p>Looks for the special value (i.e. <code>None</code>) in the <code>.take_while</code> closure
  and terminate the stream when it&#8217;s been&nbsp;found.</p>
</li>
<li>
<p>Finally, convert the wrapped items back into their original form using <code>.map</code>,
  thus giving us back a <code>Stream</code> of <code>T</code><span class="quo">&#8216;</span>s.</p>
</li>
</ul>
<p>Applying this technique to our initial example,
we get something that looks like&nbsp;this:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stream</span><span class="o">::</span><span class="n">iter_result</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="nb">Ok</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="kc">false</span><span class="p">),</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="o">|</span><span class="n">r</span><span class="o">|</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">r</span><span class="p">)),</span><span class="w">  </span><span class="c1">// no-op passthrough of items</span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span><span class="w"> </span><span class="c1">// non-fatal error, terminate the stream</span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="w">      </span><span class="c1">// no-op passthrough of other errors</span>
<span class="w">    </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">take_while</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">future</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">is_some</span><span class="p">()))</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="nb">Option</span><span class="o">::</span><span class="n">unwrap</span><span class="p">);</span><span class="w"></span>
</pre></div>


<p>If we now try to consume this stream like&nbsp;before:</p>
<div class="highlight"><pre><span class="n">Core</span><span class="o">::</span><span class="n">new</span><span class="p">().</span><span class="n">run</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">for_each</span><span class="p">(</span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
</pre></div>


<p>it will still end after the first two items,
but without producing any errors&nbsp;afterwards.</p>
<hr />
<p>For a more reusable version of the trick, you can check
<a href="https://play.rust-lang.org/?gist=1bf2199460258be6674c9c7a7a157f50&amp;version=stable">this gist</a>;
it adds a <code>Stream::take_while_err</code> method through an <a href="http://xion.io/post/code/rust-extension-traits.html">extension trait</a>.</p>
<p>This isn&#8217;t a perfect solution, however, because it requires <code>Box</code>ing even on nightly Rust<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>.
We can fix that by introducing a dedicated <code>TakeWhileErr</code> stream type,
similarly to what native <code>Stream</code> methods do.
I leave that as an exercise for the reader&nbsp;;-)</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>This is due to a limitation in <a href="https://github.com/rust-lang/rust/issues/34511">the <code>impl Trait</code> feature</a>
which prevents it from being used as a return type of trait methods.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/rust-stream-terminate.html#rust-stream-terminate">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-little-crates.html#rust-little-crates">Small Rust crates I (almost) always&nbsp;use</a></h2>
    <p>
      Posted on Tue 31 October 2017 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/libraries.html">libraries</a>      &#8226; <a href="http://xion.io/post/code/rust-little-crates.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>Alternative clickbait title: <em>My Little Crates: Rust is Magic</em>&nbsp;:-)</p>
<hr />
<p>Due to its relatively scant standard library,
programming in Rust inevitably involves pulling in a good number of third-party&nbsp;dependencies.</p>
<p>Some of them deal with problems that are solved with built-ins
in languages that take a more &#8220;batteries included&#8221; approach.
A good example would be the Python&#8217;s <code>re</code> module,
whose moral equivalent in the Rust ecosystem is <a href="http://docs.rs/regex">the <em>regex</em> crate</a>.</p>
<p>Things like regular expressions, however, represent comparatively large problems.
It isn&#8217;t very surprising that dedicated libraries exist to address them.
It is less common for a language to offer <em>small</em> packages
that target very specialized&nbsp;applications.</p>
<p>As in, one function/type/macro-kind of specialized,
or perhaps only a little larger than&nbsp;that.</p>
<p>In this post, we&#8217;ll take a whirlwind tour through a bunch of such essential&nbsp;&#8220;micropackages&#8221;.</p>
<h4>either</h4>
<p>Rust has the built-in <code>Result</code> type, which is a sum<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup> of an <code>Ok</code> outcome or an <code>Err</code>or.
It forms the basis of a general error handling mechanism in the&nbsp;language.</p>
<p>Structurally, however, <code>Result&lt;T, E&gt;</code> is just an alternative between the types <code>T</code> and <code>E</code>.
You may want to use such an enum for other purposes
than representing results of fallible operations.
Unfortunately, because of the strong inherent meaning of <code>Result</code>,
such usage would be unidiomatic and highly&nbsp;confusing.</p>
<p>This is why the <a href="http://docs.rs/either"><em>either</em> crate</a> exists.
It contains the following <code>Either</code> type:</p>
<div class="highlight"><pre><span class="k">enum</span><span class="w"> </span><span class="n">Either</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Left</span><span class="p">(</span><span class="n">L</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">Right</span><span class="p">(</span><span class="n">R</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>While it is isomorphic to <code>Result</code>,
it carries no connotation to the entrenched error handling practices<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>.
Additionally, it offers symmetric combinator methods such as <code>map_left</code>
or <code>right_and_then</code> for chaining computations involving the <code>Either</code> values.</p>
<h4>lazy_static</h4>
<p>As a design choice, Rust doesn&#8217;t allow for safe access to global mutable variables.
The semi-standard way of introducing those into your code
is therefore <a href="http://docs.rs/lazy_static">the <em>lazy_static</em> crate</a>.</p>
<p>However, the most important usage for it is to declare lazy initialized <em>constants</em>
of more complex&nbsp;types:</p>
<div class="highlight"><pre><span class="n">lazy_static</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">TICK_INTERVAL</span><span class="o">:</span><span class="w"> </span><span class="n">Duration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Duration</span><span class="o">::</span><span class="n">from_secs</span><span class="p">(</span><span class="mi">7</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">24</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">60</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">60</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>The trick isn&#8217;t entirely transparent<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>,
but it&#8217;s the best you can do until we get a proper support
for <a href="https://github.com/rust-lang/rfcs/issues/322">compile-time expressions</a> in the&nbsp;language.</p>
<h4>maplit</h4>
<p>To go nicely with the crate above &#8212;
and to act as a natural syntactic follow-up to
<a href="https://doc.rust-lang.org/1.3.0/std/macro.vec!.html">the standard <code>vec![]</code> macro</a> &#8212;
we&#8217;ve got the <a href="http://docs.rs/maplit"><em>maplit</em> crate</a>.</p>
<p>What it does is add <code>HashMap</code> and <code>HashSet</code> <span class="dquo">&#8220;</span>literals&#8221; by defining
some very simple <code>hashmap!</code> and <code>hashset!</code> macros:</p>
<div class="highlight"><pre><span class="n">lazy_static</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">IMAGE_EXTENSIONS</span><span class="o">:</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;&amp;</span><span class="n">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">ImageFormat</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hashmap</span><span class="o">!</span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;gif&quot;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">ImageFormat</span><span class="o">::</span><span class="n">GIF</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;jpeg&quot;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">ImageFormat</span><span class="o">::</span><span class="n">JPEG</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;jpg&quot;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">ImageFormat</span><span class="o">::</span><span class="n">JPG</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;png&quot;</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">ImageFormat</span><span class="o">::</span><span class="n">PNG</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Internally, <code>hashmap!</code> expands to the appropriate amount of <code>HashMap::insert</code> calls,
returning the finished hash map with all the keys and values&nbsp;given.</p>
<h4>try_opt</h4>
<p>Before the <code>?</code> operator was introduced to Rust,
the idiomatic way of propagating erroneous <code>Result</code>s was the <code>try!</code> macro.</p>
<p>A similar macro can also be implemented for <code>Option</code> types
so that it propagates the <code>None</code>s upstream.
The <a href="http://docs.rs/try_opt"><em>try_opt</em> crate</a> is doing precisely that,
and the macro can be used in a straightforward&nbsp;manner:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">parse_ipv4</span><span class="p">(</span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">lazy_static</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">RE</span><span class="o">:</span><span class="w"> </span><span class="n">Regex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Regex</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="s-Raw">r&quot;^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$&quot;</span><span class="w"></span>
<span class="w">        </span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">caps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_opt</span><span class="o">!</span><span class="p">(</span><span class="n">RE</span><span class="p">.</span><span class="n">captures</span><span class="p">(</span><span class="n">s</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_opt</span><span class="o">!</span><span class="p">(</span><span class="n">caps</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="n">as_str</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_opt</span><span class="o">!</span><span class="p">(</span><span class="n">caps</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">)).</span><span class="n">as_str</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_opt</span><span class="o">!</span><span class="p">(</span><span class="n">caps</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">3</span><span class="p">)).</span><span class="n">as_str</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_opt</span><span class="o">!</span><span class="p">(</span><span class="n">caps</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">4</span><span class="p">)).</span><span class="n">as_str</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="nb">Some</span><span class="p">((</span><span class="w"></span>
<span class="w">        </span><span class="n">try_opt</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">ok</span><span class="p">()),</span><span class="w"></span>
<span class="w">        </span><span class="n">try_opt</span><span class="o">!</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">ok</span><span class="p">()),</span><span class="w"></span>
<span class="w">        </span><span class="n">try_opt</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">ok</span><span class="p">()),</span><span class="w"></span>
<span class="w">        </span><span class="n">try_opt</span><span class="o">!</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">ok</span><span class="p">()),</span><span class="w"></span>
<span class="w">    </span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Until Rust supports <code>?</code> for <code>Option</code>s (which is <a href="https://github.com/rust-lang/rust/issues/31436">planned</a>),
this <code>try_opt!</code> macro can serve as an acceptable&nbsp;workaround.</p>
<h4>exitcode</h4>
<p>It is a common convention in basically every mainstream <span class="caps">OS</span>
that a process has finished with an error
if it exits with a code different than 0 (zero),
Linux divides the space of error codes <a href="http://www.tldp.org/LDP/abs/html/exitcodes.html">further</a>,
and &#8212; along with <span class="caps">BSD</span> &#8212; it also includes the <em>sysexits.h</em> header with some more specialized&nbsp;codes.</p>
<p>These have been adopted by great many programs
and <a href="https://docs.python.org/3.0/library/os.html#os.EX_OK">languages</a>.
In Rust, those semi-standard names for common errors can be used, too.
All you need to do is add <a href="http://docs.rs/exitcode">the <em>exitcode</em> crate</a> to your&nbsp;project:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">args</span><span class="o">::</span><span class="n">parse</span><span class="p">().</span><span class="n">unwrap_or_else</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">print_args_error</span><span class="p">(</span><span class="n">e</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">process</span><span class="o">::</span><span class="n">exit</span><span class="p">(</span><span class="n">exitcode</span><span class="o">::</span><span class="n">USAGE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">});</span><span class="w"></span>
</pre></div>


<p>In addition to constants like <code>USAGE</code> or <code>TEMPFAIL</code>,
the <em>exitcode</em> crate also defines an <code>ExitCode</code> alias
for the integer type holding the exit codes.
You can use it, among other things, as a return type of your top-level&nbsp;functions:</p>
<div class="highlight"><pre><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">do_stuff</span><span class="p">(</span><span class="n">options</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">process</span><span class="o">::</span><span class="n">exit</span><span class="p">(</span><span class="n">code</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">do_stuff</span><span class="p">(</span><span class="n">options</span><span class="o">:</span><span class="w"> </span><span class="n">Options</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">exitcode</span><span class="o">::</span><span class="n">ExitCode</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<h4>enum-set</h4>
<p>In Java, there is a specialization of the general <code>Set</code> interface
that works for enum types:
<a href="https://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html">the <code>EnumSet</code> class</a>.
Its members are represented very compactly as <em>bits</em> rather than hashed&nbsp;elements.</p>
<p>A similar (albeit slightly less powerful<sup id="fnref:4"><a class="footnote-ref" href="#fn:4" rel="footnote">4</a></sup>) structure has been implemented
in the <a href="http://docs.rs/enum-set"><em>enum-set</em> crate</a>. Given a <code>#[repr(u32)]</code> enum&nbsp;type:</p>
<div class="highlight"><pre><span class="cp">#[repr(u32)]</span><span class="w"></span>
<span class="cp">#[derive(Clone, Copy, Debug Eq, Hash, PartialEq)]</span><span class="w"></span>
<span class="k">enum</span><span class="w"> </span><span class="n">Weekday</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Monday</span><span class="p">,</span><span class="w"> </span><span class="n">Tuesday</span><span class="p">,</span><span class="w"> </span><span class="n">Wednesday</span><span class="p">,</span><span class="w"> </span><span class="n">Thursday</span><span class="p">,</span><span class="w"> </span><span class="n">Friday</span><span class="p">,</span><span class="w"> </span><span class="n">Saturday</span><span class="p">,</span><span class="w"> </span><span class="n">Sunday</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>you can create an <code>EnumSet</code> of its&nbsp;variants:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">weekend</span><span class="o">:</span><span class="w"> </span><span class="n">EnumSet</span><span class="o">&lt;</span><span class="n">Weekday</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EnumSet</span><span class="o">::</span><span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="n">weekend</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Weekday</span><span class="o">::</span><span class="n">Saturday</span><span class="p">);</span><span class="w"></span>
<span class="n">weekend</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Weekday</span><span class="o">::</span><span class="n">Sunday</span><span class="p">);</span><span class="w"></span>
</pre></div>


<p>as long as you provide a simple trait impl that specifies
how to convert those enum values to and from <code>u32</code>:</p>
<div class="highlight"><pre><span class="k">impl</span><span class="w"> </span><span class="n">enum_set</span><span class="o">::</span><span class="n">CLike</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Weekday</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">to_u32</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">u32</span><span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">from_u32</span><span class="p">(</span><span class="n">v</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">mem</span><span class="o">::</span><span class="n">transmute</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>The advantage is having a set structure represented by a single, unsigned 32-bit integer,
leading to <em>O</em>(1) complexity of <em>all</em> common set operations.
This includes membership checks, the union of two sets, their intersection, difference, and so&nbsp;on.</p>
<h4>antidote</h4>
<p>As part of fulfilling the promise of Fearless Concurrency,
Rust offers multiple synchronization primitives
that are all defined in <a href="https://doc.rust-lang.org/std/sync/">the <code>std::sync</code> module</a>.
One thing that <code>Mutex</code>, <code>RwLock</code>, and similar mechanisms there have in common
is that their locks can become &#8220;poisoned&#8221; if a thread panicks while holding them.
As a result, acquiring a lock requires handling the potential <code>PoisonError</code>.</p>
<p>For many programs, however, lock poisoning is not even a remote,
but a straight-up <em>impossible</em> situation.
If you follow the best practices of concurrent resource sharing,
you won&#8217;t be holding locks for more than a few instructions,
devoid of <code>unwrap</code>s or any other opportunity to <code>panic!()</code>.
Unfortunately, you cannot prove this to the Rust compiler statically,
so it will still require you to handle a <code>PoisonError</code> that cannot&nbsp;happen.</p>
<p>This is where the aptly named <a href="http://docs.rs/antidote"><em>antidote</em> crate</a> crate offers help.
In it, you can find all the same locks <span class="amp">&amp;</span> guards <span class="caps">API</span> that is offered by <code>std::sync</code>,
just without the <code>PoisonError</code>.
In many cases, this removal has radically simplified the interface,
for example by turning <code>Result&lt;Guard, Error&gt;</code> return types into just <code>Guard</code>.</p>
<p>The caveat, of course, is that you need to ensure all threads holding these &#8220;immunized&#8221; locks&nbsp;either:</p>
<ul>
<li>don&#8217;t panic at all;&nbsp;or</li>
<li>don&#8217;t leave guarded resources in an inconsistent state if they <em>do</em>&nbsp;panic</li>
</ul>
<p>Like it&#8217;s been mentioned earlier,
the best way to make that happen is to keep lock-guarded critical sections minimal and&nbsp;infallible.</p>
<h4>matches</h4>
<p>Pattern matching is one of the most important features of Rust,
but some of the relevant language constructs have awkward shortcomings.
The <code>if let</code> conditional, for example, cannot be combined with boolean&nbsp;tests:</p>
<div class="highlight"><pre><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">is_good</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</pre></div>


<p>and thus requires additional nesting, or a different approach&nbsp;altogether.</p>
<p>Thankfully, to help with situations like this,
there is the <a href="http://docs.rs/matches"><em>matches</em> crate</a> with a bunch of convenient macros.
Besides <a href="https://docs.rs/matches/0.1.6/matches/macro.matches.html">its namesake, <code>matches!</code></a>:</p>
<div class="highlight"><pre><span class="k">if</span><span class="w"> </span><span class="n">matches</span><span class="o">!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="n">_</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">is_good</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</pre></div>


<p>it also exposes assertion macros
(<a href="https://docs.rs/matches/0.1.6/matches/macro.assert_matches.html"><code>assert_match!</code></a>
and <a href="https://docs.rs/matches/0.1.6/matches/macro.debug_assert_matches.html"><code>debug_assert_match!</code></a>)
that can be used in both production and test&nbsp;code.</p>
<hr />
<p>This concludes the overview of small Rust crates, at least for&nbsp;now.</p>
<p>To be certain, these crates are by far not the only ones that are small in size
and simultaneously almost indispensable.
Many more great libraries can be found
e.g. in the <a href="https://github.com/rust-unofficial/awesome-rust#libraries">Awesome Rust registry</a>,
though obviously you could argue if all of them are truly &#8220;micro&#8221;&nbsp;;-)</p>
<p>If you know more crates in the similar vein,
make sure to mention them in the&nbsp;comments!</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>A <em>sum type</em> consists of several alternatives,
out of which only one has been picked for a particular instance.
The other common name for it is a <em>tagged union</em>.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Unless you come from Haskell, that is, where <code>Either</code> is the equivalent of Rust&#8217;s <code>Result</code> :)&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>You will occasionally need an explicit <code>*</code> to trigger the <code>Deref</code> coercion it uses.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>It only supports unitary enums of up to 32 variants.&#160;<a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/rust-little-crates.html#rust-little-crates">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/haskell-printer-monad.html#haskell-printer-monad">The Printer Monad in&nbsp;Haskell</a></h2>
    <p>
      Posted on Fri 04 August 2017 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/haskell.html">Haskell</a>,      <a href="http://xion.io/tag/writer.html">Writer</a>,      <a href="http://xion.io/tag/monads.html">monads</a>,      <a href="http://xion.io/tag/monad-transformers.html">monad transformers</a>,      <a href="http://xion.io/tag/writert.html">WriterT</a>      &#8226; <a href="http://xion.io/post/code/haskell-printer-monad.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>Quite recently, I have encountered an interesting case of monad-based refactoring in&nbsp;Haskell.</p>
<p>Suppose you have a <code>ComplicatedRecord</code>
that holds the results of some lengthy and important process in your program.
You want to present that data to the user in a nicely formatted way,
so you write a function which begins somewhat like&nbsp;this:</p>
<div class="highlight"><pre><span class="cm">{-# LANGUAGE RecordWildcards #-}</span>

<span class="c1">-- | Pretty-print the content of the record.</span>
<span class="nf">ppRecord</span> <span class="ow">::</span> <span class="kt">ComplicatedRecord</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">ppRecord</span> <span class="kt">ComplicatedRecord</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="c1">-- ...</span>
</pre></div>


<p>Inside, there is plenty of <code>putStrLn</code> calls, likely hidden inside more specific subfunctions
that format all the numerous parts of <code>ComplicatedRecord</code>.
But the <code>IO</code> monad isn&#8217;t there just for printing:
because the code went through multiple iterations,
some of this logic actually takes advantage of it by making additional system <span class="amp">&amp;</span> network&nbsp;calls.</p>
<p>So yeah, it&#8217;s not particularly&nbsp;pretty.</p>
<p>Now, however, we find out that the output we&#8217;re printing here
shouldn&#8217;t <em>always</em> go directly to stdout.
In some cases, unsurprisingly, we actually want it back as a single string,
without having it sent to the standard output at&nbsp;all.</p>
<h4>Just $ return .&nbsp;it</h4>
<p>Your first instinct here may be to simply give back the final string (well, <code>Text</code>)
as the function result<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>:</p>
<div class="highlight"><pre><span class="nf">ppRecord</span> <span class="ow">::</span> <span class="kt">ComplicatedRecord</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Text</span>
</pre></div>


<p>However, this turns out to be rather awkward.
While in most other languages
we would simply accumulate output by progressively adding more data to a mutable result,
this would be much more inconvenient (and somewhat weird) to do in&nbsp;Haskell.</p>
<p>This is where the stdout-based approach seems cleaner;
instead of straightforward, sequential code like&nbsp;this:</p>
<div class="highlight"><pre><span class="cm">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kr">import</span> <span class="nn">Control.Monad.Extra</span> <span class="p">(</span><span class="nf">whenJust</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Text.IO</span>
<span class="kr">import</span> <span class="nn">TextShow</span>

<span class="nf">ppOrder</span> <span class="kt">Order</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;Order #&quot;</span> <span class="o">&lt;&gt;</span> <span class="n">ordNumber</span>
    <span class="n">ppAddress</span> <span class="n">ordDeliveryAddress</span>
    <span class="n">forM_</span> <span class="p">(</span><span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="n">ordItems</span><span class="p">)</span> <span class="o">$</span> <span class="nf">\</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="kt">Item</span><span class="p">{</span><span class="o">..</span><span class="p">})</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">showt</span> <span class="p">(</span><span class="n">i</span><span class="ow">::</span><span class="kt">Int</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="s">&quot;. &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">itName</span> <span class="o">&lt;&gt;</span> <span class="s">&quot; x&quot;</span> <span class="o">&lt;&gt;</span> <span class="n">showt</span> <span class="n">itQuantity</span>
    <span class="n">whenJust</span> <span class="n">ordBillingAddress</span> <span class="n">ppAddress</span>

<span class="nf">ppAddress</span> <span class="kt">Address</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">addrFirstName</span> <span class="o">&lt;&gt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">addrLastName</span>
    <span class="n">putStrLn</span> <span class="n">addrLine1</span>
    <span class="n">whenJust</span> <span class="n">addrLine2</span> <span class="n">putStrLn</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">addrCity</span> <span class="o">&lt;&gt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">addrPostalCode</span>
</pre></div>


<p>we have to overhaul each function and turn it into a much less pleasant &#8220;<code>mappend</code>age&#8221;:</p>
<div class="highlight"><pre><span class="nf">ppOrder</span> <span class="kt">Order</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="n">unlines</span> <span class="o">$</span> <span class="n">mconcat</span>
    <span class="p">[</span> <span class="s">&quot;Order #&quot;</span> <span class="o">&lt;&gt;</span> <span class="n">ordNumber</span>
    <span class="p">,</span> <span class="n">ppAddress</span> <span class="n">ordDeliveryAddress</span>
    <span class="p">,</span> <span class="n">ppItems</span> <span class="n">ordItems</span>
    <span class="p">]</span> <span class="o">+</span> <span class="n">maybe</span> <span class="kt">[]</span> <span class="p">(</span><span class="nf">\</span><span class="n">addr</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">ppAddress</span> <span class="n">addr</span><span class="p">])</span> <span class="n">ordBillingAddress</span>
    <span class="kr">where</span>
    <span class="n">ppItems</span> <span class="ow">=</span> <span class="n">mconcat</span> <span class="o">.</span> <span class="n">map</span> <span class="p">(</span><span class="n">uncurry</span> <span class="n">ppItem</span><span class="p">)</span> <span class="o">.</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
    <span class="n">ppItem</span> <span class="n">i</span> <span class="kt">Item</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="n">showt</span> <span class="n">i</span> <span class="o">&lt;&gt;</span> <span class="s">&quot;. &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">itName</span> <span class="o">&lt;&gt;</span> <span class="s">&quot; x&quot;</span> <span class="o">&lt;&gt;</span> <span class="n">itQuantity</span>
</pre></div>


<p>One may argue that this is, in fact, the more idiomatic approach,
but I&#8217;m not very fond of all those commas.
Plus, it shows rather clearly that any conditional logic (like with <code>ordBillingAddress</code> here)
is going to get pretty&nbsp;cumbersome.</p>
<h4>Along comes the <code>Writer</code></h4>
<p>What I&#8217;m saying here is that even in pure code,
it is sometimes very desirable to have a <code>do</code> notation.
For that, however, we need a suitable <code>Monad</code><sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup> to provide the meaning of &#8220;invisible semicolon&#8221; in a <code>do</code> block.</p>
<p>And <code>Text</code>, obviously, isn&#8217;t one.
Neither is <code>[Text]</code> (lines of text),
nor any other type we&#8217;d use to represent the final output of formatting <span class="amp">&amp;</span> printing.
They are unsuitable, because they cannot encode the <em>computation</em> that eventually produces said output &#8212;
either the top-level one (<code>ppRecord</code>) or any of its building blocks (like the <code>ppOrder</code> or <code>ppAddress</code>),
down to a most elementary <code>putStrLn</code>.
The only thing they can stand for is the result&nbsp;itself.</p>
<p>Fortunately, the pattern of executing code and occassionally producing some &#8220;additional&#8221; output
has been abstracted over in the Haskell standard library.
This is exactly the use case for the <code>Writer</code> monad!</p>
<p>The definition of <code>Writer</code> is roughly equivalent to the&nbsp;following:</p>
<div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">Writer</span> <span class="n">w</span> <span class="n">a</span> <span class="ow">=</span> <span class="o">...</span> <span class="c1">-- omitted</span>
</pre></div>


<p>Of the two type parameters it takes, the <code>w</code> one signifies what output it can produce &#8220;on the side&#8221;.
This is contrasted with <code>a</code> which is the regular result of a monadic expression or function.
In our case, <code>a</code> will basically always be <code>()</code> (unit/&#8221;empty&#8221; type),
but it is nonetheless necessary for the <code>Writer</code> to behave as a&nbsp;monad.</p>
<p>To complement the above definition, <code>Writer</code> comes with several useful functions.
Among those, the most interesting one is <code>tell</code>:</p>
<div class="highlight"><pre><span class="nf">tell</span> <span class="ow">::</span> <span class="n">w</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="n">w</span> <span class="nb">()</span>
</pre></div>


<p><code>write</code> would&#8217;ve probably been a better name for it,
as it&#8217;s definitely the main and defining operation of <code>Writer</code>.</p>
<p>Looking at its signature, we can see it takes a bit of the <code>Writer</code><span class="quo">&#8216;</span>s output (<code>w</code>)
and results in a <code>Writer</code> action.
Internally, it will simply add the argument to the already accumulated output of the writer<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>.</p>
<p>To make everything more concrete,
here&#8217;s a literal &#8220;Hello world&#8221; example coded very verbosly as a <code>Writer</code> action:</p>
<div class="highlight"><pre><span class="kr">import</span> <span class="nn">Control.Monad.Writer</span>

<span class="nf">hello</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">hello</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">tell</span> <span class="s">&quot;Hello&quot;</span>
    <span class="n">tell</span> <span class="s">&quot; &quot;</span>
    <span class="n">tell</span> <span class="s">&quot;world&quot;</span>

<span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="n">greeting</span><span class="p">)</span> <span class="ow">=</span> <span class="n">runWriter</span> <span class="n">hello</span>
    <span class="kt">Text</span><span class="o">.</span><span class="n">putStrLn</span> <span class="n">greeting</span>
</pre></div>


<p>It also contains the last element of the <code>Writer</code> puzzle:</p>
<div class="highlight"><pre><span class="nf">runWriter</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="n">w</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>


<p>Like its name suggests, this function will &#8220;run&#8221; any <code>Writer</code> action that we give it,
returning both the &#8220;regular&#8221; result (<code>a</code>) plus any output passed in <code>tell</code>s (<code>w</code>).<sup id="fnref:4"><a class="footnote-ref" href="#fn:4" rel="footnote">4</a></sup></p>
<h4>My little monad: transformers are&nbsp;magic</h4>
<p>The last example may be very simple,
but it contains all the building blocks for many of the printing functions we need.
If we define a convenience wrapper for <code>tell</code>:</p>
<div class="highlight"><pre><span class="nf">putLn</span> <span class="ow">::</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">putLn</span> <span class="n">line</span> <span class="ow">=</span> <span class="n">tell</span> <span class="o">$</span> <span class="n">line</span> <span class="o">&lt;&gt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
</pre></div>


<p>then both <code>ppAddress</code> and <code>ppOrder</code> can be translated
through a mere mechanical substitution of <code>putStrLn</code> with <code>putLn</code>:</p>
<div class="highlight"><pre><span class="nf">ppAddress</span> <span class="kt">Address</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">putLn</span> <span class="o">$</span> <span class="n">addrFirstName</span> <span class="o">&lt;&gt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">addrLastName</span>
    <span class="n">putLn</span> <span class="n">addrLine1</span>
    <span class="n">whenJust</span> <span class="n">addrLine2</span> <span class="n">putLn</span>
    <span class="n">putLn</span> <span class="o">$</span> <span class="n">addrCity</span> <span class="o">&lt;&gt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">addrPostalCode</span>

<span class="c1">-- ppOrder omitted</span>
</pre></div>


<p>Unfortunately, a bare <code>Writer</code> like this can only work for pure code,
which isn&#8217;t a luxury we can expect in every situtation.
In my case, some of the printing logic was tied pretty strongly to <code>IO</code>,
and it would be difficult and time consuming to decouple&nbsp;it.</p>
<p>Thankfully, the reliance on <code>IO</code> isn&#8217;t a complete deal breaker.
While we cannot ensure that nothing calls <code>putStrLn</code> anymore,
we can provide the <code>tell</code>/<code>putLn</code> capabilities alongside whatever <em>other</em> <code>IO</code> calls
our code has to make (for&nbsp;now).</p>
<p>To achieve that, we need to create a <em>monad stack</em> with <code>WriterT</code>:</p>
<div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">WriterT</span> <span class="n">w</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">=</span> <span class="o">...</span> <span class="c1">-- omitted</span>
</pre></div>


<p><code>WriterT</code> is a <em>monad transformer</em>, one of those scary Haskell concepts
that are actually simpler than they appear on the surface.
This is because transfomers like <code>WriterT</code> are mere wrappers.
The only difference between it and a regular <code>Writer</code> is the additional <code>m</code> parameter,
which is the <em>inner monad</em> we&#8217;re packaging inside a new <code>Writer</code>.</p>
<p>Here (and in many other cases), <code>m</code> will be substituted with <code>IO</code>:</p>
<div class="highlight"><pre><span class="kr">type</span> <span class="kt">Printer</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">WriterT</span> <span class="kt">Text</span> <span class="kt">IO</span> <span class="n">a</span>  <span class="c1">-- w == Text, m == IO</span>
</pre></div>


<p>thus creating the titular <code>Printer</code> monad.
This hybrid beast can both output <code>Text</code> through the <code>Writer</code> <span class="caps">API</span>,
as well as perform any additional <code>IO</code> operations
that the code may (still)&nbsp;require.</p>
<p>Below is an example;
the <code>User</code> record requires an I/O call to get the size of its <code>$HOME</code> directory:</p>
<div class="highlight"><pre><span class="kr">import</span> <span class="nn">Control.Monad.IO.Class</span> <span class="p">(</span><span class="nf">liftIO</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">System.Directory</span> <span class="p">(</span><span class="nf">getFileSize</span><span class="p">)</span>

<span class="c1">-- To print this data type nicely, we sadly require I/O :(</span>
<span class="kr">data</span> <span class="kt">User</span> <span class="ow">=</span> <span class="kt">User</span> <span class="p">{</span> <span class="n">usrName</span> <span class="ow">::</span> <span class="kt">Text</span>
                 <span class="p">,</span> <span class="n">usrHomeDir</span> <span class="ow">::</span> <span class="kt">FilePath</span>
                 <span class="p">}</span>

<span class="nf">ppUser</span> <span class="ow">::</span> <span class="kt">User</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Text</span>
<span class="nf">ppUser</span> <span class="kt">User</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="n">snd</span> <span class="o">&lt;$&gt;</span> <span class="n">runWriterT</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">putLn</span> <span class="o">$</span> <span class="s">&quot;Name: &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">usrName</span>
    <span class="n">homeSize</span> <span class="ow">&lt;-</span> <span class="n">liftIO</span> <span class="o">$</span> <span class="n">getFileSize</span> <span class="n">usrHomeDir</span>
    <span class="n">putLn</span> <span class="o">$</span> <span class="s">&quot;$HOME: &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">showt</span> <span class="n">usrHomeDir</span> <span class="o">&lt;&gt;</span> <span class="s">&quot;(&quot;</span> <span class="o">&lt;&gt;</span> <span class="n">showt</span> <span class="n">homeSize</span> <span class="o">&lt;&gt;</span> <span class="s">&quot; bytes)&quot;</span>
</pre></div>


<p>As a bit of necessary cruft,
we have to use <code>liftIO</code> to &#8220;lift&#8221; (wrap) <code>IO</code> actions such as <code>getFileSize</code>
in a full <code>Printer</code> monad before executing them.
Besides everything else you can think of,
this is yet another argument for eventually getting rid of the <code>IO</code> :)</p>
<h4>Making the monads&nbsp;coexist</h4>
<p>But our job isn&#8217;t done yet.
Despite looking very reasonable, this version of <code>ppUser</code> doesn&#8217;t actually compile!
The actual type error may vary a little,
but it all boils down to a difference between <code>WriterT Text IO ()</code> (i.e. <code>Printer ()</code>)
and <code>Writer Text ()</code> at each call site of <code>putLn</code>.</p>
<p><span class="caps">GHC</span> is obviously correct.
However, the problem lies not in how we&#8217;re calling <code>putLn</code>,
but rather the way it&#8217;s been&nbsp;defined:</p>
<div class="highlight"><pre><span class="nf">putLn</span> <span class="ow">::</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Text</span> <span class="nb">()</span>
</pre></div>


<p>This type can only produce a specific, <em>pure</em> <code>Writer</code> action.
But to fit inside the <code>do</code> block of our compound monad,
we need the <code>Writer</code> + <code>IO</code> combo from <code>WriterT Text IO</code> (i.e. <code>Printer</code>).</p>
<p>We can try to address the mismatch by changing the signature&nbsp;to:</p>
<div class="highlight"><pre><span class="nf">putLn</span> <span class="ow">::</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">WriterT</span> <span class="kt">Text</span> <span class="kt">IO</span> <span class="nb">()</span>  <span class="c1">-- or just: Printer ()</span>
</pre></div>


<p>but this will only result in the <em>opposite</em> problem.
Now, all the pure printers like <code>ppAddress</code> are facing the fact
that <code>putLn</code> is a (wrapped) <code>IO</code> action, despite not actually doing any I/O&nbsp;whatsoever.</p>
<p>The obvious question is, can we have something that fits <em>both</em>?</p>
<p>Earlier on, I&#8217;ve said that both vanilla <code>Writer</code> and the <code>IO</code>-spruced <code>Printer</code> support the &#8220;<code>Writer</code> <span class="caps">API</span>&#8221;,
most notably the <code>tell</code> function.
This notion of a &#8220;monadic interface&#8221; isn&#8217;t just hand-waving, though,
and Haskell (obviously!) provides a way to express it&nbsp;programmatically.</p>
<p>Meet the <code>MonadWriter</code> typeclass:</p>
<div class="highlight"><pre><span class="kr">class</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">w</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MonadWriter</span> <span class="n">w</span> <span class="n">m</span>
</pre></div>


<p>Any monad that can work as a <code>Writer</code> will be an instance of it,
regardless of whether it wraps over <code>IO</code> or anything else.
Functions like <code>tell</code> are defined to be
<a href="http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Writer-Class.html#v:tell">polymorphic over it</a>,
enabling us to leverage the same technique they use when we define <code>putLn</code>:</p>
<div class="highlight"><pre><span class="cm">{-# LANGUAGE FlexibleContexts #-}</span>

<span class="kr">import</span> <span class="nn">Control.Monad.Writer.Class</span>

<span class="nf">putLn</span> <span class="ow">::</span> <span class="kt">MonadWriter</span> <span class="kt">Text</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>
<span class="nf">putLn</span> <span class="n">line</span> <span class="ow">=</span> <span class="n">tell</span> <span class="o">$</span> <span class="n">line</span> <span class="o">&lt;&gt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
</pre></div>


<p>If you aren&#8217;t very familiar with this syntax,
the part before <code>=&gt;</code> is a <em>typeclass constraint</em>, or <em>context</em>.
It defines the requirements to be satisfied by types
which are later used in the function&nbsp;signature.</p>
<p>Here, we request a <code>MonadWriter</code> instance &#8212; one where <code>Text</code> is the output
but <em>anything</em> can be the inner monad.
We refer to that unknown monad only as <code>m</code>, a type variable.
The compiler will figure out what to substitute for it <em>at every call site</em> of <code>putLn</code>.</p>
<p>As a result, both a pure <code>Writer</code> and the <code>IO</code>-bound <code>Printer</code> can now use it.
In the second case, the relevant instance of <code>MonadWriter</code> will,
naturally, have <code>IO</code> fill in the <code>m</code> position.</p>
<p>But curiously, the &#8220;pure&#8221; <code>Writer</code> also has
<a href="http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Functor-Identity.html#t:Identity">an inner monad</a>.
It just literally <em>does nothing</em> but wrap some other&nbsp;value:</p>
<div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">Identity</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Identity</span> <span class="p">{</span> <span class="n">runIdentity</span> <span class="ow">::</span> <span class="n">a</span> <span class="p">}</span>
</pre></div>


<p>In most cases, this fact is hidden behind
<a href="http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Writer-Lazy.html#t:Writer">the real definition of <code>Writer</code></a>,
though <code>runIdentity</code> may sometimes come handy for some on-the-spot type hacks<sup id="fnref:5"><a class="footnote-ref" href="#fn:5" rel="footnote">5</a></sup>.</p>
<h4>The&nbsp;wrap</h4>
<p>The many things we&#8217;ve talked about here could of course be a starting point
for even more advanced stuff, but obviously we have to stop somewhere!
But don&#8217;t worry: knowing about <code>MonadWriter</code> and other monad typeclasses like this
is enough to write quite idiomatic&nbsp;code&#8230;</p>
<p>&#8230;at least until you learn about
<a href="http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html">free monads</a>,
<a href="https://ocharles.org.uk/blog/posts/2013-12-04-24-days-of-hackage-extensible-effects.html">effects</a>,
and the like&nbsp;;-)</p>
<p>In any case, you can check <a href="https://gist.github.com/Xion/74c39b65c591ae9615b7cf81e88a5946">this gist</a>
for the complete code from this&nbsp;post.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p><code>IO</code> is still necessary due to ad-hoc network fetches and syscalls mentioned earlier.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Or at least an <code>Applicative</code>, via the <code>ApplicativeDo</code> <span class="caps">GHC</span> extension.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>The adding is done via <code>mappend</code>, requiring <code>w</code> to be a <code>Monoid</code>.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>There is also the <code>execWriter</code> variant which is actually more practical here
  as it only returns the accumulated output.&#160;<a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:5">
<p>We could, for example, use it alongside <code>mapWriterT</code> to &#8220;fix&#8221; the calls to <code>putLn</code>
  if we didn&#8217;t have control over its definition.&#160;<a class="footnote-backref" href="#fnref:5" rev="footnote" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/haskell-printer-monad.html#haskell-printer-monad">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-extension-traits.html#rust-extension-traits">Extension traits in&nbsp;Rust</a></h2>
    <p>
      Posted on Tue 20 June 2017 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/c.html">C#</a>,      <a href="http://xion.io/tag/methods.html">methods</a>,      <a href="http://xion.io/tag/extension-methods.html">extension methods</a>,      <a href="http://xion.io/tag/traits.html">traits</a>      &#8226; <a href="http://xion.io/post/code/rust-extension-traits.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>In a few object-oriented languages,
it is possible to add methods to a class <em>after</em> it&#8217;s already been&nbsp;defined.</p>
<p>This feature arises quite naturally if the language has a dynamic type system
that&#8217;s modifiable at runtime.
In those cases, even <em>replacing</em> existing methods is perfectly possible<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>.</p>
<p>In addition to that,
some statically typed languages &#8212; most notably in C# &#8212;
offer <em>extension methods</em> as a <a href="cs-ext-methods">dedicated feature</a> of their type systems.
The premise is that you would write standalone functions whose
first argument is specially designated (usually by <code>this</code> keyword)
as a receiver of the resulting method&nbsp;call:</p>
<div class="highlight"><pre><span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">WordCount</span><span class="p">(</span><span class="k">this</span> <span class="n">String</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">str</span><span class="p">.</span><span class="n">Split</span><span class="p">(</span><span class="k">new</span> <span class="kt">char</span><span class="p">[]</span> <span class="p">{</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">,</span> <span class="sc">&#39;?&#39;</span> <span class="p">},</span>
                     <span class="n">StringSplitOptions</span><span class="p">.</span><span class="n">RemoveEmptyEntries</span><span class="p">).</span><span class="n">Length</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>At the call site,
the new method is indistinguishable from any of the existing&nbsp;ones:</p>
<div class="highlight"><pre><span class="kt">string</span> <span class="n">s</span> <span class="p">=</span> <span class="s">&quot;Alice has a cat.&quot;</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">WordCount</span><span class="p">();</span>
</pre></div>


<p>That&#8217;s assuming you have imported both the original class
(or it&#8217;s a built-in like <code>String</code>),
as well as the module in which the extension method is&nbsp;defined.</p>
<h4>Rewrite it in&nbsp;Rust</h4>
<p>The curious thing about <a href="http://rust-lang.org">Rust</a>&#8216;s type system is
that it permits extension methods solely as a side effect of its core building block: <em>traits</em>.</p>
<p>In this post, I&#8217;m going to describe a certain design pattern in Rust
which involves third-party types and user-defined traits.
Several popular crates &#8212;
like <a href="https://docs.rs/itertools">itertools</a> or <a href="https://docs.rs/unicode-normalization/">unicode-normalization</a> &#8212;
utilize it very successfully to add new, useful methods to the language standard&nbsp;types.</p>
<p>I&#8217;m not sure if this pattern has an official or widely accepted name.
Personally, I&#8217;ve taken to calling it <strong>extension traits</strong>.</p>
<p>Let&#8217;s have a look at how they are commonly&nbsp;implemented.</p>
<h4>Ingredients</h4>
<p>We can use the extension trait pattern if we want to have additional methods in a type
that we don&#8217;t otherwise control (or don&#8217;t want to&nbsp;modify).</p>
<p>Common cases&nbsp;include:</p>
<ul>
<li>Rust standard library types, like <code>Result</code>, <code>String</code>,
  or anything else inside the <code>std</code> namespace</li>
<li>types imported from <a href="https://crates.io">third-party&nbsp;libraries</a></li>
<li>types from the current crate if additional methods only make sense in certain scenarios
  (e.g. conditional compilation / testing)<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup></li>
</ul>
<p>The crux of this technique is really simple.
Like with most design patterns, however,
it involves a certain degree of boilerplate and&nbsp;duplication.</p>
<p>So without further ado&#8230;
In order to &#8220;patch&#8221; some new method(s) into an external type you will need&nbsp;to:</p>
<ol>
<li>Define a trait with signatures of all the methods you want to&nbsp;add.</li>
<li>Implement it for the external&nbsp;type.</li>
<li><em>There is no step three</em>.</li>
</ol>
<p>As an important note on the usage side,
the calling code needs to <em>import your new trait</em> in addition to the external type.
Once that&#8217;s done, it can proceed to use the new methods is if they were there to begin&nbsp;with.</p>
<p>I&#8217;m sure you are keen on seeing some&nbsp;examples!</p>
<h4>Broadening your <code>Option</code>s</h4>
<p>We&#8217;re going to add two new methods to Rust&#8217;s <a href="https://doc.rust-lang.org/std/option/enum.Option.html">standard <code>Option</code> type</a>.
The goal is to make it more convenient to operate on mutable <code>Option</code>s
by allowing to easily replace an existing value with another one<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>.</p>
<p>Here&#8217;s the appropriate extension trait<sup id="fnref:4"><a class="footnote-ref" href="#fn:4" rel="footnote">4</a></sup>:</p>
<div class="highlight"><pre><span class="c-Doc">/// Additional mutation methods for `Option`.</span>
<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">OptionMutExt</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c-Doc">/// Replace the existing `Some` value with a new one.</span>
<span class="w">    </span><span class="c-Doc">///</span>
<span class="w">    </span><span class="c-Doc">/// Returns the previous value if it was present, or `None` if no replacement was made.</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c-Doc">/// Replace the existing `Some` value with the result of given closure.</span>
<span class="w">    </span><span class="c-Doc">///</span>
<span class="w">    </span><span class="c-Doc">/// Returns the previous value if it was present, or `None` if no replacement was made.</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">replace_with</span><span class="o">&lt;</span><span class="n">F</span><span class="o">:</span><span class="w"> </span><span class="n">FnOnce</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>It may feel at little bit weird to implement it.<br>
You will basically have to pretend you are <em>inside the <code>Option</code> type itself</em>:</p>
<div class="highlight"><pre><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">OptionMutExt</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">replace_with</span><span class="p">(</span><span class="n">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">replace_with</span><span class="o">&lt;</span><span class="n">F</span><span class="o">:</span><span class="w"> </span><span class="n">FnOnce</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">is_some</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">take</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">f</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="n">result</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">None</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Unfortunately, this is just an illusion.
Extension traits grant no special powers
that&#8217;d allow you to bypass any of the regular visibility rules.
All you can use inside the new methods is still
just the <em>public interface</em> of the type you&#8217;re augmenting (here, <code>Option</code>).</p>
<p>In our case, however, this is good enough,
mostly thanks to <a href="option_take">the recently introduced <code>Option::take</code></a>.</p>
<p>To use our shiny new methods in other places,
all we have to do is import the extension&nbsp;trait:</p>
<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">ext</span><span class="o">::</span><span class="n">rust</span><span class="o">::</span><span class="n">OptionMutExt</span><span class="p">;</span><span class="w">  </span><span class="c1">// assuming you put it in ext/rust.rs</span>

<span class="c1">// ...somewhere...</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">opt</span><span class="o">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="k">match</span><span class="w"> </span><span class="n">opt</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">debug</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Option had a value of {} before replacement&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="nb">None</span><span class="p">,</span><span class="w"> </span><span class="n">opt</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>It doesn&#8217;t matter where it was defined either,
meaning we can ship it away to <a href="https://crates.io">crates.io</a>
and let it accrue as many happy users as <code>Itertools</code> has&nbsp;;-)</p>
<h4>Are you <code>hyper::Body</code> ready?</h4>
<p>Our second example will demonstrate attaching more methods to a third-party&nbsp;type.</p>
<p>Last week, there was a new release of <a href="https://hyper.rs/">Hyper</a>,
a popular Rust framework for <span class="caps">HTTP</span> servers <span class="amp">&amp;</span> clients.
It was notable because it marked a switch from synchronous, straightforward <span class="caps">API</span>
to a more complex, asynchronous one
(which I incidentally <a href="http://xion.io/post/programming/rust-async-closer-look.html">wrote about a few weeks ago</a>).</p>
<p>Predictably, <a href="https://www.reddit.com/r/rust/comments/6hksa0/problems_with_understanding_hypers_async/">there has been some confusion</a>
among its new and existing&nbsp;users.</p>
<p>We&#8217;re going to help by pinning a more convenient interface on
<a href="https://hyper.rs/hyper/master/hyper/struct.Body.html">hyper&#8217;s <code>Body</code> type</a>.
<code>Body</code> here is a struct representing the content of an <span class="caps">HTTP</span> request or response.
After the &#8216;asyncatastrophe&#8217;,
it doesn&#8217;t allow to access the raw incoming bytes as easily as it did&nbsp;before.</p>
<p>Thanks to extension traits, we can fix this rather&nbsp;quickly:</p>
<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">Error</span><span class="p">;</span><span class="w"></span>

<span class="kn">use</span><span class="w"> </span><span class="n">futures</span><span class="o">::</span><span class="p">{</span><span class="n">BoxFuture</span><span class="p">,</span><span class="w"> </span><span class="n">future</span><span class="p">,</span><span class="w"> </span><span class="n">Future</span><span class="p">,</span><span class="w"> </span><span class="n">Stream</span><span class="p">};</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">hyper</span><span class="o">::</span><span class="p">{</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">Body</span><span class="p">};</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">BodyExt</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c-Doc">/// Collect all the bytes from all the `Chunk`s from `Body`</span>
<span class="w">    </span><span class="c-Doc">/// and return it as `Vec&lt;u8&gt;`.</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">into_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">BoxFuture</span><span class="o">&lt;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">hyper</span><span class="o">::</span><span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c-Doc">/// Collect all the bytes from all the `Chunk`s from `Body`,</span>
<span class="w">    </span><span class="c-Doc">/// decode them as UTF8, and return the resulting `String`.</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">into_string</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">BoxFuture</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">BodyExt</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Body</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">into_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">BoxFuture</span><span class="o">&lt;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">hyper</span><span class="o">::</span><span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">concat</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">bytes</span><span class="o">|</span><span class="w"> </span><span class="n">future</span><span class="o">::</span><span class="n">ok</span><span class="o">::&lt;</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">hyper</span><span class="o">::</span><span class="n">Error</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bytes</span><span class="p">.</span><span class="n">to_vec</span><span class="p">()))</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">boxed</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">into_string</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">BoxFuture</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">into_bytes</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">bytes</span><span class="o">|</span><span class="w"> </span><span class="n">String</span><span class="o">::</span><span class="n">from_utf8</span><span class="p">(</span><span class="n">bytes</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">boxed</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>With these new methods in hand,
it is relatively straightforward to implement, say, a simple character-counting&nbsp;service:</p>
<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">Error</span><span class="p">;</span><span class="w"></span>

<span class="kn">use</span><span class="w"> </span><span class="n">futures</span><span class="o">::</span><span class="p">{</span><span class="n">BoxFuture</span><span class="p">,</span><span class="w"> </span><span class="n">future</span><span class="p">,</span><span class="w"> </span><span class="n">Future</span><span class="p">};</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">hyper</span><span class="o">::</span><span class="n">server</span><span class="o">::</span><span class="p">{</span><span class="n">Service</span><span class="p">,</span><span class="w"> </span><span class="n">Request</span><span class="p">,</span><span class="w"> </span><span class="n">Response</span><span class="p">};</span><span class="w"></span>

<span class="kn">use</span><span class="w"> </span><span class="n">ext</span><span class="o">::</span><span class="n">hyper</span><span class="o">::</span><span class="n">BodyExt</span><span class="p">;</span><span class="w">  </span><span class="c1">// assuming the above is in ext/hyper.rs</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="n">Length</span><span class="p">;</span><span class="w"></span>
<span class="k">impl</span><span class="w"> </span><span class="n">Service</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Length</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="n">Request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Request</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="n">Response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Response</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BoxFuture</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">::</span><span class="n">Response</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span><span class="o">::</span><span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">call</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">request</span><span class="o">:</span><span class="w"> </span><span class="n">Request</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="o">::</span><span class="n">Future</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">request</span><span class="p">.</span><span class="n">deconstruct</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">body</span><span class="p">.</span><span class="n">into_string</span><span class="p">().</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="n">future</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">Response</span><span class="o">::</span><span class="n">new</span><span class="p">().</span><span class="n">with_body</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">().</span><span class="n">to_string</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">)).</span><span class="n">boxed</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Replacing <code>Box&lt;Error + Send&gt;</code> with an idiomatic <a href="https://docs.rs/crate/derive-error/">error enum</a>
is left as an exercise for the reader&nbsp;:)</p>
<h4>Extra credit bonus&nbsp;explanation</h4>
<p><small>Reading this section is not necessary to use extension traits.</small></p>
<p>So far, we have seen what extension traits are capable of.
It is only right to mention what they <em>cannot do</em>.</p>
<p>Indeed, this technique has some limitations.
They are a conscious choice on the part of Rust authors,
and they were decided upon in an effort to keep the type system <em>coherent</em>.</p>
<p>Coherence isn&#8217;t an everyday topic in Rust,
but it becomes important when working with traits and types that cross package boundaries.
Rules of trait coherence
(described briefly towards the end of <a href="coherence-in-book">this section of the Rust book</a>)
state that the following combinations of &#8220;local&#8221; (this crate) and &#8220;external&#8221; (other crates<sup id="fnref:5"><a class="footnote-ref" href="#fn:5" rel="footnote">5</a></sup>) are&nbsp;legal:</p>
<ul>
<li>implement a <em>local</em> trait for a <em>local</em> type.<br>
  This is common in larger programs that use polymorphic&nbsp;abstractions.</li>
<li>implement an <em>external</em> trait for a <em>local</em> type.<br>
  We do this often to integrate with third-party libraries and frameworks,
  just like with <code>hyper</code> above.</li>
<li>implement a <em>local</em> trait for an <em>external</em> type.<br>
  That&#8217;s extension traits for&nbsp;you!</li>
</ul>
<p>What is <em>not</em> possible, however, is&nbsp;to:</p>
<ul>
<li>implement an <em>external</em> trait for an <em>external</em>&nbsp;type</li>
</ul>
<p>This case is prohibited in order to make the choice of trait implementations more predictable,
both for the compiler and for the programmer.
Without this rule in place, you could introduce many instances of <code>impl Trait for Type</code>
(same <code>Trait</code> and same <code>Type</code>),
each one with different functionality,
leaving the compiler to &#8220;guess&#8221; the right <code>impl</code> for any given situation<sup id="fnref:6"><a class="footnote-ref" href="#fn:6" rel="footnote">6</a></sup>.</p>
<p>The decision was thus made to disallow the <code>impl ExternalTrait for ExternalType</code> case altogether.
If you like, you can read <a href="rust-orphans">some more extensive backstory</a> behind&nbsp;it.</p>
<p>Bear in mind, however, that this isn&#8217;t the unequivocally &#8220;correct&#8221; solution.
<a href="hs-orphans">Some languages</a> choose to allow this so-called <em>orphan</em> case,
and try to resolve the potential ambiguities in various different ways.
It is a genuinely useful feature, too, as it makes easier it to glue together two unrelated libraries<sup id="fnref:7"><a class="footnote-ref" href="#fn:7" rel="footnote">7</a></sup>.</p>
<p>Thankfully for extension traits,
the coherence restriction doesn&#8217;t apply as long as you keep those traits and their <code>impl</code>s in the same&nbsp;crate.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>This practice is often referred to as <em>monkeypatching</em>, especially in Python and Ruby.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>In this case, a more common solution is to just open another <code>impl Foo</code> block,
annotated with <code>#[cfg(test)]</code> or similar.
An extension trait, however, makes it easier
to extract <code>Foo</code> into a separate crate along with some handy, test-only <span class="caps">API</span>.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>Note that this is <em>not</em> the same as the unstable (as of 1.18) <code>Option</code> methods
guarded behind <a href="https://github.com/rust-lang/rust/issues/39288">the <code>options_entry</code> feature gate</a>.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>My own convention is to call those traits <code>FooExt</code>
if they are meant to enhance the interface of type <code>Foo</code>.
The other practice is to mirror the name of the crate that the trait is packaged in;
both <code>Itertools</code> and <code>UnicodeNormalization</code> are examples of this style.&#160;<a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:5">
<p>Standard library (<code>std</code> or <code>core</code> namespaces) counts as external crate for this purpose.&#160;<a class="footnote-backref" href="#fnref:5" rev="footnote" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:6">
<p>Or throw an error. However, trait <code>impl</code>s are always imported implicitly,
so this could essentially prevent some combination of different modules/libraries in the ecosystem from being used together,
and generally create an unfathomable mess.&#160;<a class="footnote-backref" href="#fnref:6" rev="footnote" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:7">
<p>The usual workaround for coherence/orphan rules in Rust involves creating a wrapper
around the external type in order to make it &#8220;local&#8221;, and therefore allow external trait <code>impl</code>s for it.
This is called <a href="https://github.com/rust-unofficial/patterns/blob/master/patterns/newtype.md">the <em>newtype</em> pattern</a>
and there are <a href="https://docs.rs/newtype_derive">some crates</a> to support it.&#160;<a class="footnote-backref" href="#fnref:7" rev="footnote" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/rust-extension-traits.html#rust-extension-traits">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/code/rust-iter-patterns.html#rust-iter-patterns">Iteration patterns for Result <span class="amp">&amp;</span>&nbsp;Option</a></h2>
    <p>
      Posted on Mon 10 April 2017 in <a href="http://xion.io/category/code.html">Code</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/iterators.html">iterators</a>      &#8226; <a href="http://xion.io/post/code/rust-iter-patterns.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>Towards the end of <a href="http://xion.io/post/code/rust-for-loop.html">my previous post about <code>for</code> loops in Rust</a>,
I mentioned how those loops can often be expressed in a more declarative way.
This alternative approach involves chaining methods of
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">the <code>Iterator</code> trait</a>
to create specialized transformation&nbsp;pipelines:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">odds_squared</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">1.</span><span class="p">.</span><span class="mi">100</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
</pre></div>


<p><small><a href="https://is.gd/q4lXew">Playground link</a></small></p>
<p>Code like this isn&#8217;t unique to Rust, of course.
Similar patterns are prevalent in functional languages such as
<a href="https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/operators.%5b-h%5d-%5d%5b't1%2c'u%5d-function-%5bfsharp%5d">F#</a>,
and can also be found in
Java (<a href="https://dzone.com/articles/understanding-java-8-streams-1">Streams</a>),
imperative .<span class="caps">NET</span> (<a href="https://msdn.microsoft.com/en-us/library/bb308959.aspx#linqoverview_topic3"><span class="caps">LINQ</span></a>),
JavaScript (<a href="https://lodash.com/docs/4.17.4#chain">LoDash</a>)
and&nbsp;elsewhere.</p>
<p>This saying, Rust also has its fair share of unique iteration idioms.
In this post, we&#8217;re going to explore those arising on the intersection of iterators
and the most common Rust enums: <code>Result</code> and <code>Option</code>.</p>
<h4>filter_map()</h4>
<p>When working with iterators,
we&#8217;re almost always interested in selecting elements that match some criterion
or passing them through a transformation function.
It&#8217;s not even uncommon to want <em>both</em> of those things,
as demonstrated by the initial example in this&nbsp;post.</p>
<p>You can, of course, accomplish those two tasks independently:
Rust&#8217;s <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter"><code>filter</code></a>
and <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map"><code>map</code></a> methods
work just fine for this purpose.
But there exists an alternative, and in some cases it fits the problem <em>amazingly</em>&nbsp;well.</p>
<p>Meet <code>filter_map</code>.
Here&#8217;s what <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter_map">the official docs</a>
have to say about&nbsp;it:</p>
<blockquote>
<p>Creates an iterator that both filters and&nbsp;maps.</p>
</blockquote>
<p>Well, <em>duh</em>.</p>
<p>On a more serious note, the common pattern that <code>filter_map</code> simplifies
is unwrapping a series of <code>Option</code>s.
If you have a sequence of maybe-values,
and you want to retain only those that are actually there,
<code>filter_map</code> can do it in a single&nbsp;step:</p>
<div class="highlight"><pre><span class="c1">// Get the sequence of all files matching a glob pattern via the glob crate.</span>
<span class="kd">let</span><span class="w"> </span><span class="n">some_files</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glob</span><span class="o">::</span><span class="n">glob</span><span class="p">(</span><span class="s">&quot;foo.*&quot;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">unwrap</span><span class="p">());</span><span class="w"></span>
<span class="c1">// Retain only their extensions, e.g. &quot;.txt&quot; or &quot;.md&quot;.</span>
<span class="kd">let</span><span class="w"> </span><span class="n">file_extensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_files</span><span class="p">.</span><span class="n">filter_map</span><span class="p">(</span><span class="o">|</span><span class="n">p</span><span class="o">|</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">extension</span><span class="p">());</span><span class="w"></span>
</pre></div>


<p>The equivalent that doesn&#8217;t use <code>filter_map</code>
would have to split the checking <span class="amp">&amp;</span> unwrapping of <code>Option</code>s into separate&nbsp;steps:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">file_extensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_files</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">p</span><span class="o">|</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">extension</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">is_some</span><span class="p">()).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">unwrap</span><span class="p">());</span><span class="w"></span>
</pre></div>


<p>Because of this check <span class="amp">&amp;</span> unwrap logic,
<code>filter_map</code> can be useful even with a no-op predicate (<code>.filter_map(|x| x)</code>)
if we already have the <code>Option</code> objects handy.
Otherwise, it&#8217;s often very easy to obtain them,
which is exactly the case for the <code>Result</code> type:</p>
<div class="highlight"><pre><span class="c1">// Read all text lines from a file:</span>
<span class="kd">let</span><span class="w"> </span><span class="n">lines</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BufReader</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">fs</span><span class="o">::</span><span class="n">File</span><span class="o">::</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;file.ext&quot;</span><span class="p">)</span><span class="o">?</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">lines</span><span class="p">().</span><span class="n">filter_map</span><span class="p">(</span><span class="nb">Result</span><span class="o">::</span><span class="n">ok</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
</pre></div>


<p>With a simple <code>.filter_map(Result::ok)</code>, like above,
we can pass through a sequence of <code>Result</code>s and yield only the &#8220;successful&#8221; values.
I find this particular idiom to be extremely useful in practice,
as long as you remember that <code>Err</code>ors will be discarded by it<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>.</p>
<p>As a final note on <code>filter_map</code>,
you need to keep in mind that regardless of how great it often is,
not all combinations of <code>filter</code> and <code>map</code> should be replaced by it.
When deciding whether it&#8217;s appropriate in your case,
it is helpful to consider the equivalence of these two&nbsp;expressions:</p>
<div class="highlight"><pre><span class="n">iter</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="n">f</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"></span>
<span class="n">iter</span><span class="p">.</span><span class="n">filter_map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">None</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
</pre></div>


<p>Simply put, if you find yourself writing conditions like this inside <code>filter_map</code>,
you&#8217;re probably better off with two separate processing&nbsp;steps.</p>
<h4>collect()</h4>
<p>Let&#8217;s go back to the last example with a sequence of <code>Result</code>s.
Since the final sequence won&#8217;t include any <code>Err</code>oneous values,
you may be wondering if there is a way to preserve&nbsp;them.</p>
<p>In more formal terms, the question is about turning a vector of results
(<code>Vec&lt;Result&lt;T, E&gt;&gt;</code>) into a result with a vector (<code>Result&lt;Vec&lt;T&gt;, E&gt;</code>).
We&#8217;d like for this aggregated result to only be <code>Ok</code>
if <em>all</em> original results were <code>Ok</code>.
Otherwise, we should just get the first <code>Err</code>or.</p>
<p>Believe it or not, but this is probably <em>the</em> most common Rust problem!<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup></p>
<p>Of course, that doesn&#8217;t necessarily mean the problem is particularly hard.
Possible solutions exist in both an iterator&nbsp;version:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">results</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">fold</span><span class="p">(</span><span class="nb">Ok</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[]),</span><span class="w"> </span><span class="o">|</span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="o">|</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">as_mut</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">v</span><span class="o">|</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">));</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="w"></span>
<span class="p">});</span><span class="w"></span>
</pre></div>


<p>and in a loop&nbsp;form:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[]);</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">as_mut</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">v</span><span class="o">|</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">);</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>but I suspect not many people would call them clear and readable,
let alone pretty<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>.</p>
<p>Fortunately, you don&#8217;t need to pollute your codebase with any of those workarounds.
Rust offers an out-of-the-box solution which solves this particular problem,
and its only flaw is one that I hope to address through this very&nbsp;post.</p>
<p>So, here it&nbsp;goes:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="o">:</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">results</span><span class="p">.</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
</pre></div>


<p>Yep, that&#8217;s all of&nbsp;it.</p>
<p>The background story is that <code>Result&lt;Vec&lt;T&gt;, E&gt;</code> simply &#8220;knows&#8221;
how to construct itself from a sequence of <code>Result</code>s.
Unfortunately, this <span class="caps">API</span> is hidden behind Rust&#8217;s iterator abstraction,
and specifically the fact that
<code>Result</code> implements <a href="https://doc.rust-lang.org/1.2.0/std/iter/trait.FromIterator.html"><code>FromIterator</code></a>
in this particular manner.
The way
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">the documentation page for <code>Result</code></a>
is structured, however &#8212; with trait implementations at the very end &#8212;
ensures this useful fact remains virtually&nbsp;undiscoverable.</p>
<p>Because let&#8217;s be honest: no one scrolls that&nbsp;far.</p>
<p>Incidentally, <code>Option</code> offers analogous functionally:
a sequence of <code>Option&lt;T&gt;</code> can be <code>collect</code>ed into <code>Option&lt;Vec&lt;T&gt;&gt;</code>,
which will be <code>None</code> if any of the input elements were.
As you may suspect, this fact is equally hard to find in the relevant&nbsp;docs.</p>
<p>But the good news is: you know about all this now! :)
And perhaps thanks to this post,
those handy tricks become a little better in a wider Rust&nbsp;community.</p>
<h4>partition()</h4>
<p>The last technique I wanted to present here follows naturally
from the other idioms that apply to <code>Result</code>s.
Instead of extracting just the <code>Ok</code> values with <code>flat_map</code>,
or keeping only the first error through <code>collect</code>,
we will now learn how to retain all the errors <em>and</em> all the values,
both neatly&nbsp;separated.</p>
<p>The <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.partition"><code>partition</code> method</a>,
as this is what the section is about,
is essentially a more powerful variant of <code>filter</code>.
While the latter only returns items that <em>do</em> match a predicate,
<code>partition</code> will also give us the ones which <em>don&#8217;t</em>.</p>
<p>Using it to slice an iterable of <code>Result</code>s is&nbsp;straightforward:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">oks</span><span class="p">,</span><span class="w"> </span><span class="n">fails</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">results</span><span class="p">.</span><span class="n">partition</span><span class="p">(</span><span class="nb">Result</span><span class="o">::</span><span class="n">is_ok</span><span class="p">);</span><span class="w"></span>
</pre></div>


<p>The only thing that remains cumbersome is
the fact that both parts of the resulting tuple still contain just <code>Result</code>s.
Ideally, we would like them to be already unwrapped into values and errors,
but unfortunately we need to do this&nbsp;ourselves:</p>
<div class="highlight"><pre><span class="kd">let</span><span class="w"> </span><span class="n">values</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">oks</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="nb">Result</span><span class="o">::</span><span class="n">unwrap</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">errors</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fails</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="nb">Result</span><span class="o">::</span><span class="n">unwrap_err</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
</pre></div>


<p>As an alternative,
<a href="https://docs.rs/itertools/0.6.0/itertools/trait.Itertools.html#method.partition_map">the <code>partition_map</code> method</a>
from the <a href="https://crates.io/crates/itertools"><code>itertools</code> crate</a>
can accomplish the same thing in a single step,
albeit a more verbose&nbsp;one.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>A symmetrical technique is to use <code>.filter_map(Result::err)</code> to get just
the <code>Err</code>or objects, but that&#8217;s probably much less useful
as it drops all the successful values.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Based on my completely unsystematic and anecdotal observations,
someone asks about this on the #rust-beginners <span class="caps">IRC</span> approximately <em>every other day</em>.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>The <code>fold</code> variant is also rife with type inference traps,
often requiring explicit type annotations, a &#8220;no-op&#8221; <code>Err</code> arm in <code>match</code>,
or both.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/code/rust-iter-patterns.html#rust-iter-patterns">Continue reading</a>
  </div>
</article>

  <div class="pagination">
    <a class="btn" href="http://xion.io/category/code2.html">
      <i class="fa fa-angle-left"></i> Older Posts
    </a>
  </div>

    <footer>
<p>
  &copy; Karol Kuczmarski 2019 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-27379564-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Karol Kuczmarski's Blog ",
  "url" : "http://xion.io",
  "image": "http://xion.io/logo.jpeg",
  "description": ""
}
</script><script type="text/javascript">
    var disqus_shortname = 'xionblog';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>