<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/font-awesome.min.css">

    <link href="http://xion.io/style.css" rel="stylesheet">




  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

    <meta name="author" content="Karol Kuczmarski" />
    <meta name="description" content="" />
<meta property="og:site_name" content="Karol Kuczmarski's Blog"/>
<meta property="og:type" content="blog"/>
<meta property="og:title" content="Karol Kuczmarski's Blog"/>
<meta property="og:description" content=""/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://xion.io"/>
<meta property="og:image" content="http://xion.io/logo.jpeg">

  <title>Karol Kuczmarski's Blog &ndash; Category: Programming</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://xion.io">
        <img src="http://xion.io/logo.jpeg" alt="Karol Kuczmarski" title="Karol Kuczmarski">
      </a>
      <h1><a href="http://xion.io">Karol Kuczmarski</a></h1>
      <p>fn(Tea) -> Code</p>
      <nav>
        <ul class="list">
          <li><a href="http://xion.io/page/about.html#about">About</a></li>
          <li><a href="http://xion.io/page/projects.html#projects">Projects</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-github" href="http://github.com/Xion" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-stack-overflow" href="http://stackoverflow.com/users/434799/xion" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
        <li><a class="sc-twitter" href="http://twitter.com/Xion__" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-google" href="https://plus.google.com/+KarolKuczmarski" target="_blank"><i class="fa fa-google"></i></a></li>
        <li><a class="sc-rss" href="/feeds/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="http://xion.io">Home</a>
      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>
      <a href="http://xion.org.pl/">Old blog</a>
    </nav>

<article>
  <header>
    <h2><a href="http://xion.io/post/programming/rust-into-haskell.html#rust-into-haskell">Rust as a gateway drug to&nbsp;Haskell</a></h2>
    <p>
      Posted on Tue 13 June 2017 in <a href="http://xion.io/category/programming.html">Programming</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/haskell.html">Haskell</a>,      <a href="http://xion.io/tag/traits.html">traits</a>,      <a href="http://xion.io/tag/typeclasses.html">typeclasses</a>,      <a href="http://xion.io/tag/monads.html">monads</a>,      <a href="http://xion.io/tag/adts.html">ADTs</a>,      <a href="http://xion.io/tag/fp.html">FP</a>      &#8226; <a href="http://xion.io/post/programming/rust-into-haskell.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>For work-related reasons,
I had to recently get up to speed on programming in <a href="https://www.haskell.org/">Haskell</a>.</p>
<p>Before that, I had very little actual experience with the language,
clocking probably at less than a thousand lines of working code over a couple of years.
Nothing impressive either:
some <a href="https://gist.github.com/Xion/b8fdb6a896264915ad85">wrapper script</a> here,
some <a href="https://gist.github.com/Xion/1525222">experimental rewrite</a>&nbsp;there&#8230;</p>
<p>These days, I heard, there are a few resources for learning Haskell<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>
that don&#8217;t require having a PhD in category theory<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>.
They may be quite helpful when your exposure to the functional programming is limited.
In my case, however, the one thing that <em>really</em> enabled me to become (somewhat) productive
was not even related to Haskell at&nbsp;all.</p>
<p>It was <a href="http://rust-lang.org/">Rust</a>.</p>
<p>In theory, this shouldn&#8217;t really make much of a sense.
If you compare both languages by putting checkmarks in a feature chart,
you won&#8217;t find them to have much in&nbsp;common.</p>
<p>Some of the obvious differences&nbsp;include:</p>
<ul>
<li>predominantly functional vs. mostly&nbsp;imperative</li>
<li>garbage collection vs. explicit memory&nbsp;management</li>
<li>lazy vs. eager&nbsp;evaluation</li>
<li>rich runtime<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup> vs. almost no&nbsp;runtime</li>
<li>global vs. localized type&nbsp;inference</li>
<li>indentation vs.&nbsp;braces</li>
<li>two decades (!) vs. barely two years since&nbsp;release</li>
</ul>
<p>Setting aside syntax, most of those differences are pretty&nbsp;significant.</p>
<p>You probably wouldn&#8217;t use Haskell for embedded programming, for instance,
both for performance (<span class="caps">GC</span>) and memory usage reasons (laziness).
Similarly, Rust&#8217;s ownership system can be too much of a hassle for high level code
that isn&#8217;t subject to real time&nbsp;requirements.</p>
<p>But if you look a little deeper,
beyond just the surface descriptions of both languages,
you can find plenty of <em>concepts</em> they&nbsp;share.</p>
<h4>Traits: they are typeclasses,&nbsp;essentially</h4>
<p>Take Haskell&#8217;s typeclasses, for example &#8212;
the cornerstone of its rich and expressive type&nbsp;system.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Type_class"><em>typeclass</em></a> is, simply speaking,
a list of capabilities:
it defines what a type can <em>do</em>.
There exist analogs of typeclasses in most programming languages,
but they are normally called interfaces or protocols,
and remain closely tied to the object-oriented&nbsp;paradigm.</p>
<p>Not so in&nbsp;Haskell.</p>
<p>Or in Rust for that matter, where the equivalent concept exists under the name of <em>traits</em>.
What typeclasses and traits have in common is that
they&#8217;re used for <em>all kinds of polymorphism</em> in their respective&nbsp;languages.</p>
<h5>Generics</h5>
<p>For example, let&#8217;s consider <em>parametrized types</em>,
sometimes also referred to as templates (C++) or generics&nbsp;(C#).</p>
<p>In many cases, a generic function or type requires its type arguments
to exhibit certain characteristics.
In some languages (like the legacy C++), this is checked only implicitly:
as long as the template type-checks after its expansion, everything is&nbsp;okay:</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">min</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">b</span> <span class="p">:</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Foo</span> <span class="p">{};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1">// OK</span>
    <span class="n">min</span><span class="p">(</span><span class="n">Foo</span><span class="p">(),</span> <span class="n">Foo</span><span class="p">());</span>  <span class="c1">// ERROR, no operator `&gt;`</span>
<span class="p">}</span>
</pre></div>


<p>More advanced type systems, however, allow to specify the generic constraints <em>explicitly</em>.
This is the case in&nbsp;Rust:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">min</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>as well as in&nbsp;Haskell:</p>
<div class="highlight"><pre><span class="nf">min</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">min</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="kr">then</span> <span class="n">b</span> <span class="kr">else</span> <span class="n">a</span>
</pre></div>


<p>In both languages, the notion of a type supporting certain operations (like comparison/ordering)
is represented as its own, first-class concept:
a <em>trait</em> (Rust) or a <em>typeclass</em> (Haskell).
Since the compiler is aware of those constraints,
it can verify that the <code>min</code> function is used correctly even before
it tries to generate code for a specific substitution of <code>T</code>.</p>
<h5>Dynamic&nbsp;dispatch</h5>
<p>On the other hand, let&#8217;s look at <em>runtime polymorphism</em>:
the one that <span class="caps">OO</span> languages implement
through abstract base classes and virtual methods.
It&#8217;s the tool of choice if you need a container of objects of different types,
which nevertheless all expose the same&nbsp;interface.</p>
<p>To offer it, Rust has <a href="https://doc.rust-lang.org/book/first-edition/trait-objects.html"><em>trait objects</em></a>,
and they work pretty much exactly like base class pointers/references from Java, C++, or&nbsp;C#.</p>
<div class="highlight"><pre><span class="c1">// Trait definition</span>
<span class="k">trait</span><span class="w"> </span><span class="n">Draw</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Data type implementing the trait</span>
<span class="k">struct</span><span class="w"> </span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">radius</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="k">impl</span><span class="w"> </span><span class="n">Draw</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">draw</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* omitted */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Usage</span>
<span class="k">fn</span><span class="w"> </span><span class="n">draw_all</span><span class="p">(</span><span class="n">objects</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Draw</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">obj</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">objects</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">obj</span><span class="p">.</span><span class="n">draw</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>The Haskell analogue is, in turn, based on typeclasses,
though the specifics can be a little bit&nbsp;trickier:</p>
<div class="highlight"><pre><span class="cm">{-# LANGUAGE ExistentialQuantification #-}</span>

<span class="c1">-- Typeclass definition</span>
<span class="kr">class</span> <span class="kt">Draw</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">draw</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>

<span class="c1">-- Polymorphic wrapper type</span>
<span class="kr">data</span> <span class="kt">Draw&#39;</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Draw</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Draw&#39;</span> <span class="n">a</span>
<span class="kr">instance</span> <span class="kt">Draw</span> <span class="kt">Draw&#39;</span> <span class="kr">where</span>
    <span class="n">draw</span> <span class="p">(</span><span class="kt">Draw&#39;</span> <span class="n">d</span><span class="p">)</span> <span class="ow">=</span> <span class="n">draw</span> <span class="n">d</span>

<span class="c1">-- Data types instantiating (&quot;implementing&quot;) the typeclass</span>
<span class="kr">data</span> <span class="kt">Circle</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="nb">()</span>
<span class="kr">instance</span> <span class="kt">Draw</span> <span class="kt">Circle</span> <span class="kr">where</span> <span class="n">draw</span> <span class="ow">=</span> <span class="n">undefined</span> <span class="c1">-- omitted</span>
<span class="kr">data</span> <span class="kt">Square</span> <span class="ow">=</span> <span class="kt">Square</span> <span class="nb">()</span>
<span class="kr">instance</span> <span class="kt">Draw</span> <span class="kt">Square</span> <span class="kr">where</span> <span class="n">draw</span> <span class="ow">=</span> <span class="n">undefined</span> <span class="c1">-- omitted</span>

<span class="c1">-- Usage</span>
<span class="nf">drawAll</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Draw</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">drawAll</span> <span class="n">ds</span> <span class="ow">=</span> <span class="n">mapM_</span> <span class="n">draw</span> <span class="n">ds</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="n">shapes</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Draw&#39;</span> <span class="kt">Circle</span> <span class="nb">()</span><span class="p">,</span> <span class="kt">Draw&#39;</span> <span class="kt">Square</span> <span class="nb">()</span><span class="p">]</span>
    <span class="n">drawAll</span> <span class="n">shapes</span>
</pre></div>


<p>Here, the generic function can use typeclass constraints directly (<code>(Draw a) =&gt; ...</code>),
but creating a container of different object types requires a polymorphic wrapper<sup id="fnref:4"><a class="footnote-ref" href="#fn:4" rel="footnote">4</a></sup>.</p>
<h5>Differences</h5>
<p>All those similarities do not mean that
Rust traits and Haskell typeclasses are one and the same.
There are, in fact, quite a few differences, owing mostly to the fact that
Haskell&#8217;s type system is more&nbsp;expressive:</p>
<ul>
<li>
<p>Rust lacks <a href="https://en.wikipedia.org/wiki/Kind_(type_theory)#Kinds_in_Haskell"><em>higher kinded types</em></a>,
  making certain abstractions impossible to encode as traits.
  It <em>is</em> possible, however, to implement a trait for infinitely many types at once
  if the <code>impl</code>ementation itself is generic
  (like <a href="https://github.com/Xion/rofld/blob/2a9e427707cc93c716e011e99b0127f19cd770a5/src/lib/resources/mod.rs#L45">here</a>).</p>
</li>
<li>
<p>When defining a trait in Rust, you can ask implementors to provide some auxiliary,
  <a href="https://doc.rust-lang.org/book/first-edition/associated-types.html">associated types</a>
  in addition to just methods<sup id="fnref:5"><a class="footnote-ref" href="#fn:5" rel="footnote">5</a></sup>.
  A similar mechanism in Haskell is expanded into <a href="https://wiki.haskell.org/GHC/Type_families">type families</a>,
  and requires enabling a <a href="https://ocharles.org.uk/blog/posts/2014-12-12-type-families.html"><span class="caps">GHC</span> extension</a>.</p>
</li>
<li>
<p>While typeclasses in Haskell can be implemented for multiple types simultaneously
  via a <a href="https://wiki.haskell.org/Multi-parameter_type_class"><span class="caps">GHC</span> extension</a>,
  Rust&#8217;s take on this feature is to make <em>traits themselves</em> generic (e.g. <code>trait Foo&lt;T&gt;</code>).
  The end result is roughly similar;
  however, the &#8220;main implementing type&#8221; (one after <code>for</code> in <code>impl ... for ...</code>)
  is still a method receiver (<code>self</code>), just like in <span class="caps">OO</span>&nbsp;languages.</p>
</li>
<li>
<p>Rust enforces <em>coherence rules</em> on trait implementations.
  The topic is actually
  <a href="http://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/">rather complicated</a>,
  but the gist is about local (current package) vs. remote (other packages / standard library)
  traits and types.<br>
  Without too much detail, coherence demands that there be a local type or trait
  somewhere in the <code>impl ... for ...</code> construct.
  Haskell doesn&#8217;t have this limitation,
  although it is recommended <a href="https://wiki.haskell.org/Orphan_instance">not to take advantage of this</a>.</p>
</li>
</ul>
<h4>The&nbsp;M-word</h4>
<p>Another area of overlap between Haskell and Rust exists
in the <em>data model</em> utilized by those languages.
Both are taking heavy advantage of <a href="https://en.wikipedia.org/wiki/Algebraic_data_type"><em>algebraic data types</em> (<span class="caps">ADT</span>)</a>,
including the ability to define both <em>product types</em> (&#8220;regular&#8221; structs and records)
as well as <em>sum types</em> (tagged&nbsp;unions).</p>
<h5><code>Maybe</code> you&#8217;d like <code>Some(T)</code>?</h5>
<p>Even more interestingly,
code in both languages makes extensive use of the two most basic&nbsp;ADTs:</p>
<ul>
<li><code>Option</code> (Rust) or <code>Maybe</code> (Haskell) &#8212;
  for denoting a presence or absence of a&nbsp;value</li>
<li><code>Result</code> (Rust) or <code>Either</code> (Haskell) &#8212;
  for representing the alternative of &#8220;correct&#8221; and &#8220;erroneous&#8221;&nbsp;value</li>
</ul>
<p>These aren&#8217;t just simple datatypes.
They are deeply interwoven into the basic semantics of both languages,
not to mention their standard libraries and community-provided&nbsp;packages.</p>
<p>The <code>Option</code>/<code>Maybe</code> type, for example,
is the alternative to <em>nullable references</em>:
something that&#8217;s been
<a href="https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/">heavily criticized</a>
for making programs prone to unexpected <code>NullReferenceException</code>s.
The idea behind both of those types is to make actual values impossible to confuse with <code>null</code>s
by encoding the potential nullability into the type&nbsp;system:</p>
<div class="highlight"><pre><span class="k">enum</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w"> </span><span class="nb">None</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>


<!-- -->

<div class="highlight"><pre><span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Nothing</span>
</pre></div>


<p><code>Result</code> and <code>Either</code>, on the other hand,
can be thought as an extension of this idea.
They also represent two possibilities,
but the &#8220;wrong&#8221; one isn&#8217;t just <code>None</code> or <code>Nothing</code>
&#8212; it has some more information associated with&nbsp;it:</p>
<div class="highlight"><pre><span class="k">enum</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>


<!-- -->

<div class="highlight"><pre><span class="kr">data</span> <span class="kt">Either</span> <span class="n">e</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">e</span> <span class="o">|</span> <span class="kt">Right</span> <span class="n">a</span>
</pre></div>


<p>This dichotomy between the <code>Ok</code> (or <code>Right</code>) value and the <code>Err</code>or value (or the <code>Left</code> one)
makes it a great vehicle for carrying results of functions that can <em>fail</em>.</p>
<p>In Rust, this replaces the traditional error handling mechanisms based on exceptions.
In Haskell, the exceptions are present and sometimes necessary,
but <code>Either</code> is nevertheless the preferred approach to dealing with&nbsp;errors.</p>
<h5>What to <code>do</code>?</h5>
<p>One thing that Haskell does better is <em>composing</em> those fallible functions
into bigger chunks of&nbsp;logic.</p>
<p>Relatively recently, Rust has added the <a href="https://m4rw3r.github.io/rust-questionmark-operator"><code>?</code> operator</a>
as a replacement for the <code>try!</code> macro.
This is now the preferred way of <em>error propagation</em>,
allowing for a more concise composition of functions that return <code>Result</code>s:</p>
<div class="highlight"><pre><span class="c-Doc">/// Read an integer from given file.</span>
<span class="k">fn</span><span class="w"> </span><span class="n">int_from_file</span><span class="p">(</span><span class="n">path</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="nb">Path</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">io</span><span class="o">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span><span class="o">::</span><span class="n">File</span><span class="o">::</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">String</span><span class="o">::</span><span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">io</span><span class="o">::</span><span class="n">Error</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">io</span><span class="o">::</span><span class="n">ErrorKind</span><span class="o">::</span><span class="n">InvalidData</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>But Haskell had it for much longer,
and it&#8217;s something of a hallmark of the language and functional programming in general
&#8212; even though it looks thoroughly <em>imperative</em>:</p>
<div class="highlight"><pre><span class="nf">intFromFile</span> <span class="ow">::</span> <span class="kt">FilePath</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Int</span>
<span class="nf">intFromFile</span> <span class="n">path</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">readFile</span> <span class="n">path</span>
    <span class="n">i</span> <span class="ow">&lt;-</span> <span class="n">readIO</span> <span class="n">s</span>
    <span class="n">return</span> <span class="n">i</span>
</pre></div>


<p>If you haven&#8217;t seen it before, this is of course a <em>monad</em> &#8212; the <code>IO</code> monad, to be precise.
While discussing monads in detail is way outside of the scope of this article,
we can definitely notice some analogies with Rust.
The <code>do</code> notation with <code>&lt;-</code> arrows is evidently similar to
how in Rust you&#8217;d assign the result of a fallible operation after &#8220;unpacking&#8221; it with <code>?</code>.</p>
<p>But of course,
there&#8217;s plenty of different monads in Haskell: not just <code>IO</code>,
but also <code>Either</code>, <code>Maybe</code>, <code>Reader</code>, <code>Writer</code>, <code>Cont</code>, <code>STM</code>, and many others.
In Rust (at least as of 1.19), the <code>?</code> operator only works for <code>Result</code> types,
although there is <a href="https://github.com/rust-lang/rfcs/issues/1718">some talk</a>
about extending it to <code>Option</code> as well<sup id="fnref:6"><a class="footnote-ref" href="#fn:6" rel="footnote">6</a></sup>.</p>
<p>Eventually, we may see the language adopt some variant of the <code>do</code> notation,
though the motivation for this will most likely come from
<a href="https://github.com/alexcrichton/futures-await">asynchronous programming with <code>Future</code>s</a>
rather than plain <code>Result</code>s.
General monads, however, require support for <em>higher kinded types</em>
which <a href="https://github.com/rust-lang/rfcs/issues/324">isn&#8217;t coming anytime soon</a>.</p>
<h4>A path through&nbsp;Rust?</h4>
<p>Now that we&#8217;ve discussed those similarities,
the obvious question&nbsp;arises.</p>
<blockquote>
<p>Is learning Rust worthwhile
if your ultimate goal is getting proficient at functional programming in general,
or Haskell in&nbsp;particular?</p>
</blockquote>
<p>My answer to that is actually pretty&nbsp;straightforward.</p>
<p>If &#8220;getting to <span class="caps">FP</span>&#8221; is your main goal, then Rust will <em>not</em> help you very much.
Functional paradigm isn&#8217;t the main idea behind the language &#8212;
its shtick is mostly <em>memory safety</em>, and zero-cost abstractions.
While it succeeds somewhat at being &#8220;Haskell Lite&#8221;,
it really strives to be <em>safer C++</em><sup id="fnref:7"><a class="footnote-ref" href="#fn:7" rel="footnote">7</a></sup>.</p>
<p>But if, on the other hand, you regard <span class="caps">FP</span> mostly as a curiosity
that seems to be seeping into your favorite imperative language at an increasing rate,
Rust can be a good way to gain familiarity with this peculiar&nbsp;beast.</p>
<p>At the very least, you will learn the functional way of <em>modeling programs</em>,
with lots of smart enums/unions and structs but without&nbsp;inheritance.</p>
<p>And the best part is: you will be so busy
<a href="https://m-decoster.github.io//2017/01/16/fighting-borrowchk/">fighting the borrow checker</a>
you won&#8217;t even notice when it happens&nbsp;;-)</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Just ask in <code>#haskell-beginners</code> on Freenode if you&#8217;re interested.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Though ironically,
I found the <a href="https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_"><span class="caps">CT</span> lectures by Bartosz Milewski</a>
very helpful in developing the right intuitions, even though they&#8217;re very abstract.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>For example, Haskell has <em>green threads</em> (created with <code>forkIO</code>)
which are somewhat similar to goroutines from Go.
To get anything remotely similar in Rust, you need to use <a href="http://tokio.rs">external libraries</a>.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>Note that such containers aren&#8217;t very idiomatic Haskell.
A more typical solution would be to just curry the <code>draw</code> function,
implicitly putting the <code>Draw</code> object inside its closure.&#160;<a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:5">
<p>This mechanisms expands to
<a href="https://doc.rust-lang.org/1.6.0/book/associated-constants.html">associated constants</a>
in Rust 1.20.&#160;<a class="footnote-backref" href="#fnref:5" rev="footnote" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:6">
<p>Those two types also have a form of <em>monadic bind</em> (<code>&gt;&gt;=</code> in Haskell)
exposed as <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then">the <code>and_then</code> method</a>.&#160;<a class="footnote-backref" href="#fnref:6" rev="footnote" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:7">
<p>If you want another language for easing into the concept of functional programming,
I&#8217;ve heard that Scala fills that niche quite well.&#160;<a class="footnote-backref" href="#fnref:7" rev="footnote" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/programming/rust-into-haskell.html#rust-into-haskell">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/programming/long-live-dynamic-languages.html#long-live-dynamic-languages">Long Live Dynamic&nbsp;Languages!</a></h2>
    <p>
      Posted on Wed 24 May 2017 in <a href="http://xion.io/category/programming.html">Programming</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/python.html">Python</a>,      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/dynamic-languages.html">dynamic languages</a>,      <a href="http://xion.io/tag/dynamic-typing.html">dynamic typing</a>,      <a href="http://xion.io/tag/static-typing.html">static typing</a>      &#8226; <a href="http://xion.io/post/programming/long-live-dynamic-languages.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>If you followed the few (or a dozen) of my recent posts,
you&#8217;ve probably noticed a sizable bias in the choice of topics.
The vast majority were about <a href="http://rust-lang.org">Rust</a> &#8212;
a native, bare metal, statically typed language with powerful compile time semantics
but little in the way of runtime&nbsp;flexibility.</p>
<p>Needless to say, Rust is radically different than (almost the exact opposite of) Python,
the other language that I&#8217;m covering sometimes.
Considering this topical shift,
it would fair to assume that I, too, have subscribed to the whole Static Typingâ„¢&nbsp;trend.</p>
<p>But that wouldn&#8217;t be very&nbsp;accurate.</p>
<p>Don&#8217;t get me wrong.
As far as fashion cycles in the software industry go,
the current trend towards static/compiled languages is difficult to disparage.
Strong in both hype <em>and</em> merit,
it has given us some <a href="http://rust-lang.org">really innovative</a>
<span class="amp">&amp;</span> <a href="https://www.typescriptlang.org/">promising</a> solutions
(as well as some <a href="http://golang.org">not-so-innovative</a> ones)
that are poised to shape the future of programming for years, if not decades to come.
In many ways, it is also correcting mistakes of <a href="https://www.java.com/en/">the previous generation</a>:
excessive boilerplate, byzantine abstractions, and software&nbsp;bloat.</p>
<p>What about dynamic languages, then?
Are they slowly going the way of the&nbsp;dodo?</p>
<h4>Trigger warning: <code>TypeError</code></h4>
<p>Some programmers would certainly wish&nbsp;so.</p>
<p>Indeed, it&#8217;s not hard at all to find
<a href="https://arstechnica.com/information-technology/2014/06/why-do-dynamic-languages-make-it-difficult-to-maintain-large-codebases/">articles</a>
and <a href="https://www.reddit.com/r/rust/comments/6aqksm/rust_productivity_compared_to_other_languages/dhgp037/">opinions</a>
about dynamic languages that are, well, less than&nbsp;flattering.</p>
<p>The common argument echoed in those accounts points to supposed unsuitability of Python et al.
for any large, multi-person project.
The reasoning can be summed up as &#8220;good for small scripts and not much else&#8221;.
Without statically checked types, the argument goes,
anything bigger than a quick hack or a prototype
shall inevitably become hairy and dangerous&nbsp;monstrosity.</p>
<p>And when that happens,
<em>a single typo</em> can go unchecked and bring down the entire&nbsp;system!&#8230;</p>
<p>At the very end of this spectrum of beliefs,
some pundits may eventually make the leap from languages to <em>people</em>.
If dynamically typed languages (or &#8220;untyped&#8221; ones, as they&#8217;re often mislabeled)
are letting even trivial bugs through,
then obviously anyone who wants to use them is
<a href="https://danluu.com/images/empirical-pl/pl_godwin.png">dangerously irresponsible</a>.
It must follow that all they <em>really</em> want is to hack up some shoddy code,
<em>yolo</em> it over to production, and let others worry about the&nbsp;consequences.</p>
<h4>Mind the&nbsp;gap</h4>
<p>It&#8217;s likely unproductive to engage with someone who&#8217;s that extreme.
If the rhetoric is dialed down, however, we can definitely find the edge of&nbsp;reason.</p>
<p>In my opinion, this fine line goes right through the &#8220;good in small quantities&#8221; argument.
I can certainly understand the apprehension towards large projects
that utilize dynamically typed languages throughout their codebases.
The prospect of such a project <em>is</em> scary,
because it contains an additional element of uncertainty.
More so than with many other technologies,
you ought to <em>know what you&#8217;re doing</em>.</p>
<p>Some people (and teams) do. Others, not so&nbsp;much.</p>
<p>I would therefore refine the argument
so that it better reflects the strengths and weaknesses of dynamic languages.
They are perfectly suited for at least the following&nbsp;cases:</p>
<ul>
<li>anyone writing small, standalone applications or&nbsp;scripts</li>
<li><em>any project</em> (large or small) with a well-functioning team of talented&nbsp;individuals</li>
</ul>
<p>The sad reality of the software industry is the vast, gaping chasm of calamity and despair
that stretches between those two&nbsp;scenarios.</p>
<p>Within lies the bulk of commercial software projects,
consistently hamstrung by the usual suspects:
incompetent management, unclear and shifting requirements, under- or overstaffing,
ancient development practices, lack of coding standards, rampant bureaucracy,
<a href="http://www.daedtech.com/how-developers-stop-learning-rise-of-the-expert-beginner/">inexperienced developers</a>,
and so&nbsp;on.</p>
<p>In such an environment,
it becomes nigh impossible to capitalize on the strengths of dynamic languages.
Instead, the main priority is to protect from even further productivity losses,
which is what bog-standard languages like Java, C#, or Go tend to be pretty good at.
Rather than to move fast, the objective is to remain moving <em>at all</em>.</p>
<h4>Freedom of&nbsp;choice</h4>
<p><span class="dquo">&#8220;</span>But that&#8217;s backwards&#8221;, the usual retort goes.
&#8220;Static typing and compilation checks are what <em>enables</em> me to be&nbsp;productive!&#8221;</p>
<p>I have no doubt that most people saying this do indeed believe
they&#8217;re better off programming in static languages.
Regardless of what they think, however,
there exists <a href="https://danluu.com/empirical-pl/">no conclusive evidence</a>
to back up such claims as a universal&nbsp;rule.</p>
<p>This is of course the perennial problem with software engineering in general,
and the project management aspect of it in particular.
There is very little proper research on optimal and effective approaches to it,
which is why any of the so-called &#8220;best practices&#8221;
are quite likely to stem from <a href="https://leanpub.com/leprechauns">unsubstantiated hearsay</a>.</p>
<p>We can lament this state of affairs, of course.
But on the other hand, we can also find it <em>liberating</em>.
In the absence of rigid prescriptions and judgments about productivity,
we are free to explore, within technical limitations,
what language works best for us, our team, and our&nbsp;projects.</p>
<p>Sometimes it&#8217;ll be Go, Java, Rust, or even Haskell.<br>
A different situation may be best handled by Python, Ruby, or even&nbsp;JavaScript.</p>
<p>As the old adage goes, there is no silver bullet.
We should not try to polish static typing into&nbsp;one.</p>
      <a class="btn" href="http://xion.io/post/programming/long-live-dynamic-languages.html#long-live-dynamic-languages">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/programming/rust-async-closer-look.html#rust-async-closer-look">Asynchronous Rust for fun <span class="amp">&amp;</span>&nbsp;profit</a></h2>
    <p>
      Posted on Fri 28 April 2017 in <a href="http://xion.io/category/programming.html">Programming</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/async.html">async</a>,      <a href="http://xion.io/tag/tokio.html">Tokio</a>,      <a href="http://xion.io/tag/futures.html">futures</a>,      <a href="http://xion.io/tag/http.html">HTTP</a>      &#8226; <a href="http://xion.io/post/programming/rust-async-closer-look.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p><em>&#8230;or: Is Rust&nbsp;webscale?</em></p>
<p>In this day and age, no language can really make an impact anymore
unless it enables its programmers to harness the power of the Internet.
<a href="https://www.rust-lang.org/en-US/">Rust</a> is no different here.
Despite posing as a true systems language
(as opposed to those <a href="http://golang.org/">only marketed as such</a>),
it includes <a href="https://github.com/aturon/rfcs/blob/roadmap-2017/text/0000-roadmap-2017.md#rust-should-be-well-equipped-for-writing-robust-high-scale-servers">highly scalable servers</a>
as a prominent objective in its 2017&nbsp;agenda.</p>
<p>Presumably to satisfy this very objective,
the Rust ecosystem has recently seen some major developments
in the space of <em>asynchronous I/O</em>.
Given the pace of those improvements,
it may seem that production quality async services are quite possible&nbsp;already.</p>
<p>But is that so?
How exactly do you write async Rust servers in the early to mid&nbsp;2017?</p>
<p>To find out, I set to code up a toy application.
Said program was a small intermediary/<span class="caps">API</span> server (a &#8220;microservice&#8221;, if you will)
that tries to hit many of the typical requirements that arise in such projects.
The main objective was to test the limits of asynchronous Rust,
and see how easily (or difficult) they can be&nbsp;pushed.</p>
<p>This post is a summary of all the lessons I&#8217;ve learned from&nbsp;that.</p>
<p>It is necessarily quite long,
so if you look for some <span class="caps">TL</span>;<span class="caps">DR</span>, scroll down straight to <em>Conclusions</em>.</p>
<p align="center"><img src="http://xion.io/images/jump-to-conclusions-mat.jpeg"></p>

<h4>Asynchro-what?</h4>
<p>Before we dive in, I have to clarify what &#8220;asynchronous&#8221; means in this context.
Those familiar with async concepts can freely skip this&nbsp;section.</p>
<h5>Pulling some&nbsp;threads</h5>
<p>Asynchronous processing (or <em>async</em> for short) is brought up most often
in the context of I/O operations: disk reads, network calls, database queries,
and so&nbsp;on.</p>
<p>Relatively speaking, all those tasks tend to be <em>slow</em>:
they take orders of magnitude longer than just executing code or even accessing <span class="caps">RAM</span>.
The &#8220;traditional&#8221; (synchronous) approach to dealing with them
is to relegate those tasks to separate <em>threads</em>.</p>
<p>When one thread has to wait for a lengthy I/O operation to complete,
the operating system (its <em>scheduler</em>, to be precise) can suspend that thread.
This lets others execute their code in the mean time and not waste <span class="caps">CPU</span>&nbsp;cycles.</p>
<p>This is the essence of <em>concurrency</em><sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>.</p>
<h5>Schedule&nbsp;yourself</h5>
<p>But threads are not the only option when dealing with many things (i.e. requests) at&nbsp;once.</p>
<p>The alternative approach is one where no threads are automatically suspended or resumed
by the <span class="caps">OS</span>. Instead, a special version of I/O subroutines
allows the program to continue execution immediately after issuing an I/O call.
While the operation happens in the background<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>,
the code is given an opaque handle &#8212; usually called a promise, a <em>future</em>,
or an async result &#8212; that will eventually resolve to the actual return&nbsp;value.</p>
<p>The program can wait for the handle synchronously,
but it would typically hand it over to an <em>event loop</em>,
an abstraction provided by a dedicated async framework.
Such a framework (among which node.js is probably the best known example)
maintains a list of all I/O &#8220;descriptors&#8221; (fds in Unix)
that are associated with pending I/O&nbsp;operations.</p>
<p>Then, in the loop, it simply waits on <em>all</em> of them,
usually via the <a href="https://en.wikipedia.org/wiki/Epoll"><code>epoll</code> system call</a>.
Whenever an I/O task completes, the loop would execute a <em>callback</em> associated
with its result (or promise, or future).
Through this callback, the application is able to process&nbsp;it.</p>
<p>In a sense, we can treat the event loop as a dedicated scheduler for its&nbsp;program.</p>
<h5>But&nbsp;why?</h5>
<p>So, what exactly the benefit of asynchronous I/O?
If anything, it definitely sounds more complicated for the programmer. (Spoiler alert: it&nbsp;is).</p>
<p>The impetus for the development of async techniques most likely came from
the <a href="http://www.kegel.com/c10k.html"><span class="caps">C10K</span> problem</a>.
The short version of it is that computers are nowadays very fast
and should therefore be able to serve thousands of requests simultaneously.
(especially when those requests are mostly I/O, which translate to waiting time for the <span class="caps">CPU</span>).</p>
<p>And if &#8220;serving&#8221; queries is indeed almost all waiting,
then handling thousands of clients should be very&nbsp;possible.</p>
<p>In some cases, however, it was found that when the <span class="caps">OS</span> is scheduling the threads,
it introduces too much overhead on the frequent pause/resume state changes (<em>context switching</em>).
Like I mentioned above, the asynchronous alternative does away with all that,
and indeed lets the <span class="caps">CPU</span> just wait (on <code>epoll</code>) until something interesting happens.
Once it does, the application can deal with it quickly,
issue another I/O call, and let the server go back to&nbsp;waiting.</p>
<p>With today&#8217;s processing power we can theoretically handle
<em>a lot</em> of concurrent clients this way: up to hundreds of thousands or even&nbsp;millions.</p>
<h5>Reality&nbsp;check</h5>
<p>Well, ain&#8217;t that grand? No wonder everyone is writing everything in node.js&nbsp;now!</p>
<p>Jokes aside, the <em>actual</em> benefits of asynchronous I/O
(especially when weighed against its inconvenience for developers)
are a bit harder to quantify.
For one, they rely heavily on the assumption of fast code <span class="amp">&amp;</span> slow I/O being valid in all&nbsp;situations.</p>
<p>But this isn&#8217;t really self-evident, and becomes increasingly dubious as time goes on
and code complexity grows.
It should be obvious, for example, that a Python web frontend
talking mostly to in-memory caches in the same datacenter will have radically different
performance characteristics than a C++ proxy server calling <span class="caps">HTTP</span> APIs over public Internet.
Those nuances are often lost in translation between simplistic benchmarks
and exaggerated blog posts<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>.</p>
<p>Upon a closer look, however, these details point quite clearly in favor of asynchronous Rust.
Being a language that compiles to native code, it should usually run faster
than interpreted (Python, Ruby) or even JITed (<span class="caps">JVM</span> <span class="amp">&amp;</span> .<span class="caps">NET</span>) languages,
very close to what is typically referred to as &#8220;bare metal&#8221; speed.
For async I/O, it means the event loop won&#8217;t be disturbed for a (relatively) long time
to do some trivial processing, leading to higher potential throughput of&nbsp;requests.</p>
<p>All in all, it would seem that Rust is one of the few languages
where async actually <em>makes sense</em>.</p>
<h4>Rust: the story so&nbsp;far</h4>
<p>Obviously, this means it&#8217;s been built into the language right from the start&#8230;&nbsp;right?</p>
<p>Well, not really.
It was always possible to use native <code>epoll</code> through <a href="https://doc.rust-lang.org/book/ffi.html"><span class="caps">FFI</span></a>,
of course, but that&#8217;s not exactly the level of abstraction we&#8217;d like to work with.
Still, the upper layers of the async I/O stack have been steadily growing at least since Rust&nbsp;1.0.</p>
<p>The major milestones here include <a href="https://docs.rs/mio"><em>mio</em></a>,
a comparatively basic building block that provides an asynchronous version of <span class="caps">TCP</span>/<span class="caps">IP</span>.
It also offers idiomatic wrappers over <code>epoll</code>, allowing us to write our own event&nbsp;loop.</p>
<p>On the application side, <a href="https://docs.rs/futures">the <em>futures</em> crate</a> abstracts the notion
of a potentially incomplete operation into, well, a <em>future</em>.
Manipulating those futures is how one can now write asynchronous code in&nbsp;Rust.</p>
<p>More recently, <a href="http://tokio.rs">Tokio</a> has been emerging as
<a href="https://blog.mozilla.org/blog/2017/04/10/mozilla-awards-365000-to-open-source-projects-as-part-of-moss/"><em>defacto</em> framework</a>
for async I/O in Rust. It essentially combines the two previously mentioned crates,
and provides additional abstractions specifically for network clients and&nbsp;servers.</p>
<p>And finally, the popular <span class="caps">HTTP</span> framework <a href="http://hyper.rs">Hyper</a> is now also supporting
asynchronous request handling via Tokio.
What this means is that bread-and-butter of the Internet&#8217;s application layer &#8212;
<span class="caps">API</span> servers talking <span class="caps">JSON</span> over <span class="caps">HTTP</span> &#8212; should now be fully supported by the ecosystem
of asynchronous&nbsp;Rust.</p>
<p>Let&#8217;s take it for a spin then, shall&nbsp;we?</p>
<h4>The Grand&nbsp;Project</h4>
<p>Earlier on, we have established that the main use case for asynchronous I/O
is intermediate microservices.
They often sit somewhere between a standard web frontend and a storage server or a database.
Because of their typical role within a bigger system,
these kinds of projects don&#8217;t tend to be particularly exciting on their&nbsp;own.</p>
<p>But perhaps we can liven them up a&nbsp;little.</p>
<p>In the end, it is all about the Internet that we&#8217;re talking here,
and everything on the Internet can usually be improved by one simple&nbsp;addition.</p>
<p align="center">
    <img src="http://xion.io/images/smoothie.jpeg">
    <br/>
    <small style="text-side: xx-small">
        <a href="http://www.boredpanda.com/beautiful-fluffy-cat-british-longhair/">
            Image source
        </a>
    </small>
</p>

<p>&#8230;Okay, <em>two</em> possible additions &#8212; the other one&nbsp;being:</p>
<p align="center"><img src="http://xion.io/images/oprah-memes.png" alt="Memes!"></p>

<p>If you&#8217;re really pedantic, you may call them <em>image macros</em>.
But regardless of the name, the important part is putting text on pictures,
preferably in a funny&nbsp;way.</p>
<p><a href="https://github.com/Xion/rofld">The microservice I wrote</a> is doing just that.
Thought it won&#8217;t ensure your memes are sufficiently hilarious,
it will try to deliver them exactly to
<a href="https://github.com/Xion/rofld/blob/e25e9d01bdd7e85452e6a5922770dae941d5b61c/src/caption/mod.rs#L32">your specifications</a>.
You may thus think of it as possible backend for
<a href="http://www.quickmeme.com/caption">an image site like this one</a>.</p>
<h5>Flimsy excuses <span class="amp">&amp;</span> post-hoc&nbsp;justifications</h5>
<p>It is, of course, a <em>complete</em> coincidence,
lacking <em>any</em> premeditation on my part,
that when it comes to evaluating an async platform,
a service like this fits the bill <em>very well</em>.</p>
<p>And especially when said platform is async <em>Rust</em>.</p>
<p>Why, though, is it such a happy, er,&nbsp;accident?</p>
<ul>
<li>
<p><strong>It&#8217;s a simple, well-defined application</strong>.
  There is basically a <a href="https://github.com/Xion/rofld/blob/e25e9d01bdd7e85452e6a5922770dae941d5b61c/src/service.rs#L33">single endpoint</a>,
  accepting simple input (<span class="caps">JSON</span> or query string) and producing a straightforward result (an image).
  No need to persist any state made creating
  <a href="https://github.com/Xion/rofld/blob/8026eab34ea54c4ba1b814c1114b3f5d87020233/src/main.rs">an <span class="caps">MVP</span></a>
  significantly&nbsp;easier.</p>
</li>
<li>
<p><strong>Caching can be used for meme templates and fonts.</strong>
  Besides being an inherent part of most network services,
  a cache also represents a point of contention for Rust programs.
  The language is widely known for its alergy to global mutable state,
  which is exactly what programmatic caches boil down&nbsp;to.</p>
</li>
<li>
<p><strong>Image captioning is a <span class="caps">CPU</span>-intensive operation.</strong>
  While the &#8220;async&#8221; part of async I/O may sometimes go all the way down,
  many practical services either evolve some important <span class="caps">CPU</span>-bound code,
  or require it right from the start.
  For this reason, I wanted to check if <span class="amp">&amp;</span> how async Rust can mix
  with threaded&nbsp;concurrency.</p>
</li>
<li>
<p><strong>Configuration knobs can be added.</strong>
  Unlike trivial experiments in the vein of an echo or &#8220;Hello world&#8221; server,
  this kind of service warrants some flags that the user could tweak,
  like the number of image captioning threads, or the size of the template cache.
  We can see how easy (or how hard) it is to make them applicable across
  all future-based&nbsp;requests.</p>
</li>
</ul>
<p>All in all, and despite its frivolous subject matter,
a meme server is actually hitting quite a few notable spots in the microservice&nbsp;domain.</p>
<p align="center">
    <img src="http://xion.io/images/meme-shocked.png" alt="">
</p>

<h4>Learnings</h4>
<p>As you may glean from its <a href="https://github.com/Xion/rofld">GitHub repo</a>,
it would seem that the experiment was successful.
Sure, you could implement some features in the captioning department
(supporting animated GIFs comes to mind),
but none of these are pertinent to the async mechanics of the&nbsp;server.</p>
<p>And since it&#8217;s the async (I/O) in Rust that we&#8217;re interested in,
let me now present you with an assorted collection of practical experiences with&nbsp;it.</p>
<h5>&gt;0-cost&nbsp;futures</h5>
<p>If you read the docs&#8217; preamble to <a href="https://docs.rs/futures">the <code>futures</code> crate</a>,
you will see it mentioning the &#8220;zero-cost&#8221; aspect of the library.
Consistent with the philosophy behind Rust,
it proclaims to deliver its abstractions without any&nbsp;overhead.</p>
<p>Thing is, I&#8217;m not sure how this promise can be delivered on in&nbsp;practice.</p>
<p>Flip through <a href="https://tokio.rs/docs/getting-started/simple-server/">the introductory tutorial to Tokio</a>,
for example, and you will already find plenty of compromises.
Without the crucial (but nightly-only)
<a href="https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md"><code>impl Trait</code> feature</a>,
you are basically required to put all your futures in a <code>Box</code><sup id="fnref:4"><a class="footnote-ref" href="#fn:4" rel="footnote">4</a></sup>.
They even encourage it themselves, offering a convenient
<a href="https://docs.rs/futures/0.1.13/futures/future/trait.Future.html#method.boxed"><code>Future::boxed</code> method</a>
exactly for this purpose, as well the matching
<a href="https://docs.rs/futures/0.1.13/futures/future/type.BoxFuture.html"><code>BoxFuture</code> typedef</a>
right in the&nbsp;crate.</p>
<p>But hey, you can always just use nightly Rust, right?
<code>impl Trait</code> will stabilize eventually, so your code should be, ahem, <em>future-proof</em> either&nbsp;way.</p>
<p>Unfortunately, this assumes all the futures that you&#8217;re building your request handlers from
shall never cross any thread boundaries.
(<code>BoxFuture</code>, for example, automatically constrains them to be <code>Send</code>).
As you&#8217;ve likely guessed, this doesn&#8217;t jive very well with computationally intensive tasks
which are best relegated to a separate&nbsp;thread.</p>
<p>To deal with them properly, you&#8217;re going to need a thread pool-based executor,
which is currently implemented in the <a href="https://docs.rs/futures-cpupool"><code>futures_cpupool</code> crate</a>.
Using it requires a lot of care, though,
and a deep understanding of <em>both</em> types of concurrency&nbsp;involved.</p>
<p>Evidently, this was something that I lacked at the time,
which is why I encountered problems ensuring that my futures are properly <code>Send</code>.
In the end, I settled on <em>making</em> them <code>Send</code> in the most straightforward
(and completely <a href="https://github.com/Xion/rofld/commit/19d37cef4bb2e917e54c862ef138c7da4378d03e">unnecessary</a>) manner:
by <a href="https://github.com/Xion/rofld/blob/7e7d3b160594689d2e4c80b7328f90f34546b955/src/ext.rs#L39">wrapping them in <code>Arc</code>/<code>Mutex</code></a>.
That in itself wasn&#8217;t
<a href="https://github.com/Xion/rofld/commit/15bcd60f76a97badb9b90721179daa0845b139dd#diff-126a37e2b594610dd09c3f228d9d1717L52">without its perils</a>,
but at least allowed me to move&nbsp;forward.</p>
<p>Ironically, this also shows an important, pragmatic property of the futures&#8217; system:
sub-par hacks around it <em>are</em> possible &#8212;
a fact you&#8217;ll be glad to know about on the proverbial day before a&nbsp;deadline.</p>
<h5>Templates-worthy error&nbsp;messages</h5>
<p>Other significant properties of the futures&#8217; abstraction shall include
telling the programmer what&#8217;s wrong with his code in the simplest,
most straightforward, and concise manner&nbsp;possible.</p>
<p>Here, let me show you an&nbsp;example:</p>
<p align="center">
    <img src="http://xion.io/images/rust-futures-error.png"><br>
    <small>
        &#8230;which you can also behold in its
        <a href="https://gist.github.com/Xion/df1fb7fffa1afb4bfbf2838b9c3fc4c1">
            gist form
        </a>.
    </small>
</p>

<p>The reason you will encounter such incomprehensible messages
stems from the very building blocks of async&nbsp;code.</p>
<p>Right now, each chained operation on a future &#8212; <code>map</code>, <code>and_then</code>, <code>or_else</code>, and so on &#8212;
produces a <em>nested type</em>.
Every subsequent application of those methods
&#8220;contains&#8221; (in terms of the type system) <em>all the previous ones</em>.
Keep going, and it will eventually balloon into one big onion of <code>Chain&lt;Map&lt;OrElse&lt;Chain&lt;Map&lt;...etc...&gt;&gt;&gt;&gt;&gt;</code>.</p>
<p align="center">
    <img src="http://xion.io/images/meme-yo-dawg.jpeg"><br>
    <small>Futures are like ogres.</small>
</p>

<p>I haven&#8217;t personally hit any compiler limits in this regard,
but I&#8217;m sure it is plausible for a complicated, real-world&nbsp;program.</p>
<p>It also gets <em>worse</em> if you use nightly Rust with <code>impl Trait</code>.
In this case, function boundaries no longer &#8220;break&#8221; type stacking
via <code>Box</code>ing the results into trait objects.
Indeed, you can very well end up with some truly gigantic constructs
as the compiler tries represent the return types of your most complex&nbsp;handlers.</p>
<p>But even if rustc is up to snuff and can deal with those fractals just fine,
it doesn&#8217;t necessarily mean the <em>programmer</em> can.
Looking at those error messages,
I had vivid flashbacks from hacking on C++ templates with ancient compilers like <span class="caps">VS2005</span>.
The difference is, of course, that we&#8217;re not trying any arcane metaprogramming here;
we just want to do some relatively mundane&nbsp;I/O.</p>
<p>I have no doubt the messaging will eventually improve,
and the mile-long types will at least get pretty-printed.
At the moment, however, prepare for some serious squinting and&nbsp;bracket-counting.</p>
<h5>Where is my (language)&nbsp;support?</h5>
<p>Sadly, those long, cryptic error messages are not the only way
in which the Rust compiler disappoints&nbsp;us.</p>
<p>I keep mentioning <code>impl Trait</code> as a generally desirable language feature
for writers of asynchronous code.
This improvement is still a relatively long way from getting precisely
<a href="https://github.com/aturon/rfcs/blob/expand-impl-trait/text/0000-expand-impl-trait.md"><em>defined</em></a>,
much less stabilized.
And it is only a somewhat minor improvement in the async&nbsp;ergonomics.</p>
<p>The wishlist is vastly longer and even more&nbsp;inchoate.</p>
<p>Saying it bluntly, right now Rust doesn&#8217;t really support the async style <em>at all</em>.
All the combined <span class="caps">API</span> surface of futures/Tokio/Hyper/etc. is a clever,
but ultimately contrived design,
and it has no intentional backing in the Rust language&nbsp;itself.</p>
<p>This is a stark contrast with numerous other languages.
They often support asynchronous I/O as something of a first class feature.
The list includes at least
<a href="https://msdn.microsoft.com/en-us/library/mt674882.aspx">C#</a>,
<a href="https://docs.python.org/3/library/asyncio-task.html">Python 3.5+</a>,
<a href="https://docs.hhvm.com/hack/async/awaitables">Hack/<span class="caps">PHP</span></a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function"><span class="caps">ES8</span> / JavaScript</a>,
and basically all the functional languages.
They all have dedicated <code>async</code>, <code>await</code>, or equivalent constructs
that make the callback-based nature of asynchronous code essentially&nbsp;transparent.</p>
<p>The absence of similar support puts Rust in the same bucket as frontend JavaScript circa 2010,
where <code>.then</code>-chaining of promises reigned supreme.
This is of course better than the callback hell of early Node,
but I wouldn&#8217;t think that&#8217;s a particularly high bar.
In this regard, Rust leaves plenty to be&nbsp;desired.</p>
<p>There are <a href="https://github.com/vadimcn/rfcs/blob/coroutines2/text/0000-coroutines.md">proposals</a>,
obviously, to bring async coroutines into Rust.
There is an even broader wish to make the language cross the <span class="caps">OOP</span>/<span class="caps">FP</span> fence already
and commit to the functional way; this would mean adding an equivalent of Haskell&#8217;s <code>do</code> notation.</p>
<p>Either development could be sufficient.
Both, however, require significant amount of design and implementation work.
If solved now, this would easily be the most significant addition to the language
since its 1.0 release &#8212; but the solution is currently in the <span class="caps">RFC</span> stages <em>at best</em>.</p>
<h5>Future&lt;Ecosystem&gt;</h5>
<p>While the core language support is lacking,
the great as usual Rust community has been picking up some of the slack
by establishing and cultivating a steadily growing&nbsp;ecosystem.</p>
<p>The constellation of async-related crates clusters mostly around the two core libraries:
<code>futures</code> crate itself and Tokio.
Any functionality you may need while writing asynchronous should likely be found
quite easily by searching for one of those two keywords (plus Rust, of course).
Another way of finding what you need is to look at
<a href="https://tokio.rs/docs/going-deeper-tokio/third-party/">the list of Tokio-related crates</a>&nbsp;directly.</p>
<p>To be fair, I can&#8217;t really say much about the completeness of this ecosystem.
The project didn&#8217;t really require too many external dependencies &#8212;
the only relevant ones&nbsp;were:</p>
<ul>
<li><code>futures_cpupool</code> mentioned&nbsp;before</li>
<li><code>tokio-timer</code> for imposing a timeout on caption&nbsp;requests</li>
<li><code>tokio-signal</code> which handles <span class="caps">SIGINT</span>/Ctrl+C  and allows for a graceful&nbsp;shutdown</li>
</ul>
<p>Normally, you&#8217;d also want to research the async database drivers
for your storage system of choice.
I would not expect anything resembling the <a href="http://diesel.rs">Diesel</a> <span class="caps">ORM</span> crate, though,
nor a web framework comparable to <a href="http://ironframework.io/">Iron</a>,
<a href="https://fengsp.github.io/pencil/pencil/">Pencil</a>,
or <a href="https://rocket.rs/">Rocket</a>.</p>
<h4>Conclusions</h4>
<p>Alright, so what can we get from this overall&nbsp;analysis?</p>
<p>Given the rapid development of async Rust ecosystem so far,
it is clear the technology is very promising.
If the community maintains its usual enthusiasm and keeps funneling it into Tokio et al.,
it won&#8217;t be long before it matures into something&nbsp;remarkable.</p>
<p>Right now, however, it exposes way too many rough edges to fully bet on it.
Still, there may be some applications
where you could get away with an async Rust backend even in production.
But personally, I wouldn&#8217;t recommend it outside of non-essential services,
or tools internal to your&nbsp;organization.</p>
<p>If you do use async Rust for microservices,
I&#8217;d also advise to take steps to ensure they remain &#8220;micro&#8221;.
Like I&#8217;ve elaborated in the earlier sections,
there are several issues that make future-based Rust code scale poorly
with respect to maintainability.
Keeping it simple is therefore&nbsp;essential.</p>
<p>To sum up, async Rust is currently an option only for the adventurous and/or small.
Others should stick to a tried <span class="amp">&amp;</span> tested solution:
something like Java (with <a href="http://docs.paralleluniverse.co/quasar/">Quasar</a>),
.<span class="caps">NET</span>, Go, or perhaps node.js at the very&nbsp;least.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>It is also the crux of parallelism,
but <a href="https://www.youtube.com/watch?v=cN_DpYBzKso">that&#8217;s different</a> and is not the focus here.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p><span class="dquo">&#8220;</span>Background&#8221; here refers to the low level, innate concurrency of the <span class="caps">OS</span> kernel
(mediated with hardware interrupts), not the <code>epoll</code>-based event loops on the application side.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>There is a great parallel to be drawn between a trivial echo/Hello world server,
and a 3D graphics program that only redraws an empty screen.
Both may start at some very high performance numbers (requests/frames per second)
but once you start adding practical stuff, those metrics must drop <em>hyperbolically</em>.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p><em>Technically</em>, you are not, but the alternative is extremely cumbersome.<br>
In short, you&#8217;d have to follow an approach similar to custom <code>Iterator</code>s:
define a new struct for each individual case
(possibly just <a href="https://doc.rust-lang.org/book/structs.html#tuple-structs">newtype</a>&#8216;ing an existing one),
and then implement the necessary trait for it.<br>
For iterators, this works reasonably well,
and you don&#8217;t need custom ones that often anyway.
But futures, by their very nature, are meant to encapsulate <em>any</em> computation.
For them, &#8220;each individual case&#8221; is literally <em>every asynchronous function</em> in your code.&#160;<a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/programming/rust-async-closer-look.html#rust-async-closer-look">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/programming/rust-nightly-vs-stable.html#rust-nightly-vs-stable">A tale of two&nbsp;Rusts</a></h2>
    <p>
      Posted on Sat 24 December 2016 in <a href="http://xion.io/category/programming.html">Programming</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/rust.html">Rust</a>,      <a href="http://xion.io/tag/nightly-rust.html">nightly Rust</a>,      <a href="http://xion.io/tag/stable-rust.html">stable Rust</a>,      <a href="http://xion.io/tag/rocketrs.html">Rocket.rs</a>      &#8226; <a href="http://xion.io/post/programming/rust-nightly-vs-stable.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>The writing has been on the wall for many months now,
but I think the time has come when we can officially declare&nbsp;it.</p>
<blockquote>
<p>Stable Rust is dead. Nightly Rust is the only&nbsp;Rust.</p>
</blockquote>
<h4>Say&nbsp;what?</h4>
<p>If you&#8217;re out of the loop,
<a href="http://rust-lang.org/">Rust</a> is this newfangled system programming language.
Rust is meant to fit in the niches normally occupied by C,
so its domain includes performance-sensitive and safety-critical applications.
Embedded programming, <span class="caps">OS</span> kernels, databases, servers,
and similar low-level pieces of computing and networking infrastructure
are all within its&nbsp;purview.</p>
<p>Of course, this &#8220;replacing C&#8221; thing is still an ambition that&#8217;s years or decades away.
But in theory, there is nothing preventing it from happening.
The main thing Rust would need here is <em>time</em>: time to buy trust of developers
by having been used in real-world, production scenarios without&nbsp;issues.</p>
<p>To facilitate this (and for other reasons),
Rust has been using <a href="https://doc.rust-lang.org/stable/book/release-channels.html">three <em>release channels</em></a>
with varying frequency of updates.
There are the <em>stable</em>, <em>beta</em>, and <em>nightly</em> Rust.
Of those, beta is pretty much an
<a href="https://en.wikipedia.org/wiki/Software_release_life_cycle#Release_candidate"><span class="caps">RC</span></a>
for a future stable release,
so there aren&#8217;t many differences at all between the first two&nbsp;channels.</p>
<h4>Nightly&nbsp;perks</h4>
<p>This cannot be said about&nbsp;nightly.</p>
<p>In fact, nightly Rust is essentially <em>its own language</em>.</p>
<p>First, there is a number of exclusive language features that are only available on nightly.
They are all guarded by numerous <code>#![feature(...)]</code> gates
which are required to activate them.
Because stable Rust doesn&#8217;t accept any such directive,
trying to compile code that uses them will fail on a non-nightly&nbsp;compiler.</p>
<p>This has been justified as a necessary step for testing out new features
in real scenarios, or at least those that resemble (stable) reality as close as possible.
Indeed, many features <em>did</em> eventually land in stable Rust by going through this route
&#8212; a recent example would be <a href="https://m4rw3r.github.io/rust-questionmark-operator">the <code>?</code> operator</a>,
an error-handling measure analogous to the <code>try!</code> macro.</p>
<p>But some features take a lot of time to stabilize.
And few (like <code>zero_one</code> which guards the numeric traits
<a href="https://doc.rust-lang.org/std/num/trait.Zero.html"><code>Zero</code></a>
and <a href="https://doc.rust-lang.org/std/num/trait.One.html"><code>One</code></a>) may even be deprecated
without ever getting out of the nightly&nbsp;channel.</p>
<h4>Unplugged</h4>
<p>Secondly, and most importantly, there is at least one feature
that won&#8217;t get stabilized <strong>ever</strong>:</p>
<div class="highlight"><pre><span class="cp">#![feature(plugin)]</span><span class="w"></span>
</pre></div>


<p>And it&#8217;s all by&nbsp;design.</p>
<p>This <code>plugin</code> switch is what&#8217;s necessary to include <code>#![plugin(...)]</code> directives.
Those in turn activate <em>compiler plugins</em>:
user-provided additions to the compiler itself.
Plugins operate against the <span class="caps">API</span> provided directly by <code>rustc</code>
and enhance its capabilities beyond what the language normally&nbsp;provides.</p>
<p>Although it sounds rather ominous,
the vast majority of plugins in the wild serve a singular purpose: <em>code generation</em>.
They are written with the sole purpose of combating Rust&#8217;s rigidity,
including the (perfectly expected) lack of dynamic runtime capabilities
and the (disappointingly) stiff limits of its wanting macro&nbsp;system.</p>
<p>This is how they are utilized by <a href="http://diesel.rs/">Diesel</a>, for example,
a popular <span class="caps">ORM</span> and <span class="caps">SQL</span> query interface;
or <a href="https://serde.rs/">Serde</a>, a serialization&nbsp;framework.</p>
<p>Why compiler plugins can never be stable, though?
It&#8217;s because the internal <span class="caps">API</span> they are coded against
goes too deep into the compiler bowels to ever get stabilized.
If it were, it would severely limit the ability to further develop the language
without significant breakage of the established&nbsp;plugins.</p>
<h4>Pseudo-stable</h4>
<p><span class="dquo">&#8220;</span>Wait,&#8221; you may ask, &#8220;how do we even talk about Â«establishedÂ» compiler plugins?
Shouldn&#8217;t they be, by their very definition, <em>unstable</em>?&#8221;</p>
<p>Well&#8230; yes. They definitely should. And therein lies the crux of the&nbsp;problem.</p>
<p>Turns out, plugins <span class="amp">&amp;</span> nightly Rust are only <em>mostly</em> treated as&nbsp;unstable.</p>
<p>In reality, the comfort and convenience provided by nightly versions of many libraries
&#8212; all of which rely on compiler plugins &#8212; is difficult to overstate.
While their stable approximations are available, they at best require rather complicated&nbsp;setup.</p>
<p>What&#8217;s always involved is a custom build step,
and usually a separate file for the relevant code symbols and declarations.
In the end, we get a bunch of autogenerated modules
whose prior non-existence during development may also confuse IDEs and autocompletion&nbsp;tools.</p>
<p>For all those reasons and more,
an ecosystem has developed where several popular libraries are &#8220;nightly but pseudo-stable&#8221;.
This includes some key components in many serious applications,
like the aforementioned <span class="caps">ORM</span> <span class="amp">&amp;</span> serialization&nbsp;crates.</p>
<h4>The&nbsp;precedent</h4>
<p>And so has been the state of affairs until very recently.
The nightly Rust has been offering some extremely enticing features,
but the stable channel was at least paid a lip service to.
However, the mentality among library authors that &#8220;nightly-first&#8221; is an acceptable policy
had been strong for a long time&nbsp;now.</p>
<p>No wonder it has finally shifted towards&nbsp;&#8220;nightly-only&#8221;.</p>
<p>Meet <a href="http://rocket.rs">Rocket</a>,
the latest contestant in the already rich lineup of <a href="http://www.arewewebyet.org/topics/frameworks/">Rust web frameworks</a>.
Everything about it is really slick:
a flashy designer website; approachable and comprehensive documentation;
and concise, <a href="http://flask.pocoo.org/">Flask</a>-like <span class="caps">API</span> for
<a href="https://rocket.rs/overview/#anatomy-of-a-rocket-application">routing</a>
and response handling.
Predictably, it&#8217;s been making quite a
<a href="https://www.reddit.com/r/rust/comments/5jxv6u/rocket_web_framework_for_rust/">buzz</a> on
<a href="https://www.reddit.com/r/programming/comments/5jy64x/rocket_a_web_framework_for_rust/">Reddit</a>
and <a href="https://news.ycombinator.com/item?id=13245475">elsewhere</a>.</p>
<p>There is just an itty bitty little problem: Rocket <em>only works on nightly</em>.
No alternatives, no codegen shims&#8230;
and no prospects of any change in the foreseeable future.
Yet, there doesn&#8217;t seem to be many people concerned about this,
so clearly this is (a new?)&nbsp;norm.</p>
<h4>The Rusts&nbsp;split</h4>
<p>In essence, Rust is now two separate&nbsp;languages.</p>
<p>The stable-nightly divide has essentially evolved into something that closely resembles
the early stages of the <a href="https://wiki.python.org/moin/Python2orPython3">2.x vs. 3.x</a> split in the Python world.
The people still &#8220;stuck&#8221; on 2.7 (i.e. stable) were &#8220;holdouts&#8221;,
and the future was with 3.x (nightly).
Sure, there have been some pithy backports (feature stabilizations),
but the interesting stuff has been happening on the other&nbsp;side.</p>
<p>It&#8217;s astonishing that Rust managed to replicate this phenomenon
without any major version bumps, and with no backwards-incompatible releases.
Technically, everything is still version 1.x..
Not even <a href="http://crates.io">Cargo</a>, the Rust package manager, recognizes the stable-nightly&nbsp;distinction.</p>
<p>But that&#8217;s hardly any consolation when you try to install a nightly-only crate on stable Rust.
You will download it just fine, and get all the way to compiling its code,
only to have it error out due to unsupported <code>#![feature(...)]</code> declarations.</p>
<h4>What&nbsp;now?</h4>
<p>The natural question is, can this situation be effectively&nbsp;addressed?</p>
<p>I hope it&#8217;s obvious why stable Rust cannot suddenly start supporting compiler plugins.
Given that they rely on <code>rustc</code> internals which aren&#8217;t standardized,
doing so would be contrary to the very definition of a &#8220;stable&#8221; release&nbsp;channel.</p>
<p>The other option is to fully embrace nightly as <em>de facto</em> recommended toolchain.
This has been informally happening already,
despite the <a href="https://doc.rust-lang.org/stable/book/release-channels.html#choosing-a-version">contrary recommendations</a>
in the official&nbsp;docs.</p>
<p>The downsides are obvious here, though: nightly Rust is not a misnomer at all.
The compiler is in active development and its build <a href="https://travis-ci.org/rust-lang/rust/builds">breaks often</a>.
Some of those breakages make it into nightly releases with unsatisfying&nbsp;regularity.</p>
<p>Of course, there was also another option:
stick to the intended purpose of release channels and don&#8217;t build castles on the sand
by publishing nightly-first or nightly-only crates.
This ship seems to have sailed by now, as the community has collectively decided&nbsp;otherwise.</p>
<p>Oh&nbsp;well.</p>
<p>It&#8217;s just a little ironic that in a language that is so focused on safety,
everyone is perfectly happy with an <em>unstable compiler</em>.</p>
      <a class="btn" href="http://xion.io/post/programming/rust-nightly-vs-stable.html#rust-nightly-vs-stable">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/programming/python-dont-use-click.html#python-dont-use-click">Please don&#8217;t use&nbsp;Click</a></h2>
    <p>
      Posted on Fri 20 May 2016 in <a href="http://xion.io/category/programming.html">Programming</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/python.html">Python</a>,      <a href="http://xion.io/tag/cli.html">CLI</a>,      <a href="http://xion.io/tag/ui.html">UI</a>,      <a href="http://xion.io/tag/click.html">Click</a>      &#8226; <a href="http://xion.io/post/programming/python-dont-use-click.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p><em>&#8230;not for standalone programs&nbsp;anyway.</em></p>
<p>Chances are, you have written some command line programs in Python. This is quite probable even if you normally code
in some other language. And if you have, it is not unlikely that you needed to parse the <code>argv</code> of your program at one
point or&nbsp;another.</p>
<p>There are plenty of options here, both in the standard library as well as among third party packages. One does stand out,
however, and it&#8217;s mostly for how it is often overused. I&#8217;m talking about <a href="http://click.pocoo.org/">Click</a>&nbsp;here.</p>
<p>If you wanted to use it in your next Python program, I hereby urge you to&nbsp;reconsider.</p>
<h4>What&#8217;s the&nbsp;fuss?</h4>
<p><img style="float:right; margin-left: 8px; margin: bottom: 7px" src="http://xion.io/images/click-logo.png" alt="click_">
The somewhat bizarrely named Click library is described as a &#8220;package for creating beautiful
command line interfaces&#8221;. Its main trick is the ability to create subcommands by adorning Python functions with the
<code>@click.command()</code> decorator<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>. It then makes them coalesce into an argument parser, equipped with the necessary
dispatching&nbsp;logic.</p>
<p>This idea isn&#8217;t new, of course. Prior art goes back at least seven years to the now-abandoned
<a href="https://opster.readthedocs.io">opster</a> package. Click, however, was the first one of its kind to garner noticeable
popularity, which is easily attributed to <a href="http://lucumr.pocoo.org/">whom it&#8217;s been authored by</a>.</p>
<p>So while my arguments against using this kind of <span class="caps">CLI</span> framework would apply to any package implementing the paradigm,
it just happens that Click is currently its most prominent example. Purely for the sake of convenience, I will therefore
refer to it as if it was interchangeable with the whole concept. Because why not? Whatever you may say about
the library&#8217;s name, it&#8217;s hard to imagine a more concise moniker than a simple <em>Click</em>.</p>
<p>What&#8217;s wrong, then, with the way Click handles command line&nbsp;interfaces?</p>
<h4><span class="caps">CLI</span>: Little&nbsp;Interfaces</h4>
<p>It&#8217;s how it encourages to treat them as an <em>accidental afterthought</em> rather than a deliberate design&nbsp;decision.</p>
<p>For applications invoked repeatedly from a terminal, their command line arguments and flags are the primary means of
user interaction<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>. It is how users communicate their intent to perform an action; provide the neccessary input data
to carry it throgh; decide how they want to receive the output; and control many other aspects of the programs execution.
Absent graphical components and widgets, the command line is virtually the only way to interact with a terminal&nbsp;program.</p>
<p>In other words, it is <strong>the <span class="caps">UI</span></strong>.</p>
<p>And how important the <span class="caps">UI</span> is for <em>any</em> application? It seems to be important enough that entire fields of study are devoted
to reducing friction of human-computer interaction. In many projects, the emphasis on user interface design is on par
with that of actual software engineering.<br>
Like everything, of course, it is susceptible to trends and fads (such as the recent &#8220;mobile/responsive everything!&#8221;
craze). But its significance remains undiminished. Quite the opposite: in the age of ubiquitous computing,
user interfaces are probably more important than&nbsp;ever.</p>
<p>Yes, this includes <span class="caps">CLI</span>. One of the main reasons we turn to the command line are <em>speed</em> and <em>efficacy</em>. Common tasks must
utilize short and convenient syntax that is quick to integrate into user&#8217;s muscle memory. Others should not only be
possible, but <em>discoverable</em> and <em>accessible</em> without going through reams of <code>man</code> pages.</p>
<p>Any terminal program intended for frequent use by humans should therefore strive to excel in those two qualities.
But except for <a href="http://linux.die.net/man/1/echo">the simplest of cases</a>, it won&#8217;t happen by itself.
Designing an efficient <span class="caps">CLI</span> for any non-trivial application is a challenging and demanding&nbsp;task.</p>
<h4>It doesn&#8217;t&nbsp;click</h4>
<p>With Click, however, we&#8217;re encouraged to just wing&nbsp;it.</p>
<p>Click tells us to slap some decorators on our top-level functions and call it a day. Sure, you can dig deep enough
and uncover the underlying layers of abstraction that may eventually allow you do things for which <code>argparse</code> has
a <a href="https://docs.python.org/3/library/argparse.html#mutual-exclusion">first-class support</a>.</p>
<p>By default, however, Click shoehorns your programs into
<a href="http://click.pocoo.org/5/quickstart/#basic-concepts">predefined patterns</a> that, incidentally, mirror those of some
<a href="http://click.pocoo.org/5/complex/#building-a-git-clone">least intuitive</a> command-line tools in&nbsp;existence.</p>
<p>Indeed, the whole idea of subdiving your program into several distinct is already suspect, for it appears at odds
with the fundamental Unix philosophy of
<a href="https://en.wikipedia.org/wiki/Unix_philosophy#Do_One_Thing_and_Do_It_Well">doing one thing well</a>. While it is
occasionally justified, it shouldn&#8217;t be the first thing that comes to your mind. But that&#8217;s completely at odds with the
Click&#8217;s approach, where <em>not</em> ending up with multiple distinct commands is something you have to consciously&nbsp;avoid.</p>
<h4>&#8230;though it sometimes&nbsp;might</h4>
<p>So, what <em>am</em> I suggesting you use instead libraries such as Click?&#8230; Nothing outrageous,&nbsp;really.</p>
<p>If you care about your command line interface, consider just using
<a href="https://docs.python.org/3/library/argparse.html">the <code>argparse</code> module</a>. Yes, it will force you to create parser objects,
add arguments <span class="amp">&amp;</span> flags to it, and in general pay some attention to the whole business. When it comes to <span class="caps">UI</span>, it&#8217;s always
good to make it an explicit concern, maybe even sufficient to warrant
<a href="https://github.com/Xion/gisht/blob/e86af37388573f00a4d6f282feca76ead88725d8/gisht/args/parser.py">its own module</a>.</p>
<p>Alternatively, the <a href="https://github.com/docopt/docopt"><code>docopt</code> library</a> provides another take on the <span class="caps">UI</span>-first approach
to <span class="caps">CLI</span>, though it is more limited in its capabilities<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>.</p>
<p>Finally, I&#8217;m not advocating to ditch Click in <em>all</em> scenarios. There&#8217;s plenty of situations when we&#8217;re interested in
getting <em>any</em> <span class="caps">CLI</span> up and running, and not so much in making the most efficient and intuitive interface possible. The prime
example is any kind of automation scripts that are ancillary to some bigger project, like <em>manage.py</em> is in Django<sup id="fnref:4"><a class="footnote-ref" href="#fn:4" rel="footnote">4</a></sup>.
The Python ecosystem doesn&#8217;t really have dedicated task runners that are as featureful as <a href="http://gruntjs.com">Grunt</a>
or <a href="http://gulpjs.com/">Gulp</a>, and that makes Click a viable and compelling option<sup id="fnref:5"><a class="footnote-ref" href="#fn:5" rel="footnote">5</a></sup>.</p>
<p>But for standalone programs whose <span class="caps">CLI</span> is the main interface? Yeah, not&nbsp;really.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Oddly enough, that pair of parentheses seems to be mandatory.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Environment variables and config files deserve a honorary mention, of course. But those are usually derivatives of
the command line arguments, containing e.g. the default values for flags.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>Click&#8217;s <a href="http://click.pocoo.org/5/why/#why-not-docopt-etc">own documentation</a> actually describes quite nicely
how theirs and docopt&#8217;s philosophies differ in a way that&#8217;s consistent with this article.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>Incidentally, this appears to be a major motivation behind creating Click in the first place:
to support web applications built upon on the <a href="http://flask.pocoo.org/">Flask</a> framework, and possibly obviate the need
for extensions such as <a href="http://flask-script.readthedocs.io/en/latest/">Flask-Script</a>.&#160;<a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:5">
<p>This saying, there are some task runners which offer similar experience, like <a href="http://pyinvoke.org">Invoke</a>.&#160;<a class="footnote-backref" href="#fnref:5" rev="footnote" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/programming/python-dont-use-click.html#python-dont-use-click">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/programming/package-management.html#package-management">Package managers&#8217; appreciation&nbsp;day</a></h2>
    <p>
      Posted on Sat 26 March 2016 in <a href="http://xion.io/category/programming.html">Programming</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/packages.html">packages</a>,      <a href="http://xion.io/tag/package-manager.html">package manager</a>,      <a href="http://xion.io/tag/nodejs.html">node.js</a>,      <a href="http://xion.io/tag/npm.html">npm</a>,      <a href="http://xion.io/tag/c.html">C++</a>      &#8226; <a href="http://xion.io/post/programming/package-management.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>By now you have probably heard about the infamous &#8220;npm-gate&#8221; that swept through the developer community
over the last week. It has been
<a href="https://medium.com/@azerbike/i-ve-just-liberated-my-modules-9045c06be67c#.hp7p1aolc">brought up</a>,
<a href="https://medium.com/@mproberts/a-discussion-about-the-breaking-of-the-internet-3d4d2a83aa4d#.rlnh89inz">discussed</a>,
<a href="http://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/">covered</a>,
<a href="http://www.haneycodes.net/npm-left-pad-have-we-forgotten-how-to-program">meta-discussed</a>,
<a href="http://left-pad.io/">satirized</a>, and even featured by
<a href="http://www.businessinsider.com/npm-left-pad-controversy-explained-2016-3">some mainstream media</a>.
Evidently the nerds have managed to stir up some serious trouble again, and it only took them 11 lines of
that strange thing they call&nbsp;&#8220;code&#8221;.</p>
<h4>No good things in small&nbsp;packages</h4>
<p>When looking for a culprit, the one party that everyone pounced on immediately was of course
the <a href="http://npmjs.com">npm</a> itself. With its myriad of packages that could each fit in a tweet, it invites to create
the exact house of cards we&#8217;ve seen&nbsp;collapse.</p>
<p>This serves as a good wake-up call, of course. But it also compels to throw the baby out with the bathwater,
and draw a conclusion that may be a little too far-fetched. Like perhaps declaring the <em>entire idea</em> of
managing dependencies &#8220;the npm way&#8221; suspect. If packages tend to degenerate into something as ludicrous as
<a href="https://www.npmjs.com/package/isarray"><code>isArray</code></a> &#8212; to say nothing of
<a href="https://www.npmjs.com/package/left-pad"><code>left-pad</code></a>, which started the whole debacle &#8212; then maybe this approach
to software reusability has simply bankrupted&nbsp;itself?</p>
<h4>A world without&nbsp;*pm</h4>
<p>I&#8217;m right away responding to that with a resounding &#8220;No!&#8221;. Package management as a concept is not responsible for
the poor decision making of one specific developer collective. And anyone who might think tools like npm do more
harm than good I ask: have you recently written any&nbsp;C++?</p>
<p>See, C++ is the odd one among languages that at least pretend to be keeping up with the times. It doesn&#8217;t present
a package management story at all. That&#8217;s right &#8212; the C++ &#8220;ecosystem&#8221;, as it stands now,&nbsp;has:</p>
<ul>
<li>no package&nbsp;manager</li>
<li>no repository of&nbsp;packages</li>
<li>no unified way of managing&nbsp;dependencies</li>
<li>no way to isolate development environments of different projects from one&nbsp;another</li>
</ul>
<p>Adding any kind of third-party dependency to a C++ project &#8212; especially a portable one, which is allegedly one of C++&#8217;s
strengths &#8212; is a considerable pain, even when it doesn&#8217;t require any additional libraries by itself. And environment
isolation? Some people are using Linux containers (!) for this, which is like dealing with a mosquito by shooting it
with a&nbsp;howitzer.</p>
<p style="text-align: center">
    <img src="http://xion.io/images/carl-sagan.jpg" alt="Billions upon billions of lines"></br>
    <small>To build a C++ binary, you must first build the userspace.</small>
</p>

<p>But hey, at least they can use <code>apt-get</code>,&nbsp;right?&#8230;</p>
<p>So, string padding incidents aside, package managers are absolutely <em>essential</em>. Sure, we can and should discuss
the merits of their particular flavors and implementation details &#8212;like whether it&#8217;s prudent to allow &#8220;delisting&#8221;
of packages. As a whole, however, package managers deserve recognition as a crucial part of modern language tooling
that we cannot really do&nbsp;without.</p>
      <a class="btn" href="http://xion.io/post/programming/package-management.html#package-management">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/programming/dont-interview-like-google.html#dont-interview-like-google">You Don&#8217;t Have to Interview like&nbsp;Google</a></h2>
    <p>
      Posted on Mon 28 December 2015 in <a href="http://xion.io/category/programming.html">Programming</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/google.html">Google</a>,      <a href="http://xion.io/tag/interviews.html">interviews</a>,      <a href="http://xion.io/tag/startups.html">startups</a>,      <a href="http://xion.io/tag/career.html">career</a>,      <a href="http://xion.io/tag/hiring.html">hiring</a>      &#8226; <a href="http://xion.io/post/programming/dont-interview-like-google.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>If you look at discussion forums for people in the <span class="caps">CS</span> industry &#8212;
like <a href="https://www.reddit.com/r/cscareerquestions/">/r/cscareequestions</a> or even just Hacker News &#8212;
you&#8217;ll find lots of talk about the so called <em>Big Four</em>&nbsp;companies.</p>
<p>This is mostly in the context of applying to them, or going through their interview process.
Which of the large software corporations are discussed here tends to fluctuate a little bit,
but both Google and Microsoft are invariably included, with Facebook popping up more often than&nbsp;not.</p>
<p>Because of their privileged positions as very desirable places to work, these companies tend to be taken as models
for others to mimic<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>. Probably the most apparent and direct outcome is the increasing prevalence of
&#8220;Google-style&#8221; interviews, which are now utilized by countless software shops around the&nbsp;world.</p>
<p><em>Whiteboard coding</em> is how they are often called. It is a subject of an intense debate, whether or not they &#8220;work&#8221;,
and adequately assess the engineering aptitude of candidates. If some
<a href="https://twitter.com/mxcl/status/608682016205344768">high profile anecdotes</a> are of any indication, the most common complaint
is that they fail to recognize competence by ignoring previous professional work, open source contributions,
conference talks, and so&nbsp;on.</p>
<p>Instead, the whiteboard interview requires demand showing a &#8220;pure&#8221; problem solving ability
within a relatively short time window, all without some broader context or even the usual tools of the trade:
laptop, editor, and a search&nbsp;engine.</p>
<p>As a Googler who had gone through this process and has now conducted a few of those interviews himself,
I find those complaints mostly valid albeit&nbsp;misdirected.</p>
<p>The problem isn&#8217;t really that Google interviews like it&nbsp;does.</p>
<p>What&#8217;s really the issue is <em>other companies</em> implementing the same process, and not realizing it cannot possibly work for&nbsp;them.</p>
<h4>Somewhat&nbsp;special</h4>
<p>It is important to understand that Google&#8217;s stance on interviewing is influenced by some unique&nbsp;circumstances:</p>
<ul>
<li>
<p>very high and steady influx of potential&nbsp;candidates</p>
</li>
<li>
<p>comparatively long tenure of the average engineer and the general focus on employee&nbsp;retention</p>
</li>
<li>
<p>huge and mostly proprietary software stack working at a scale that almost no others&nbsp;do</p>
</li>
</ul>
<p>From this perspective, it makes sense to utilize cautious hiring strategies that may result in a high ratio
of <em>false negatives</em><sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>. When rejections are cheap but the new hires are supposed to be here for the long run &#8212;
partially because of the long ramp-up time necessary to become productive &#8212; it can be costly to give candidates
the benefit of the&nbsp;doubt.</p>
<p>The last point also explains why proficiency with specific technologies is less useful than
general flexibility grounded in strong fundamentals. To put it shortly, Google prefers you know
<a href="https://en.wikipedia.org/wiki/Computer_science"><span class="caps">CS</span></a> rather than <a href="https://en.wikipedia.org/wiki/Cascading_Style_Sheets"><span class="caps">CSS</span></a>.</p>
<p>Finally, whiteboard coding is just one input to the evaluation process, but it tends to be the most trustworthy one.
Besides programming aptitude, the ideal candidate would show a proven track record of technical leadership while
tackling complex problems that span a broad scope.<br>
Unfortunately, those qualities are difficult to convey <em>efficiently</em> and <em>reliably</em> through the usual industry channels:
a resume, references from previous jobs, GitHub profile,&nbsp;etc.</p>
<h4>Different&nbsp;conditions</h4>
<p>Given the above reasoning as to why &#8220;Google-style&#8221; interviews seem to work well for Google, I hope it&#8217;s evident why
they are likely a poor choice for companies that don&#8217;t share the same characteristics as the Big&nbsp;4.</p>
<p>For one, it is highly unusual for a software shop in today&#8217;s market to command a sizeable pool for qualified candidates.
Software engineering vacancies often go unfilled for weeks and months, even if the company isn&#8217;t exactly looking
for &#8220;rockstars&#8221;, &#8220;ninjas&#8221;, &#8220;gunslingers&#8221;, or whatever the silly term <em>du jour</em> is. Those who meet the requirements
usually have their pick at many different offers,&nbsp;too.</p>
<p>The reality for many companies (especially startups) is also one where they are unable or unwilling to invest much
in the retention of their employees. Because the employment relationship in this industry tends to be quite volatile
(which isn&#8217;t necessarily a bad thing), it often makes sense for companies to look for a near-immediate payoff
when&nbsp;hiring.</p>
<p>We owe it to the prevalent open source technologies that this isn&#8217;t entirely unreasonable. If your software stack
is composed entirely of components that are available in the open, you can probably find engineers who are familiar
with most of them. They can be productive members of your team almost literally from day&nbsp;one!</p>
<h4>Right tool for the&nbsp;job</h4>
<p>The most important observation is that every company is <em>different</em>, and following the One True Best Practiceâ„¢ will likely
prevent you from utilizing the best qualities of your work place. Smaller shops, for example, could take a more personalized
approach to hiring: let candidates actually sit with engineers, solve real-life problems, and have deep technical&nbsp;conversations.</p>
<p>Of course, you may still find whiteboard coding valuable in its own right. Indeed, a simple test for at least
the basic programming skill appears to be a <a href="http://blog.codinghorror.com/why-cant-programmers-program/">necessary sanity check</a>.</p>
<p>But a full suite of difficult technical interviews with tough algorithmic problems that last a better part of the day?
Most likely&nbsp;not.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Some seem to have succeeded to such an extent that you may occasionally hear about &#8220;Big N&#8221;.
This often includes some currently large and/or successful but still &#8220;hip&#8221; startups.
<span class="caps">IT</span> is such a fashion industry sometimes&#8230;&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Though on the flip side, it exacerbates the <a href="https://en.wikipedia.org/wiki/Impostor_syndrome">impostor syndrome</a>
among people who <em>do</em> get hired, as their success could easily be construed as mostly luck.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>
      <a class="btn" href="http://xion.io/post/programming/dont-interview-like-google.html#dont-interview-like-google">Continue reading</a>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="http://xion.io/post/programming/dont-copy-paste-retype.html#dont-copy-paste-retype">Don&#8217;t Copy <span class="amp">&amp;</span> Paste.&nbsp;Retype.</a></h2>
    <p>
      Posted on Sat 03 October 2015 in <a href="http://xion.io/category/programming.html">Programming</a>
      &#8226; Tagged with
      <a href="http://xion.io/tag/problem-solving.html">problem solving</a>,      <a href="http://xion.io/tag/stack-overflow.html">Stack Overflow</a>,      <a href="http://xion.io/tag/typing.html">typing</a>      &#8226; <a href="http://xion.io/post/programming/dont-copy-paste-retype.html#disqus_thread">Leave a comment</a>
    </p>
  </header>
  <div>
      <p>In this day and age, Google and <a href="http://stackoverflow.com">Stack Overflow</a> are quite essential tools for any developer.
Lately, though, the latter seems to be getting some bad rap. On one side, it&#8217;s because of seemingly peculiar
and sometimes alienating <a href="https://medium.com/@johnslegers/the-decline-of-stack-overflow-7cb69faa575d">moderation policies</a>.
But more pertinently, it&#8217;s the apparent rise of a phenomenon that&#8217;s wittily dubbed
&#8220;the <a href="https://www.christianheilmann.com/2015/07/17/the-full-stackoverflow-developer/">full Stack Overflow developer</a>&#8220;.</p>
<p>In a nutshell, individuals deserving to be called that are code slingers who throw software artifacts together mostly by
copying and pasting code samples found in Stack Overflow answers. They may be getting something working pretty quickly,
but they also lack understanding of problems they&#8217;re facing and solutions they&#8217;re using so&nbsp;cheerily.</p>
<p>Of course, not every instance of code Copy Pasta is to be scorned. I&#8217;m pretty sure most people reading this post
(and certainly the person writing it!) are guilty of replicating at least a few snippets from Stack Overflow, verbatim,
in their own codebase. Heck, we may have even done so with nigh zero interest as to why it has been written this way.
Not every technology is intrinsically fascinating, after all, and deadlines are sometimes too close for&nbsp;comfort.</p>
<p>But if so, does it mean we are gradually turning into full Stack Overflow developers?&#8230;
Yikes! Surely we don&#8217;t want that to&nbsp;happen!</p>
<h4>Mitigation&nbsp;tactic</h4>
<p>Before you shut off your Internet connection altogether while coding, consider employing the following technique
whenever you feel like scraping a piece of code from Stack Overflow, and dumping it in your project&nbsp;source.</p>
<p>Don&#8217;t use the clipboard. Don&#8217;t copy and paste. <strong>Retype</strong> the code you&#8217;ve found&nbsp;instead.</p>
<p>It&#8217;s going to take more time, yes. It&#8217;s definitely more cumbersome than just hitting <em>Ctrl+C</em>/<em>Ctrl+V</em>.
It may also make little sense: if the end result is the same, why does it matter whether the code was transfered
through the clipboard or&nbsp;not?</p>
<h4>Rationale</h4>
<p>I&#8217;d argue, however, that it makes perfect sense. From the least to the most important, the reasons why I think so
are the&nbsp;following:</p>
<ul>
<li>
<p>The fact that retyping is slower than copy-pasting is what actually makes it <em>better</em>. If you vow not to use
the clipboard, you&#8217;re much less likely to just pick whatever&#8217;s the first Stack Overflow result Google has given.
You&#8217;ll weigh different solutions, and you&#8217;ll be rightfully biased towards shorter and simpler&nbsp;ones.</p>
</li>
<li>
<p>When you type something, you cannot do it completely thoughtlessly. Whether you want it or not, you&#8217;ll absorb
some of the knowledge through sheer osmosis, because the code will flow through your eyes and fingers as it&#8217;s transfered
from the browser to your editor or <span class="caps">IDE</span>. Your subconscious brain will latch onto the bits and pieces of information,
and it will sort them out for you to use later. Even if you didn&#8217;t intend to, you will most likely <em>learn something</em>.</p>
</li>
<li>
<p>But most importantly, what you type almost certainly won&#8217;t be a perfect copy of the original snippet.
As you progress through the code, you&#8217;ll inevitably deviate from it, if only to conform to a particular style guide
your project is following.<br>
It&#8217;s quite likely, though, that you&#8217;ll make larger changes as well.
You will replace familiar patterns with calls to utility functions.
You&#8217;ll rearrange the code visually for better readability.
You will add comments, or extract functions to make it more self-documenting.
You might even enhance and customize it, so that you can abstract and reuse it multiple&nbsp;times.</p>
</li>
</ul>
<p>Afterwards, what you&#8217;ve just typed won&#8217;t be just some code you have found on the Internet. It&#8217;ll be <em>your code</em>.</p>
      <a class="btn" href="http://xion.io/post/programming/dont-copy-paste-retype.html#dont-copy-paste-retype">Continue reading</a>
  </div>
</article>

  <div class="pagination">
  </div>

    <footer>
<p>
  &copy; Karol Kuczmarski 2017 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-27379564-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Karol Kuczmarski's Blog ",
  "url" : "http://xion.io",
  "image": "http://xion.io/logo.jpeg",
  "description": ""
}
</script><script type="text/javascript">
    var disqus_shortname = 'xionblog';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>