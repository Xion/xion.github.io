<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/font-awesome.min.css">

    <link href="http://xion.io/style.css" rel="stylesheet">




  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

<meta name="author" content="Karol Kuczmarski" />
<meta name="description" content="The nice part about SQLAlchemy — an ORM library/framework for Python — is that it offers much more than just mapping of SQL relations to model classes. At its lower level, for example, there exists an additional layer between those classes and raw SQL queries: an abstraction for the SQL language itself. Although it may sound byzantine at first, this extra layer serves two important purposes: portability: compiling of the same query to potentially different SQL syntaxes, as required by different database backends extensibility: allowing the user to introduce new elements: operators, functions, or even whole statements I’m going to take advantage of both of these qualities here, and show how you can implement support for regular expression operators in query filters. On supported database backends, it will allow for powerful pattern matching on string columns. Database side We will use the Postgres syntax of POSIX regular expression matchers as a reference. It includes four operators: for case sensitive or insensitive matching, in regular or negated versions. Since it’s a common practice to use an in-memory SQLite for running database-involved “unit” tests1, we will also add support for that backend. Regular expressions are not implemented there directly, but thanks to sqlite3‘s custom function ability, it’ll be easy enough to provide the necessary support in Python. Desired API In essence, what we want to do is to enhance the String column type with additional comparators, which will then be usable as arguments for the Query.filter method. As an example, consider the following model class with a string column: class Person(Model): nick = Column(String(255)) # ... Once we’re done, it should be possible to query for e.g. all the people whose nicks contain numbers in a pretty straightforward fashion: numerics = session.query(Person).filter(Person.nick.regexp(r&#39;\d+&#39;)).all() Because of the limitations of underlying databases backends, only literal regular expressions would be supported. It means that, from the SQL standpoint, they have to be constants: you cannot use the value of one column as part of a regular expression that another column is matched against. But of course, you can still construct those literals in Python code: def get_copycats(nick): &#34;&#34;&#34;Return all the people who tried to parrot given nick but failed and had to append some numbers to it. &#34;&#34;&#34; nick_regexp = &#39;^&#39; + re.escape(nick) + r&#39;\d+$&#39; return session.query(Person).filter(Person.nick.regexp(nick_regexp)).all() Considering that regular expressions themselves are already pretty powerful, this really ought to be sufficient for all reasonable purposes. How comparators work? So how do we add the regexp method to the String type? It may seem logical to simply extend the class and add it directly: from sqlalchemy import String as _String class String(_String): &#34;&#34;&#34;Enhanced version of the standard string type.&#34;&#34;&#34; def regexp(self, value): # hmm... But this won’t actually work. In SQLAlchemy, objects like String or Integer do not represent columns of certain type; they correspond to types themselves2. Extending them with additional methods won’t do much good, because regular code rarely operates on column types. On the other hand, though, we obviously don’t want to mess with the Column class itself. Our additions are only meaningful for string columns, but putting them there would expose them to all columns, regardless of type! Thankfully, there is an intermediate mechanism which SQLAlchemy introduced precisely to address the need we’ve got here. Every column type can define a comparator_factory: a kind of mixin class whose methods are incorporated into columns of that type. By overriding this inner class, we can both modify the behavior of existing operators, as well as introduce completely new ones. So in order to add regexp and other methods to all String columns, our new string type must define its own comparator_factory: class String(_String): class comparator_factory(_String.comparator_factory): def regexp(self, other): # ... We need to remember about deriving it from the original one, too. Otherwise, all the standard operators you’d want to use in queries (==, +, etc.) would cease to work, because the new comparator_factory wouldn’t include an implementation of any of the necessary magic methods (__eq__, __add__, etc.). SQL, abstracted Knowing where to put our new comparator methods is certainly desirable, but the more interesting question is how do we implement them? Like I’ve mentioned in the beginning, SQLAlchemy employs an additional layer between ORM models and raw, textual SQL language. Basically, it’s an AST for backend-independent queries which includes almost all of the various SQL constructs, codified in a platform-agnostic way inside the sqlalchemy.sql package. You may have used this layer directly if you ever wrote queries based on Table objects and ran them with Session.execute. But even those constructed using the more familiar Query class interface end up in this intermediate representation. Often there is little to no additional processing involved. Arguments to the Query.filter method, for example, are already given as SQL clause objects. It just so happens that its creation is hidden behind a very neat, operator-based API. Thus, if our regular expression filters are to cooperate, they also need to return pieces of the SQL syntax tree. Not very complicated pieces, mind you, since we only need to represent simple expressions: something like foo ~ &#39;bar&#39;, where ~ may optionally be replaced by one of the other three operators. Creating the node They are all binary operators, by the way (i.e. taking exactly two arguments), so it makes sense that the corresponding AST node class is called BinaryExpression. The node’s children are the left argument, the right argument, and the operator itself. With a little help from a few more SQL syntax wrappers, the implementation of regexp and the other methods turns out to be quite straightforward: from sqlalchemy.sql.expression import BinaryExpression, literal from sqlalchemy.sql.operators import custom_op # (inside String.comparator_factory) def regexp(self, other): return BinaryExpression(self.expr, literal(other), custom_op(&#39;~&#39;)) def iregexp(self, other): return BinaryExpression(self.expr, literal(other), custom_op(&#39;~*&#39;)) def not_regexp(self, other): return BinaryExpression(self.expr, literal(other), custom_op(&#39;!~&#39;)) def not_iregexp(self, other): return BinaryExpression(self.expr, literal(other), custom_op(&#39;!~*&#39;)) The use of literal function is dictated by the limitation that was mentioned earlier: any regular expression given in the query must be a SQL literal. If we now try to pass a column-like clause, we’ll get an exception right at the query definition, rather than a database error when we try to execute it. The custom_op function, on the other hand, is simply the easiest way to create an “operator node” that’s required as a child of BinaryExpression. Since it’s a custom operator, it won’t be interpreted by SQLAlchemy in any way; it will simply be used verbatim in the final SQL string that’s sent to the database. Compile! You may have noticed that this would pose a problem if said database doesn’t support ~ or the other operators, which happens to be the case for everything besides Postgres. Because we originally intended to support SQLite in addition to Postgres, this is evidently a problem. It’s also where the portability of an intermediate SQL representation comes into play. Since our new operators return AST nodes and not just textual SQL, we can redefine the way those nodes are compiled into actual query fragments on various database backends. To accomplish that, first we need to distinguish our regex filters from other BinaryExpressions: class RegexMatchExpression(BinaryExpression): &#34;&#34;&#34;Represents matching of a column againsts a regular expression.&#34;&#34;&#34; # (inside String.comparator_factory) def regexp(self, other): return RegexMatchExpression(self.expr, literal(other), custom_op(&#39;~&#39;)) # etc. Once we’ve introduced such a distinction, it becomes possible to provide a different way for those filters to be turned into SQL. We can namely define a new compilation routine for them, and mark it as canonical for a specific SQL dialect: from sqlalchemy.ext.compiler import compiles @compiles(RegexMatchExpression, &#39;sqlite&#39;) def sqlite_regex_match(element, compiler, **kw): &#34;&#34;&#34;Compile the SQL expression representing a regular expression match for the SQLite engine. &#34;&#34;&#34; # ... The function receives an AST element to process (here, the RegexMatchExpression), along with a special compiler object that controls the whole translation process. Armed with those tools, we are allowed to modify the process in arbitrary ways and output just the right SQL statement that’ll do the job in SQLite. Regex support lite How does such a statement look like, though? As I’ve remarked early on, SQLite is very easy to extend with your own functions, and the sqlite3 driver used by SQLAlchemy enables us to write those functions directly in Python. Obviously, this is fantastic news when you have something like the standard re module at your disposal. Indeed, coding the four required functions is quite trivial: import re # Mapping from the regular expression matching operators # to named Python functions that implement them for SQLite. SQLITE_REGEX_FUNCTIONS = { &#39;~&#39;: (&#39;REGEXP&#39;, lambda value, regex: bool(re.match(regex, value))), &#39;~*&#39;: (&#39;IREGEXP&#39;, lambda value, regex: bool(re.match(regex, value, re.IGNORECASE))), &#39;!~&#39;: (&#39;NOT_REGEXP&#39;, lambda value, regex: not re.match(regex, value)), &#39;!~*&#39;: (&#39;NOT_IREGEXP&#39;, lambda value, regex: not re.match(regex, value, re.IGNORECASE)), } What’s less apparent is how — or rather, when — to instruct the SQLite database to use them. As per the API we have to use, custom SQLite functions are created on a per-connection basis. But SQLAlchemy, like any good database interface, takes care of connection management, lifecycle, and pooling. Nowhere in our application there is a connect call (nor there should be!) that we could just follow with a few create_function invocations. Yet, there is a way of doing exactly what we require, and it involves utilizing the event subsystem included in SQLAlchemy. Anytime something interesting happens to any of its ORM or core objects — models, sessions, connection pools, etc. — SQLAlchemy publishes an event that our application code can listen (subscribe) to. It’s a classic PubSub system that introduces some serious potential for extensibility. Our use of it will be pretty modest, though. All we’re interested in is the establishing of a connection to the SQLite database. This translates directly to a &#39;connect&#39; event of the Engine object: from sqlalchemy import event from sqlalchemy.engine import Engine import sqlite3 @event.listens_for(Engine, &#39;connect&#39;) def sqlite_engine_connect(dbapi_connection, connection_record): &#34;&#34;&#34;Listener for the event of establishing connection to a SQLite database. Creates the functions handling regular expression operators within SQLite engine, pointing them to their Python implementations above. &#34;&#34;&#34; if not isinstance(dbapi_connection, sqlite3.Connection): return for name, function in SQLITE_REGEX_FUNCTIONS.values(): dbapi_connection.create_function(name, 2, function) Note that this will catch all the connection events, so we have to verify it’s really SQLite we’re talking to. Afterwards, the creation of REGEXP, IREGEXP, etc. functions is extremely straightforward. Compilation, take two This was quite a build-up, but now we’re very close to the finale. What remains is finishing the compilation routine: @compiles(RegexMatchExpression, &#39;sqlite&#39;) def sqlite_regex_match(element, compiler, **kw): pass We know that element corresponds to an expression in the form of a ~ &#39;foo&#39;. For SQLite, however, the compatible version is a function call: REGEXP(a, &#39;foo&#39;). At first this may appear rather disconcerting, because it’s basically a completely different AST node to build. But it’s actually not a problem at all. Inside compiler hooks, we are allowed to use the much of the same API that’s available when drafting regular queries. This includes the func factory object which produces calls to arbitrary SQL functions. Rather than compiling the original binary expression, we’ll simply poach its operands and use them as arguments to one of the new functions: from sqlalchemy import exc from sqlalchemy.sql.expression import func @compiles(RegexMatchExpression, &#39;sqlite&#39;) def sqlite_regex_match(element, compiler, **kw): # determine the name of a custom SQLite function to use for the operator operator = element.operator.opstring try: func_name, _ = SQLITE_REGEX_FUNCTIONS[operator] except (KeyError, ValueError), e: would_be_sql_string = &#39; &#39;.join((compiler.process(element.left), operator, compiler.process(element.right))) raise exc.StatementError( &#34;unknown regular expression match operator: %s&#34; % operator, would_be_sql_string, None, e) # compile the expression as an invocation of the custom function regex_func = getattr(func, func_name) regex_func_call = regex_func(element.left, element.right) return compiler.process(regex_func_call) Notice how compiler.process is used to obtain the final result. The compiler object doesn’t care that we use it on a totally different AST node; it will dutifully carry out its compilation into raw SQL. We can even use this capability to add a little bit of paranoid error handling: if we encounter an unknown operator, the resulting error message will include fully compiled, SQL versions of both arguments. Summary This concludes our efforts: the original query examples with Person.nick.regexp should now work in both Postgres and SQLite. For you convenience, I’ve bundled all the code in this gist. If you feel like tinkering with it further, I would suggest you try to remove the superfluous NOT_* functions. They make little sense given that SQL has a perfectly adequate NOT keyword. A clean solution would probably prefer an additional reverse flag in RegexMatchExpression over looking for a &#39;!&#39; character in the operator string. It may or may not be a good practice, though. ↩ Although it’s possible to write Column(Integer), it’s merely a syntactical convenience. SQLAlchemy interprets it readily as Column(Integer()). Parameterized types — like String — always require explicit instantiation. ↩" />
<meta name="keywords" content="regular expressions, SQLAlchemy, SQL, Postgres, SQLite, AST">
<meta property="og:site_name" content="Karol Kuczmarski's Blog"/>
<meta property="og:title" content="Regular expression filters in SQLAlchemy"/>
<meta property="og:description" content="The nice part about SQLAlchemy — an ORM library/framework for Python — is that it offers much more than just mapping of SQL relations to model classes. At its lower level, for example, there exists an additional layer between those classes and raw SQL queries: an abstraction for the SQL language itself. Although it may sound byzantine at first, this extra layer serves two important purposes: portability: compiling of the same query to potentially different SQL syntaxes, as required by different database backends extensibility: allowing the user to introduce new elements: operators, functions, or even whole statements I’m going to take advantage of both of these qualities here, and show how you can implement support for regular expression operators in query filters. On supported database backends, it will allow for powerful pattern matching on string columns. Database side We will use the Postgres syntax of POSIX regular expression matchers as a reference. It includes four operators: for case sensitive or insensitive matching, in regular or negated versions. Since it’s a common practice to use an in-memory SQLite for running database-involved “unit” tests1, we will also add support for that backend. Regular expressions are not implemented there directly, but thanks to sqlite3‘s custom function ability, it’ll be easy enough to provide the necessary support in Python. Desired API In essence, what we want to do is to enhance the String column type with additional comparators, which will then be usable as arguments for the Query.filter method. As an example, consider the following model class with a string column: class Person(Model): nick = Column(String(255)) # ... Once we’re done, it should be possible to query for e.g. all the people whose nicks contain numbers in a pretty straightforward fashion: numerics = session.query(Person).filter(Person.nick.regexp(r&#39;\d+&#39;)).all() Because of the limitations of underlying databases backends, only literal regular expressions would be supported. It means that, from the SQL standpoint, they have to be constants: you cannot use the value of one column as part of a regular expression that another column is matched against. But of course, you can still construct those literals in Python code: def get_copycats(nick): &#34;&#34;&#34;Return all the people who tried to parrot given nick but failed and had to append some numbers to it. &#34;&#34;&#34; nick_regexp = &#39;^&#39; + re.escape(nick) + r&#39;\d+$&#39; return session.query(Person).filter(Person.nick.regexp(nick_regexp)).all() Considering that regular expressions themselves are already pretty powerful, this really ought to be sufficient for all reasonable purposes. How comparators work? So how do we add the regexp method to the String type? It may seem logical to simply extend the class and add it directly: from sqlalchemy import String as _String class String(_String): &#34;&#34;&#34;Enhanced version of the standard string type.&#34;&#34;&#34; def regexp(self, value): # hmm... But this won’t actually work. In SQLAlchemy, objects like String or Integer do not represent columns of certain type; they correspond to types themselves2. Extending them with additional methods won’t do much good, because regular code rarely operates on column types. On the other hand, though, we obviously don’t want to mess with the Column class itself. Our additions are only meaningful for string columns, but putting them there would expose them to all columns, regardless of type! Thankfully, there is an intermediate mechanism which SQLAlchemy introduced precisely to address the need we’ve got here. Every column type can define a comparator_factory: a kind of mixin class whose methods are incorporated into columns of that type. By overriding this inner class, we can both modify the behavior of existing operators, as well as introduce completely new ones. So in order to add regexp and other methods to all String columns, our new string type must define its own comparator_factory: class String(_String): class comparator_factory(_String.comparator_factory): def regexp(self, other): # ... We need to remember about deriving it from the original one, too. Otherwise, all the standard operators you’d want to use in queries (==, +, etc.) would cease to work, because the new comparator_factory wouldn’t include an implementation of any of the necessary magic methods (__eq__, __add__, etc.). SQL, abstracted Knowing where to put our new comparator methods is certainly desirable, but the more interesting question is how do we implement them? Like I’ve mentioned in the beginning, SQLAlchemy employs an additional layer between ORM models and raw, textual SQL language. Basically, it’s an AST for backend-independent queries which includes almost all of the various SQL constructs, codified in a platform-agnostic way inside the sqlalchemy.sql package. You may have used this layer directly if you ever wrote queries based on Table objects and ran them with Session.execute. But even those constructed using the more familiar Query class interface end up in this intermediate representation. Often there is little to no additional processing involved. Arguments to the Query.filter method, for example, are already given as SQL clause objects. It just so happens that its creation is hidden behind a very neat, operator-based API. Thus, if our regular expression filters are to cooperate, they also need to return pieces of the SQL syntax tree. Not very complicated pieces, mind you, since we only need to represent simple expressions: something like foo ~ &#39;bar&#39;, where ~ may optionally be replaced by one of the other three operators. Creating the node They are all binary operators, by the way (i.e. taking exactly two arguments), so it makes sense that the corresponding AST node class is called BinaryExpression. The node’s children are the left argument, the right argument, and the operator itself. With a little help from a few more SQL syntax wrappers, the implementation of regexp and the other methods turns out to be quite straightforward: from sqlalchemy.sql.expression import BinaryExpression, literal from sqlalchemy.sql.operators import custom_op # (inside String.comparator_factory) def regexp(self, other): return BinaryExpression(self.expr, literal(other), custom_op(&#39;~&#39;)) def iregexp(self, other): return BinaryExpression(self.expr, literal(other), custom_op(&#39;~*&#39;)) def not_regexp(self, other): return BinaryExpression(self.expr, literal(other), custom_op(&#39;!~&#39;)) def not_iregexp(self, other): return BinaryExpression(self.expr, literal(other), custom_op(&#39;!~*&#39;)) The use of literal function is dictated by the limitation that was mentioned earlier: any regular expression given in the query must be a SQL literal. If we now try to pass a column-like clause, we’ll get an exception right at the query definition, rather than a database error when we try to execute it. The custom_op function, on the other hand, is simply the easiest way to create an “operator node” that’s required as a child of BinaryExpression. Since it’s a custom operator, it won’t be interpreted by SQLAlchemy in any way; it will simply be used verbatim in the final SQL string that’s sent to the database. Compile! You may have noticed that this would pose a problem if said database doesn’t support ~ or the other operators, which happens to be the case for everything besides Postgres. Because we originally intended to support SQLite in addition to Postgres, this is evidently a problem. It’s also where the portability of an intermediate SQL representation comes into play. Since our new operators return AST nodes and not just textual SQL, we can redefine the way those nodes are compiled into actual query fragments on various database backends. To accomplish that, first we need to distinguish our regex filters from other BinaryExpressions: class RegexMatchExpression(BinaryExpression): &#34;&#34;&#34;Represents matching of a column againsts a regular expression.&#34;&#34;&#34; # (inside String.comparator_factory) def regexp(self, other): return RegexMatchExpression(self.expr, literal(other), custom_op(&#39;~&#39;)) # etc. Once we’ve introduced such a distinction, it becomes possible to provide a different way for those filters to be turned into SQL. We can namely define a new compilation routine for them, and mark it as canonical for a specific SQL dialect: from sqlalchemy.ext.compiler import compiles @compiles(RegexMatchExpression, &#39;sqlite&#39;) def sqlite_regex_match(element, compiler, **kw): &#34;&#34;&#34;Compile the SQL expression representing a regular expression match for the SQLite engine. &#34;&#34;&#34; # ... The function receives an AST element to process (here, the RegexMatchExpression), along with a special compiler object that controls the whole translation process. Armed with those tools, we are allowed to modify the process in arbitrary ways and output just the right SQL statement that’ll do the job in SQLite. Regex support lite How does such a statement look like, though? As I’ve remarked early on, SQLite is very easy to extend with your own functions, and the sqlite3 driver used by SQLAlchemy enables us to write those functions directly in Python. Obviously, this is fantastic news when you have something like the standard re module at your disposal. Indeed, coding the four required functions is quite trivial: import re # Mapping from the regular expression matching operators # to named Python functions that implement them for SQLite. SQLITE_REGEX_FUNCTIONS = { &#39;~&#39;: (&#39;REGEXP&#39;, lambda value, regex: bool(re.match(regex, value))), &#39;~*&#39;: (&#39;IREGEXP&#39;, lambda value, regex: bool(re.match(regex, value, re.IGNORECASE))), &#39;!~&#39;: (&#39;NOT_REGEXP&#39;, lambda value, regex: not re.match(regex, value)), &#39;!~*&#39;: (&#39;NOT_IREGEXP&#39;, lambda value, regex: not re.match(regex, value, re.IGNORECASE)), } What’s less apparent is how — or rather, when — to instruct the SQLite database to use them. As per the API we have to use, custom SQLite functions are created on a per-connection basis. But SQLAlchemy, like any good database interface, takes care of connection management, lifecycle, and pooling. Nowhere in our application there is a connect call (nor there should be!) that we could just follow with a few create_function invocations. Yet, there is a way of doing exactly what we require, and it involves utilizing the event subsystem included in SQLAlchemy. Anytime something interesting happens to any of its ORM or core objects — models, sessions, connection pools, etc. — SQLAlchemy publishes an event that our application code can listen (subscribe) to. It’s a classic PubSub system that introduces some serious potential for extensibility. Our use of it will be pretty modest, though. All we’re interested in is the establishing of a connection to the SQLite database. This translates directly to a &#39;connect&#39; event of the Engine object: from sqlalchemy import event from sqlalchemy.engine import Engine import sqlite3 @event.listens_for(Engine, &#39;connect&#39;) def sqlite_engine_connect(dbapi_connection, connection_record): &#34;&#34;&#34;Listener for the event of establishing connection to a SQLite database. Creates the functions handling regular expression operators within SQLite engine, pointing them to their Python implementations above. &#34;&#34;&#34; if not isinstance(dbapi_connection, sqlite3.Connection): return for name, function in SQLITE_REGEX_FUNCTIONS.values(): dbapi_connection.create_function(name, 2, function) Note that this will catch all the connection events, so we have to verify it’s really SQLite we’re talking to. Afterwards, the creation of REGEXP, IREGEXP, etc. functions is extremely straightforward. Compilation, take two This was quite a build-up, but now we’re very close to the finale. What remains is finishing the compilation routine: @compiles(RegexMatchExpression, &#39;sqlite&#39;) def sqlite_regex_match(element, compiler, **kw): pass We know that element corresponds to an expression in the form of a ~ &#39;foo&#39;. For SQLite, however, the compatible version is a function call: REGEXP(a, &#39;foo&#39;). At first this may appear rather disconcerting, because it’s basically a completely different AST node to build. But it’s actually not a problem at all. Inside compiler hooks, we are allowed to use the much of the same API that’s available when drafting regular queries. This includes the func factory object which produces calls to arbitrary SQL functions. Rather than compiling the original binary expression, we’ll simply poach its operands and use them as arguments to one of the new functions: from sqlalchemy import exc from sqlalchemy.sql.expression import func @compiles(RegexMatchExpression, &#39;sqlite&#39;) def sqlite_regex_match(element, compiler, **kw): # determine the name of a custom SQLite function to use for the operator operator = element.operator.opstring try: func_name, _ = SQLITE_REGEX_FUNCTIONS[operator] except (KeyError, ValueError), e: would_be_sql_string = &#39; &#39;.join((compiler.process(element.left), operator, compiler.process(element.right))) raise exc.StatementError( &#34;unknown regular expression match operator: %s&#34; % operator, would_be_sql_string, None, e) # compile the expression as an invocation of the custom function regex_func = getattr(func, func_name) regex_func_call = regex_func(element.left, element.right) return compiler.process(regex_func_call) Notice how compiler.process is used to obtain the final result. The compiler object doesn’t care that we use it on a totally different AST node; it will dutifully carry out its compilation into raw SQL. We can even use this capability to add a little bit of paranoid error handling: if we encounter an unknown operator, the resulting error message will include fully compiled, SQL versions of both arguments. Summary This concludes our efforts: the original query examples with Person.nick.regexp should now work in both Postgres and SQLite. For you convenience, I’ve bundled all the code in this gist. If you feel like tinkering with it further, I would suggest you try to remove the superfluous NOT_* functions. They make little sense given that SQL has a perfectly adequate NOT keyword. A clean solution would probably prefer an additional reverse flag in RegexMatchExpression over looking for a &#39;!&#39; character in the operator string. It may or may not be a good practice, though. ↩ Although it’s possible to write Column(Integer), it’s merely a syntactical convenience. SQLAlchemy interprets it readily as Column(Integer()). Parameterized types — like String — always require explicit instantiation. ↩"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://xion.io/post/code/sqlalchemy-regex-filters.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2015-10-14 10:15:00-07:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="http://xion.io/">
<meta property="article:section" content="Code"/>
<meta property="article:tag" content="regular expressions"/>
<meta property="article:tag" content="SQLAlchemy"/>
<meta property="article:tag" content="SQL"/>
<meta property="article:tag" content="Postgres"/>
<meta property="article:tag" content="SQLite"/>
<meta property="article:tag" content="AST"/>
<meta property="og:image" content="http://xion.io/logo.jpeg">
  <title>Karol Kuczmarski's Blog &ndash; Regular expression filters in SQLAlchemy</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://xion.io">
        <img src="http://xion.io/logo.jpeg" alt="Karol Kuczmarski" title="Karol Kuczmarski">
      </a>
      <h1><a href="http://xion.io">Karol Kuczmarski</a></h1>
      <p>fn(Tea) -> Code</p>
      <nav>
        <ul class="list">
          <li><a href="http://xion.io/page/about.html#about">About</a></li>
          <li><a href="http://xion.io/page/projects.html#projects">Projects</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-github" href="http://github.com/Xion" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-stack-overflow" href="http://stackoverflow.com/users/434799/xion" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
        <li><a class="sc-twitter" href="http://twitter.com/Xion__" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-google" href="https://plus.google.com/+KarolKuczmarski" target="_blank"><i class="fa fa-google"></i></a></li>
        <li><a class="sc-rss" href="/feeds/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="http://xion.io">Home</a>
      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>
      <a href="http://xion.org.pl/">Old blog</a>
    </nav>

<article>
  <header>
    <h1 id="sqlalchemy-regex-filters">Regular expression filters in&nbsp;SQLAlchemy</h1>
    <p>Posted on Wed 14 October 2015 in <a href="http://xion.io/category/code.html">Code</a></p>
  </header>
  <div>
    <p>The nice part about <a href="http://www.sqlalchemy.org/">SQLAlchemy</a>
&#8212; an <a href="https://en.wikipedia.org/wiki/Object-relational_mapping"><span class="caps">ORM</span></a> library/framework for Python &#8212;
is that it offers much more than just mapping of <span class="caps">SQL</span> relations to model classes. At its lower level, for example,
there exists an additional layer between those classes and raw <span class="caps">SQL</span> queries: an abstraction for the <em><span class="caps">SQL</span> language itself</em>.</p>
<p>Although it may sound byzantine at first, this extra layer serves two important&nbsp;purposes:</p>
<ul>
<li><em>portability</em>: compiling of the same query to potentially different <span class="caps">SQL</span> syntaxes,
as required by different database&nbsp;backends</li>
<li><em>extensibility</em>: allowing the user to introduce new elements: operators, functions, or even whole&nbsp;statements</li>
</ul>
<p>I&#8217;m going to take advantage of both of these qualities here, and show how you can implement support
for <em>regular expression</em> operators in query filters. On supported database backends, it will allow for powerful
pattern matching on string&nbsp;columns.</p>
<h4>Database&nbsp;side</h4>
<p>We will use the Postgres syntax of <span class="caps">POSIX</span>
<a href="http://www.postgresql.org/docs/9.3/static/functions-matching.html#FUNCTIONS-POSIX-REGEXP">regular expression matchers</a>
as a reference. It includes four operators: for case sensitive or insensitive matching, in regular or negated&nbsp;versions.</p>
<p>Since it&#8217;s a common practice to use an in-memory <a href="https://www.sqlite.org/">SQLite</a> for running database-involved
&#8220;unit&#8221; tests<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>, we will also add support for that backend. Regular expressions are not implemented there directly,
but thanks to
<a href="https://docs.python.org/2/library/sqlite3.html#sqlite3.Connection.create_function"><code>sqlite3</code><span class="quo">&#8216;</span>s custom function ability</a>,
it&#8217;ll be easy enough to provide the necessary support in&nbsp;Python.</p>
<h4>Desired <span class="caps">API</span></h4>
<p>In essence, what we want to do is to enhance the <code>String</code> column type with additional <em>comparators</em>, which will then
be usable as arguments for the <code>Query.filter</code> method.</p>
<p>As an example, consider the following model class with a string&nbsp;column:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">nick</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">255</span><span class="p">))</span>
    <span class="c"># ...</span>
</pre></div>


<p>Once we&#8217;re done, it should be possible to query for e.g. all the people whose nicks contain numbers
in a pretty straightforward&nbsp;fashion:</p>
<div class="highlight"><pre><span class="n">numerics</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Person</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Person</span><span class="o">.</span><span class="n">nick</span><span class="o">.</span><span class="n">regexp</span><span class="p">(</span><span class="s">r&#39;\d+&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>


<p>Because of the limitations of underlying databases backends, only <em>literal</em> regular expressions would be supported.
It means that, from the <span class="caps">SQL</span> standpoint, they have to be constants: you cannot use the value of one column as part
of a regular expression that another column is matched&nbsp;against.</p>
<p>But of course, you can still construct those literals in Python&nbsp;code:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">get_copycats</span><span class="p">(</span><span class="n">nick</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return all the people who tried to parrot given nick</span>
<span class="sd">    but failed and had to append some numbers to it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nick_regexp</span> <span class="o">=</span> <span class="s">&#39;^&#39;</span> <span class="o">+</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">nick</span><span class="p">)</span> <span class="o">+</span> <span class="s">r&#39;\d+$&#39;</span>
    <span class="k">return</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Person</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Person</span><span class="o">.</span><span class="n">nick</span><span class="o">.</span><span class="n">regexp</span><span class="p">(</span><span class="n">nick_regexp</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>


<p>Considering that regular expressions themselves are already pretty powerful, this really ought to be sufficient
for all reasonable&nbsp;purposes.</p>
<h4>How comparators&nbsp;work?</h4>
<p>So how do we add the <code>regexp</code> method to the <code>String</code> type? It may seem logical to simply extend the class
and add it&nbsp;directly:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">String</span> <span class="k">as</span> <span class="n">_String</span>


<span class="k">class</span> <span class="nc">String</span><span class="p">(</span><span class="n">_String</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Enhanced version of the standard string type.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">regexp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c"># hmm...</span>
</pre></div>


<p>But this won&#8217;t actually work. In SQLAlchemy, objects like <code>String</code> or <code>Integer</code> do not represent columns of certain type;
they correspond to <em>types themselves</em><sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>. Extending them with additional methods won&#8217;t do much good, because regular code
rarely operates on column&nbsp;types.</p>
<p>On the other hand, though, we obviously don&#8217;t want to mess with the <code>Column</code> class itself. Our additions are only
meaningful for string columns, but putting them there would expose them to <em>all</em> columns, regardless of&nbsp;type!</p>
<p>Thankfully, there is an intermediate mechanism which SQLAlchemy introduced precisely to address the need we&#8217;ve got here.
Every column type can define a
<a href="http://docs.sqlalchemy.org/en/rel_0_9/core/type_api.html#sqlalchemy.types.TypeEngine.comparator_factory"><code>comparator_factory</code></a>: a kind of mixin class whose methods are incorporated into columns of that type.
By <a href="http://docs.sqlalchemy.org/en/rel_0_9/core/custom_types.html#types-operators">overriding this inner class</a>,
we can both modify the behavior of existing operators, as well as introduce completely new&nbsp;ones.</p>
<p>So in order to add <code>regexp</code> and other methods to all <code>String</code> columns, our new string type must define its own
<code>comparator_factory</code>:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">String</span><span class="p">(</span><span class="n">_String</span><span class="p">):</span>
    <span class="k">class</span> <span class="nc">comparator_factory</span><span class="p">(</span><span class="n">_String</span><span class="o">.</span><span class="n">comparator_factory</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">regexp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="c"># ...</span>
</pre></div>


<p>We need to remember about deriving it from the original one, too. Otherwise, all the standard operators
you&#8217;d want to use in queries (<code>==</code>, <code>+</code>, etc.) would cease to work, because the new <code>comparator_factory</code> wouldn&#8217;t
include an implementation of any of the necessary magic methods (<code>__eq__</code>, <code>__add__</code>,&nbsp;etc.).</p>
<h4><span class="caps">SQL</span>,&nbsp;abstracted</h4>
<p>Knowing where to put our new comparator methods is certainly desirable, but the more interesting question is
how do we implement&nbsp;them?</p>
<p>Like I&#8217;ve mentioned in the beginning, SQLAlchemy employs an additional layer between
<span class="caps">ORM</span> models and raw, textual <span class="caps">SQL</span> language. Basically, it&#8217;s an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree"><span class="caps">AST</span></a>
for backend-independent queries which includes almost all of the various <span class="caps">SQL</span> constructs, codified in a platform-agnostic
way inside the <code>sqlalchemy.sql</code> package.</p>
<p>You may have used this layer directly if you ever wrote queries based on
<a href="http://docs.sqlalchemy.org/en/rel_0_9/core/metadata.html#sqlalchemy.schema.Table"><code>Table</code> objects</a> and ran them with
<a href="http://docs.sqlalchemy.org/en/rel_0_9/orm/session_api.html#sqlalchemy.orm.session.Session.execute"><code>Session.execute</code></a>. But even those constructed using the more familiar
<a href="http://docs.sqlalchemy.org/en/rel_0_9/orm/query.html#sqlalchemy.orm.query.Query"><code>Query</code> class</a> interface
end up in this intermediate representation. Often there is little to no additional processing&nbsp;involved.</p>
<p>Arguments to the
<a href="http://docs.sqlalchemy.org/en/rel_0_9/orm/query.html#sqlalchemy.orm.query.Query.filter"><code>Query.filter</code> method</a>,
for example, are already given as <span class="caps">SQL</span> clause objects. It just so happens that its creation is hidden behind
a very neat, operator-based <span class="caps">API</span>.</p>
<p>Thus, if our regular expression filters are to cooperate, they also need to return pieces of the <span class="caps">SQL</span> syntax tree.
Not very complicated pieces, mind you, since we only need to represent simple expressions: something like <code>foo ~ 'bar'</code>, where <code>~</code> may optionally be replaced by one of the other three&nbsp;operators.</p>
<h4>Creating the&nbsp;node</h4>
<p>They are all <em>binary</em> operators, by the way (i.e. taking exactly two arguments), so it makes sense that the corresponding
<a href="http://docs.sqlalchemy.org/en/rel_0_9/core/sqlelement.html#sqlalchemy.sql.expression.BinaryExpression"><span class="caps">AST</span> node class</a> is called <code>BinaryExpression</code>. The node&#8217;s children are the left argument, the right argument, and the operator&nbsp;itself.</p>
<p>With a little help from a few more <span class="caps">SQL</span> syntax wrappers, the implementation of <code>regexp</code> and the other methods
turns out to be quite&nbsp;straightforward:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy.sql.expression</span> <span class="kn">import</span> <span class="n">BinaryExpression</span><span class="p">,</span> <span class="n">literal</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.sql.operators</span> <span class="kn">import</span> <span class="n">custom_op</span>


<span class="c"># (inside String.comparator_factory)</span>

<span class="k">def</span> <span class="nf">regexp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">BinaryExpression</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">literal</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">custom_op</span><span class="p">(</span><span class="s">&#39;~&#39;</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">iregexp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">BinaryExpression</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">literal</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">custom_op</span><span class="p">(</span><span class="s">&#39;~*&#39;</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">not_regexp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">BinaryExpression</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">literal</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">custom_op</span><span class="p">(</span><span class="s">&#39;!~&#39;</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">not_iregexp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">BinaryExpression</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">literal</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">custom_op</span><span class="p">(</span><span class="s">&#39;!~*&#39;</span><span class="p">))</span>
</pre></div>


<p>The use of
<a href="http://docs.sqlalchemy.org/en/rel_0_9/core/sqlelement.html#sqlalchemy.sql.expression.literal"><code>literal</code> function</a>
is dictated by the limitation that was mentioned earlier: any regular expression given in the query must be a <span class="caps">SQL</span> literal.
If we now try to pass a column-like clause, we&#8217;ll get an exception right at the query definition, rather than
a database error when we try to execute&nbsp;it.</p>
<p>The <a href="docs.sqlalchemy.org/en/rel_0_9/core/sqlelement.html#sqlalchemy.sql.operators.custom_op"><code>custom_op</code> function</a>,
on the other hand, is simply the easiest way to create an &#8220;operator node&#8221; that&#8217;s required as a child
of <code>BinaryExpression</code>. Since it&#8217;s a custom operator, it won&#8217;t be interpreted by SQLAlchemy in any way; it will simply
be used verbatim in the final <span class="caps">SQL</span> string that&#8217;s sent to the&nbsp;database.</p>
<h4>Compile!</h4>
<p>You may have noticed that this would pose a problem if said database doesn&#8217;t support <code>~</code> or the other operators,
which happens to be the case for everything besides Postgres. Because we originally intended to support SQLite in addition
to Postgres, this is evidently a&nbsp;problem.</p>
<p>It&#8217;s also where the portability of an intermediate <span class="caps">SQL</span> representation comes into play. Since our new operators return
<span class="caps">AST</span> nodes and not just textual <span class="caps">SQL</span>, we can redefine the way those nodes are <em>compiled</em> into actual query fragments
on various database&nbsp;backends.</p>
<p>To accomplish that, first we need to distinguish our regex filters from other <code>BinaryExpression</code>s:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">RegexMatchExpression</span><span class="p">(</span><span class="n">BinaryExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents matching of a column againsts a regular expression.&quot;&quot;&quot;</span>

<span class="c"># (inside String.comparator_factory)</span>

<span class="k">def</span> <span class="nf">regexp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">RegexMatchExpression</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">literal</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">custom_op</span><span class="p">(</span><span class="s">&#39;~&#39;</span><span class="p">))</span>
<span class="c"># etc.</span>
</pre></div>


<p>Once we&#8217;ve introduced such a distinction, it becomes possible to provide a different way for those filters to be turned
into <span class="caps">SQL</span>. We can namely define a new compilation routine for them,
and <a href="docs.sqlalchemy.org/en/rel_0_9/core/compiler.html#sqlalchemy.ext.compiler.compiles">mark it as canonical</a>
for a specific <span class="caps">SQL</span>&nbsp;dialect:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy.ext.compiler</span> <span class="kn">import</span> <span class="n">compiles</span>


<span class="nd">@compiles</span><span class="p">(</span><span class="n">RegexMatchExpression</span><span class="p">,</span> <span class="s">&#39;sqlite&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sqlite_regex_match</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">compiler</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compile the SQL expression representing a regular expression match</span>
<span class="sd">    for the SQLite engine.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># ...</span>
</pre></div>


<p>The function receives an <span class="caps">AST</span> <code>element</code> to process (here, the <code>RegexMatchExpression</code>), along with a
<a href="http://docs.sqlalchemy.org/en/rel_0_9/core/internals.html#sqlalchemy.sql.compiler.SQLCompiler">special <code>compiler</code> object</a>
that controls the whole translation process. Armed with those tools, we are allowed to modify the process
in arbitrary ways and output just the right <span class="caps">SQL</span> statement that&#8217;ll do the job in&nbsp;SQLite.</p>
<h4>Regex support&nbsp;lite</h4>
<p>How does such a statement look like, though? As I&#8217;ve remarked early on, SQLite is very easy to extend with your own
functions, and the <code>sqlite3</code> driver used by SQLAlchemy enables us to write those functions directly in Python.
Obviously, this is fantastic news when you have something like
<a href="https://docs.python.org/2/library/re.html">the standard <code>re</code> module</a> at your&nbsp;disposal.</p>
<p>Indeed, coding the four required functions is quite&nbsp;trivial:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">re</span>

<span class="c"># Mapping from the regular expression matching operators</span>
<span class="c"># to named Python functions that implement them for SQLite.</span>
<span class="n">SQLITE_REGEX_FUNCTIONS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;~&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;REGEXP&#39;</span><span class="p">,</span>
          <span class="k">lambda</span> <span class="n">value</span><span class="p">,</span> <span class="n">regex</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">value</span><span class="p">))),</span>
    <span class="s">&#39;~*&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;IREGEXP&#39;</span><span class="p">,</span>
           <span class="k">lambda</span> <span class="n">value</span><span class="p">,</span> <span class="n">regex</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">))),</span>
    <span class="s">&#39;!~&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;NOT_REGEXP&#39;</span><span class="p">,</span>
           <span class="k">lambda</span> <span class="n">value</span><span class="p">,</span> <span class="n">regex</span><span class="p">:</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">value</span><span class="p">)),</span>
    <span class="s">&#39;!~*&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;NOT_IREGEXP&#39;</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">value</span><span class="p">,</span> <span class="n">regex</span><span class="p">:</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)),</span>
<span class="p">}</span>
</pre></div>


<p>What&#8217;s less apparent is how &#8212; or rather, <em>when</em> &#8212; to instruct the SQLite database to use them.
As per the <a href="https://docs.python.org/2/library/sqlite3.html#sqlite3.Connection.create_function"><span class="caps">API</span> we have to use</a>,
custom SQLite functions are created on a per-connection basis. But SQLAlchemy, like any good database interface,
takes care of connection management, lifecycle, and pooling. Nowhere in our application there is a <code>connect</code> call
(nor there should be!) that we could just follow with a few <code>create_function</code> invocations.</p>
<p>Yet, there is a way of doing exactly what we require, and it involves utilizing the
<a href="http://docs.sqlalchemy.org/en/rel_0_9/core/event.html">event subsystem</a> included in SQLAlchemy. Anytime something
interesting happens to any of its <span class="caps">ORM</span> or core objects &#8212; models, sessions, connection pools, etc. &#8212; SQLAlchemy
publishes an <em>event</em> that our application code can <em>listen</em> (subscribe) to. It&#8217;s a classic
<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">PubSub system</a> that introduces some serious potential
for&nbsp;extensibility.</p>
<p>Our use of it will be pretty modest, though. All we&#8217;re interested in is the establishing of a connection
to the SQLite database. This translates directly to a <code>'connect'</code> event of the
<a href="docs.sqlalchemy.org/en/rel_0_9/core/connections.html"><code>Engine</code> object</a>:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">event</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.engine</span> <span class="kn">import</span> <span class="n">Engine</span>
<span class="kn">import</span> <span class="nn">sqlite3</span>


<span class="nd">@event.listens_for</span><span class="p">(</span><span class="n">Engine</span><span class="p">,</span> <span class="s">&#39;connect&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sqlite_engine_connect</span><span class="p">(</span><span class="n">dbapi_connection</span><span class="p">,</span> <span class="n">connection_record</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Listener for the event of establishing connection to a SQLite database.</span>

<span class="sd">    Creates the functions handling regular expression operators</span>
<span class="sd">    within SQLite engine, pointing them to their Python implementations above.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dbapi_connection</span><span class="p">,</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">Connection</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">SQLITE_REGEX_FUNCTIONS</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">dbapi_connection</span><span class="o">.</span><span class="n">create_function</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>
</pre></div>


<p>Note that this will catch all the connection events, so we have to verify it&#8217;s really SQLite we&#8217;re talking to.
Afterwards, the creation of <code>REGEXP</code>, <code>IREGEXP</code>, etc. functions is extremely&nbsp;straightforward.</p>
<h4>Compilation, take&nbsp;two</h4>
<p>This was quite a build-up, but now we&#8217;re very close to the finale. What remains is finishing the compilation&nbsp;routine:</p>
<div class="highlight"><pre><span class="nd">@compiles</span><span class="p">(</span><span class="n">RegexMatchExpression</span><span class="p">,</span> <span class="s">&#39;sqlite&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sqlite_regex_match</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">compiler</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>


<p>We know that <code>element</code> corresponds to an expression in the form of <code>a ~ 'foo'</code>. For SQLite, however, the compatible
version is a <em>function call</em>: <code>REGEXP(a, 'foo')</code>. At first this may appear rather disconcerting, because it&#8217;s basically
a completely different <span class="caps">AST</span> node to&nbsp;build.</p>
<p>But it&#8217;s actually not a problem at all. Inside compiler hooks, we are allowed to use the much of the same <span class="caps">API</span> that&#8217;s
available when drafting regular queries. This includes the
<a href="http://docs.sqlalchemy.org/en/rel_0_9/core/sqlelement.html#sqlalchemy.sql.expression.func"><code>func</code> factory object</a>
which produces calls to arbitrary <span class="caps">SQL</span> functions. Rather than compiling the original binary expression, we&#8217;ll simply
poach its operands and use them as arguments to one of the new&nbsp;functions:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">exc</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.sql.expression</span> <span class="kn">import</span> <span class="n">func</span>


<span class="nd">@compiles</span><span class="p">(</span><span class="n">RegexMatchExpression</span><span class="p">,</span> <span class="s">&#39;sqlite&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sqlite_regex_match</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">compiler</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="c"># determine the name of a custom SQLite function to use for the operator</span>
    <span class="n">operator</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">opstring</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">func_name</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">SQLITE_REGEX_FUNCTIONS</span><span class="p">[</span><span class="n">operator</span><span class="p">]</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">),</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">would_be_sql_string</span> <span class="o">=</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">compiler</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">left</span><span class="p">),</span>
                                        <span class="n">operator</span><span class="p">,</span>
                                        <span class="n">compiler</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">right</span><span class="p">)))</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">StatementError</span><span class="p">(</span>
            <span class="s">&quot;unknown regular expression match operator: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">operator</span><span class="p">,</span>
            <span class="n">would_be_sql_string</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>

    <span class="c"># compile the expression as an invocation of the custom function</span>
    <span class="n">regex_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">func_name</span><span class="p">)</span>
    <span class="n">regex_func_call</span> <span class="o">=</span> <span class="n">regex_func</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">compiler</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">regex_func_call</span><span class="p">)</span>
</pre></div>


<p>Notice how <code>compiler.process</code> is used to obtain the final result. The <code>compiler</code> object doesn&#8217;t care that we use it on
a totally different <span class="caps">AST</span> node; it will dutifully carry out its compilation into raw <span class="caps">SQL</span>. We can even use this capability
to add a little bit of paranoid error handling: if we encounter an unknown operator, the resulting error message
will include fully compiled, <span class="caps">SQL</span> versions of both&nbsp;arguments.</p>
<h4>Summary</h4>
<p>This concludes our efforts: the original query examples with <code>Person.nick.regexp</code> should now work
in both Postgres and SQLite.
For you convenience, I&#8217;ve bundled all the code in <a href="https://gist.github.com/Xion/204ddbd020f1a4275a53">this gist</a>.</p>
<p>If you feel like tinkering with it further, I would suggest you try to remove the superfluous <code>NOT_*</code> functions.
They make little sense given that <span class="caps">SQL</span> has a perfectly adequate <code>NOT</code> keyword. A clean solution would probably prefer
an additional <code>reverse</code> flag in <code>RegexMatchExpression</code> over looking for a <code>'!'</code> character in the operator&nbsp;string.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>It may or <a href="http://michael.robellard.com/2015/07/dont-test-with-sqllite-when-you-use.html">may not be</a>
a <em>good</em> practice, though.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Although it&#8217;s possible to write <code>Column(Integer)</code>, it&#8217;s merely a syntactical convenience.
SQLAlchemy interprets it readily as <code>Column(Integer())</code>. Parameterized types &#8212; like <code>String</code> &#8212; always require explicit
instantiation.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="http://xion.io/tag/regular-expressions.html">regular expressions</a>
      <a href="http://xion.io/tag/sqlalchemy.html">SQLAlchemy</a>
      <a href="http://xion.io/tag/sql.html">SQL</a>
      <a href="http://xion.io/tag/postgres.html">Postgres</a>
      <a href="http://xion.io/tag/sqlite.html">SQLite</a>
      <a href="http://xion.io/tag/ast.html">AST</a>
    </p>
  </div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'xionblog';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</article>

    <footer>
<p>
  &copy; Karol Kuczmarski 2017 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-27379564-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "Regular expression filters in SQLAlchemy",
  "headline": "Regular expression filters in SQLAlchemy",
  "datePublished": "2015-10-14 10:15:00-07:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "Karol Kuczmarski",
    "url": "http://xion.io/"
  },
  "image": "http://xion.io/logo.jpeg",
  "url": "http://xion.io/post/code/sqlalchemy-regex-filters.html",
  "description": "The nice part about SQLAlchemy — an ORM library/framework for Python — is that it offers much more than just mapping of SQL relations to model classes. At its lower level, for example, there exists an additional layer between those classes and raw SQL queries: an abstraction for the SQL language itself. Although it may sound byzantine at first, this extra layer serves two important purposes: portability: compiling of the same query to potentially different SQL syntaxes, as required by different database backends extensibility: allowing the user to introduce new elements: operators, functions, or even whole statements I’m going to take advantage of both of these qualities here, and show how you can implement support for regular expression operators in query filters. On supported database backends, it will allow for powerful pattern matching on string columns. Database side We will use the Postgres syntax of POSIX regular expression matchers as a reference. It includes four operators: for case sensitive or insensitive matching, in regular or negated versions. Since it’s a common practice to use an in-memory SQLite for running database-involved “unit” tests1, we will also add support for that backend. Regular expressions are not implemented there directly, but thanks to sqlite3‘s custom function ability, it’ll be easy enough to provide the necessary support in Python. Desired API In essence, what we want to do is to enhance the String column type with additional comparators, which will then be usable as arguments for the Query.filter method. As an example, consider the following model class with a string column: class Person(Model): nick = Column(String(255)) # ... Once we’re done, it should be possible to query for e.g. all the people whose nicks contain numbers in a pretty straightforward fashion: numerics = session.query(Person).filter(Person.nick.regexp(r'\d+')).all() Because of the limitations of underlying databases backends, only literal regular expressions would be supported. It means that, from the SQL standpoint, they have to be constants: you cannot use the value of one column as part of a regular expression that another column is matched against. But of course, you can still construct those literals in Python code: def get_copycats(nick): """Return all the people who tried to parrot given nick but failed and had to append some numbers to it. """ nick_regexp = '^' + re.escape(nick) + r'\d+$' return session.query(Person).filter(Person.nick.regexp(nick_regexp)).all() Considering that regular expressions themselves are already pretty powerful, this really ought to be sufficient for all reasonable purposes. How comparators work? So how do we add the regexp method to the String type? It may seem logical to simply extend the class and add it directly: from sqlalchemy import String as _String class String(_String): """Enhanced version of the standard string type.""" def regexp(self, value): # hmm... But this won’t actually work. In SQLAlchemy, objects like String or Integer do not represent columns of certain type; they correspond to types themselves2. Extending them with additional methods won’t do much good, because regular code rarely operates on column types. On the other hand, though, we obviously don’t want to mess with the Column class itself. Our additions are only meaningful for string columns, but putting them there would expose them to all columns, regardless of type! Thankfully, there is an intermediate mechanism which SQLAlchemy introduced precisely to address the need we’ve got here. Every column type can define a comparator_factory: a kind of mixin class whose methods are incorporated into columns of that type. By overriding this inner class, we can both modify the behavior of existing operators, as well as introduce completely new ones. So in order to add regexp and other methods to all String columns, our new string type must define its own comparator_factory: class String(_String): class comparator_factory(_String.comparator_factory): def regexp(self, other): # ... We need to remember about deriving it from the original one, too. Otherwise, all the standard operators you’d want to use in queries (==, +, etc.) would cease to work, because the new comparator_factory wouldn’t include an implementation of any of the necessary magic methods (__eq__, __add__, etc.). SQL, abstracted Knowing where to put our new comparator methods is certainly desirable, but the more interesting question is how do we implement them? Like I’ve mentioned in the beginning, SQLAlchemy employs an additional layer between ORM models and raw, textual SQL language. Basically, it’s an AST for backend-independent queries which includes almost all of the various SQL constructs, codified in a platform-agnostic way inside the sqlalchemy.sql package. You may have used this layer directly if you ever wrote queries based on Table objects and ran them with Session.execute. But even those constructed using the more familiar Query class interface end up in this intermediate representation. Often there is little to no additional processing involved. Arguments to the Query.filter method, for example, are already given as SQL clause objects. It just so happens that its creation is hidden behind a very neat, operator-based API. Thus, if our regular expression filters are to cooperate, they also need to return pieces of the SQL syntax tree. Not very complicated pieces, mind you, since we only need to represent simple expressions: something like foo ~ 'bar', where ~ may optionally be replaced by one of the other three operators. Creating the node They are all binary operators, by the way (i.e. taking exactly two arguments), so it makes sense that the corresponding AST node class is called BinaryExpression. The node’s children are the left argument, the right argument, and the operator itself. With a little help from a few more SQL syntax wrappers, the implementation of regexp and the other methods turns out to be quite straightforward: from sqlalchemy.sql.expression import BinaryExpression, literal from sqlalchemy.sql.operators import custom_op # (inside String.comparator_factory) def regexp(self, other): return BinaryExpression(self.expr, literal(other), custom_op('~')) def iregexp(self, other): return BinaryExpression(self.expr, literal(other), custom_op('~*')) def not_regexp(self, other): return BinaryExpression(self.expr, literal(other), custom_op('!~')) def not_iregexp(self, other): return BinaryExpression(self.expr, literal(other), custom_op('!~*')) The use of literal function is dictated by the limitation that was mentioned earlier: any regular expression given in the query must be a SQL literal. If we now try to pass a column-like clause, we’ll get an exception right at the query definition, rather than a database error when we try to execute it. The custom_op function, on the other hand, is simply the easiest way to create an “operator node” that’s required as a child of BinaryExpression. Since it’s a custom operator, it won’t be interpreted by SQLAlchemy in any way; it will simply be used verbatim in the final SQL string that’s sent to the database. Compile! You may have noticed that this would pose a problem if said database doesn’t support ~ or the other operators, which happens to be the case for everything besides Postgres. Because we originally intended to support SQLite in addition to Postgres, this is evidently a problem. It’s also where the portability of an intermediate SQL representation comes into play. Since our new operators return AST nodes and not just textual SQL, we can redefine the way those nodes are compiled into actual query fragments on various database backends. To accomplish that, first we need to distinguish our regex filters from other BinaryExpressions: class RegexMatchExpression(BinaryExpression): """Represents matching of a column againsts a regular expression.""" # (inside String.comparator_factory) def regexp(self, other): return RegexMatchExpression(self.expr, literal(other), custom_op('~')) # etc. Once we’ve introduced such a distinction, it becomes possible to provide a different way for those filters to be turned into SQL. We can namely define a new compilation routine for them, and mark it as canonical for a specific SQL dialect: from sqlalchemy.ext.compiler import compiles @compiles(RegexMatchExpression, 'sqlite') def sqlite_regex_match(element, compiler, **kw): """Compile the SQL expression representing a regular expression match for the SQLite engine. """ # ... The function receives an AST element to process (here, the RegexMatchExpression), along with a special compiler object that controls the whole translation process. Armed with those tools, we are allowed to modify the process in arbitrary ways and output just the right SQL statement that’ll do the job in SQLite. Regex support lite How does such a statement look like, though? As I’ve remarked early on, SQLite is very easy to extend with your own functions, and the sqlite3 driver used by SQLAlchemy enables us to write those functions directly in Python. Obviously, this is fantastic news when you have something like the standard re module at your disposal. Indeed, coding the four required functions is quite trivial: import re # Mapping from the regular expression matching operators # to named Python functions that implement them for SQLite. SQLITE_REGEX_FUNCTIONS = { '~': ('REGEXP', lambda value, regex: bool(re.match(regex, value))), '~*': ('IREGEXP', lambda value, regex: bool(re.match(regex, value, re.IGNORECASE))), '!~': ('NOT_REGEXP', lambda value, regex: not re.match(regex, value)), '!~*': ('NOT_IREGEXP', lambda value, regex: not re.match(regex, value, re.IGNORECASE)), } What’s less apparent is how — or rather, when — to instruct the SQLite database to use them. As per the API we have to use, custom SQLite functions are created on a per-connection basis. But SQLAlchemy, like any good database interface, takes care of connection management, lifecycle, and pooling. Nowhere in our application there is a connect call (nor there should be!) that we could just follow with a few create_function invocations. Yet, there is a way of doing exactly what we require, and it involves utilizing the event subsystem included in SQLAlchemy. Anytime something interesting happens to any of its ORM or core objects — models, sessions, connection pools, etc. — SQLAlchemy publishes an event that our application code can listen (subscribe) to. It’s a classic PubSub system that introduces some serious potential for extensibility. Our use of it will be pretty modest, though. All we’re interested in is the establishing of a connection to the SQLite database. This translates directly to a 'connect' event of the Engine object: from sqlalchemy import event from sqlalchemy.engine import Engine import sqlite3 @event.listens_for(Engine, 'connect') def sqlite_engine_connect(dbapi_connection, connection_record): """Listener for the event of establishing connection to a SQLite database. Creates the functions handling regular expression operators within SQLite engine, pointing them to their Python implementations above. """ if not isinstance(dbapi_connection, sqlite3.Connection): return for name, function in SQLITE_REGEX_FUNCTIONS.values(): dbapi_connection.create_function(name, 2, function) Note that this will catch all the connection events, so we have to verify it’s really SQLite we’re talking to. Afterwards, the creation of REGEXP, IREGEXP, etc. functions is extremely straightforward. Compilation, take two This was quite a build-up, but now we’re very close to the finale. What remains is finishing the compilation routine: @compiles(RegexMatchExpression, 'sqlite') def sqlite_regex_match(element, compiler, **kw): pass We know that element corresponds to an expression in the form of a ~ 'foo'. For SQLite, however, the compatible version is a function call: REGEXP(a, 'foo'). At first this may appear rather disconcerting, because it’s basically a completely different AST node to build. But it’s actually not a problem at all. Inside compiler hooks, we are allowed to use the much of the same API that’s available when drafting regular queries. This includes the func factory object which produces calls to arbitrary SQL functions. Rather than compiling the original binary expression, we’ll simply poach its operands and use them as arguments to one of the new functions: from sqlalchemy import exc from sqlalchemy.sql.expression import func @compiles(RegexMatchExpression, 'sqlite') def sqlite_regex_match(element, compiler, **kw): # determine the name of a custom SQLite function to use for the operator operator = element.operator.opstring try: func_name, _ = SQLITE_REGEX_FUNCTIONS[operator] except (KeyError, ValueError), e: would_be_sql_string = ' '.join((compiler.process(element.left), operator, compiler.process(element.right))) raise exc.StatementError( "unknown regular expression match operator: %s" % operator, would_be_sql_string, None, e) # compile the expression as an invocation of the custom function regex_func = getattr(func, func_name) regex_func_call = regex_func(element.left, element.right) return compiler.process(regex_func_call) Notice how compiler.process is used to obtain the final result. The compiler object doesn’t care that we use it on a totally different AST node; it will dutifully carry out its compilation into raw SQL. We can even use this capability to add a little bit of paranoid error handling: if we encounter an unknown operator, the resulting error message will include fully compiled, SQL versions of both arguments. Summary This concludes our efforts: the original query examples with Person.nick.regexp should now work in both Postgres and SQLite. For you convenience, I’ve bundled all the code in this gist. If you feel like tinkering with it further, I would suggest you try to remove the superfluous NOT_* functions. They make little sense given that SQL has a perfectly adequate NOT keyword. A clean solution would probably prefer an additional reverse flag in RegexMatchExpression over looking for a '!' character in the operator string. It may or may not be a good practice, though. ↩ Although it’s possible to write Column(Integer), it’s merely a syntactical convenience. SQLAlchemy interprets it readily as Column(Integer()). Parameterized types — like String — always require explicit instantiation. ↩"
}
</script></body>
</html>