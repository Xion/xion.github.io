<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/font-awesome.min.css">

    <link href="http://xion.io/style.css" rel="stylesheet">




  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

<meta name="author" content="Karol Kuczmarski" />
<meta name="description" content="RequireJS is a module loader for JavaScript. Similar to its alternatives such as Browserify, it tries to solve an important problem on the web front(end): dividing JavaScript code into modules for better maintainability while still loading them correctly and efficiently without manual curation of the &lt;script&gt; tags. Once it’s configured correctly (which can be rather non-trivial, though), modules in RequireJS are simply defined as functions that return arbitrary JavaScript objects: define([ &#39;jquery&#39;, &#39;lodash&#39;, &#39;myapp/dep1&#39;, &#39;myapp/dep2&#39;, ], function($, _, dep1, dep2) { // ... all of the module&#39;s code ... return { exportedSymbol1: ..., exportedSymbol2: ..., }; }); Before executing the function, RequireJS loads all the specified dependencies, repeating the process recursively and asynchronously. Return values from module functions are passed as parameters to the next module function, and thus the whole mechanism clicks, serving as a crafty workaround for the lack of proper import functionality1. Relative failures If, at some point in the chain, the desired module cannot be found or loaded, the entire process grinds to a halt with an error. Most of the time, this is perfectly acceptable (or even desirable) behavior, equivalent to an incorrect import statement, invalid #include directive, or similar mistake in other languages. But there are situations when we’d like to proceed with a missing module, because the dependent code is prepared to handle it. The canonical example are Web Workers. Unlike traditional web application code, Web Worker scripts operate outside of a context of any single page, having no access to the DOM tree (because which DOM tree would it be?). Correspondingly, they have no document nor window objects in their global scope. Unfortunately, some libraries (*cough* jQuery *cough*) require those objects as a hard (and usually implicit) dependency. This doesn’t exactly help if we’d like to use them in worker code for other features, not related to DOM. In case of jQuery, for example, it could be the API for making AJAX calls, which is still decidedly more pleasant than dealing with bare XMLHTTPRequest if we’re doing anything non-trivial. Due to this hard dependency on DOM, however, Web Workers cannot require jQuery. No biggie, you may think: browsers supporting workers also offer an excellent, promise-based Fetch API that largely replaces the old AJAX, so we may just use it in worker code. Good thinking indeed, but it doesn’t solve the issue of sharing code between main (“UI”) part of the app and Web Workers. Suppose you have the following dependency graph: The common module has some logic that we’d want reused between regular &lt;script&gt;-based code and a Web Worker, but its dependency on jQuery makes it impossible. It would work, however, if this dependency was a soft one. If common could detect that jQuery is not available and fall back to other solutions (like the Fetch API), we would be able to require it in both execution environments. The optional plugin What we need, it seems, is an ability to say that some dependencies (like &#39;jquery&#39;) are optional. They can be loaded if they’re available but otherwise, they shouldn’t cause the whole dependency structure to crumble. RequireJS does not support this functionality by default, but it’s easy enough to add it via a plugin. There are already several useful plugins available for RequireJS that offer some interesting features. As of this writing, however, optional module loading doesn’t seem to be among them. That’s not a big problem: rolling out our own2 plugin turns out to be relatively easy. RequireJS plugins are themselves modules: you create them as separate JavaScript files having code wrapped in define call. They can also declare their own dependencies like any other module. The only requirement is that they export an object with certain API: at minimum, it has to include the load method. Since our optional plugin is very simple, load is in fact the only method we have to implement: /* Skeleton of a simple RequireJS plugin module. */ define([], function() { function load(moduleName, parentRequire, onload, config) { // ... } return { load: load, }; }); As its name would hint, load carries out the actual module loading which a plugin is allowed to influence, modify, or even replace with something altogether different. In our case, we don’t want to be too invasive, but we need to detect failure in the original loading procedure and step in. I mentioned previously that module loading is asynchronous, which JavaScript often translates to “callbacks”. Here, load receives the onload callback which we eventually need to invoke. It also get the mysterious parentRequire argument; this is simply a regular require function that’d normally be used if our plugin didn’t stand in the way. Those two are the most important pieces of the puzzle, which overall has a pretty succinct solution: /** * RequireJS plugin for optional module loading. */ define ([], function() { /** Default value to return when a module failed to load. */ var DEFAULT = null; function load(moduleName, parentRequire, onload) { parentRequire([moduleName], onload, function (err) { var failedModule = err.requireModules &amp;&amp; requireModules[0]; console.warn(&#34;Could not load optional module: &#34; + failedModule); requirejs.undef(failedModule); define(failedModule, [], function() { return DEFAULT; }); parentRequire([failedModule], onload); }); } return { load: load, }; }); The logic here is as follows: First, try to load the module normally (via the outer parentRequire call). If it succeeds, onload is called and there is nothing for us to do. If it fails, we log the failedModule and cleanup some internal RequireJS state with requirejs.undef. Most importantly, we define the module as a trivial shim that returns some DEFAULT (here, null). As a result, when we require it again (through the inner parentRequire call), we know it’ll be loaded successfully. Usage Plugins in RequireJS are invoked on a per-module basis. You can specify that a certain dependency &#39;bar&#39; shall be loaded through a plugin &#39;foo&#39; by putting &#39;foo!bar&#39; on the dependency list: define([ &#39;foo!bar&#39;], function(bar) { // ... }); Both &#39;foo&#39; and &#39;bar&#39; represent module paths here: the first one is the path to the plugin module, while the second one is the actual dependency. In a more realistic example — like when our optional loader is involved — both of them would most likely be multi-segments paths: define([ &#39;myapp/ext/require/optional!myapp/common/buttons/awesome-button&#39;, ], function(AwesomeButtonController) { // ... }); As you can see, they can get pretty unreadable rather quickly. It would be better if the plugin prefix consisted of just one segment (i.e. optional!) instead. We can make that happen by adding a mapping to the RequireJS config: requirejs.config({ // ... map: { &#39;*&#39;: { &#39;optional&#39;: &#39;myapp/ext/require/optional&#39;, } } }) With this renaming in place, the loading of non-mandatory dependencies becomes quite a bit clearer: define([ &#39;optional!myapp/common/buttons/awesome-button&#39;, ], function(AwesomeButtonController) { // ... if (!AwesomeButtonController) { // ... (some work around) ... } }); Of course, you still need to actually code around the potential lack of an optional dependency. The if statement above is just an illustrative example; you may find it more sensible to provide some shim instead: AwesomeButtonController = AwesomeButtonController || function() { // ... }; Either way, I recommend trying to keep the size of such conditional logic to a minimum. Ideally, it should be confined to a single place, or — better yet — abstracted behind a function. An actual import statement has made it into the ES6 (ECMAScript 2015) standard but, as of this writing, no browser implements it. ↩ Most of the code for the plugin presented here is based on this StackOverflow answer. ↩" />
<meta name="keywords" content="JavaScript, RequireJS, modules, Web Workers, DOM, AJAX">
<meta property="og:site_name" content="Karol Kuczmarski's Blog"/>
<meta property="og:title" content="Optional loading of RequireJS modules"/>
<meta property="og:description" content="RequireJS is a module loader for JavaScript. Similar to its alternatives such as Browserify, it tries to solve an important problem on the web front(end): dividing JavaScript code into modules for better maintainability while still loading them correctly and efficiently without manual curation of the &lt;script&gt; tags. Once it’s configured correctly (which can be rather non-trivial, though), modules in RequireJS are simply defined as functions that return arbitrary JavaScript objects: define([ &#39;jquery&#39;, &#39;lodash&#39;, &#39;myapp/dep1&#39;, &#39;myapp/dep2&#39;, ], function($, _, dep1, dep2) { // ... all of the module&#39;s code ... return { exportedSymbol1: ..., exportedSymbol2: ..., }; }); Before executing the function, RequireJS loads all the specified dependencies, repeating the process recursively and asynchronously. Return values from module functions are passed as parameters to the next module function, and thus the whole mechanism clicks, serving as a crafty workaround for the lack of proper import functionality1. Relative failures If, at some point in the chain, the desired module cannot be found or loaded, the entire process grinds to a halt with an error. Most of the time, this is perfectly acceptable (or even desirable) behavior, equivalent to an incorrect import statement, invalid #include directive, or similar mistake in other languages. But there are situations when we’d like to proceed with a missing module, because the dependent code is prepared to handle it. The canonical example are Web Workers. Unlike traditional web application code, Web Worker scripts operate outside of a context of any single page, having no access to the DOM tree (because which DOM tree would it be?). Correspondingly, they have no document nor window objects in their global scope. Unfortunately, some libraries (*cough* jQuery *cough*) require those objects as a hard (and usually implicit) dependency. This doesn’t exactly help if we’d like to use them in worker code for other features, not related to DOM. In case of jQuery, for example, it could be the API for making AJAX calls, which is still decidedly more pleasant than dealing with bare XMLHTTPRequest if we’re doing anything non-trivial. Due to this hard dependency on DOM, however, Web Workers cannot require jQuery. No biggie, you may think: browsers supporting workers also offer an excellent, promise-based Fetch API that largely replaces the old AJAX, so we may just use it in worker code. Good thinking indeed, but it doesn’t solve the issue of sharing code between main (“UI”) part of the app and Web Workers. Suppose you have the following dependency graph: The common module has some logic that we’d want reused between regular &lt;script&gt;-based code and a Web Worker, but its dependency on jQuery makes it impossible. It would work, however, if this dependency was a soft one. If common could detect that jQuery is not available and fall back to other solutions (like the Fetch API), we would be able to require it in both execution environments. The optional plugin What we need, it seems, is an ability to say that some dependencies (like &#39;jquery&#39;) are optional. They can be loaded if they’re available but otherwise, they shouldn’t cause the whole dependency structure to crumble. RequireJS does not support this functionality by default, but it’s easy enough to add it via a plugin. There are already several useful plugins available for RequireJS that offer some interesting features. As of this writing, however, optional module loading doesn’t seem to be among them. That’s not a big problem: rolling out our own2 plugin turns out to be relatively easy. RequireJS plugins are themselves modules: you create them as separate JavaScript files having code wrapped in define call. They can also declare their own dependencies like any other module. The only requirement is that they export an object with certain API: at minimum, it has to include the load method. Since our optional plugin is very simple, load is in fact the only method we have to implement: /* Skeleton of a simple RequireJS plugin module. */ define([], function() { function load(moduleName, parentRequire, onload, config) { // ... } return { load: load, }; }); As its name would hint, load carries out the actual module loading which a plugin is allowed to influence, modify, or even replace with something altogether different. In our case, we don’t want to be too invasive, but we need to detect failure in the original loading procedure and step in. I mentioned previously that module loading is asynchronous, which JavaScript often translates to “callbacks”. Here, load receives the onload callback which we eventually need to invoke. It also get the mysterious parentRequire argument; this is simply a regular require function that’d normally be used if our plugin didn’t stand in the way. Those two are the most important pieces of the puzzle, which overall has a pretty succinct solution: /** * RequireJS plugin for optional module loading. */ define ([], function() { /** Default value to return when a module failed to load. */ var DEFAULT = null; function load(moduleName, parentRequire, onload) { parentRequire([moduleName], onload, function (err) { var failedModule = err.requireModules &amp;&amp; requireModules[0]; console.warn(&#34;Could not load optional module: &#34; + failedModule); requirejs.undef(failedModule); define(failedModule, [], function() { return DEFAULT; }); parentRequire([failedModule], onload); }); } return { load: load, }; }); The logic here is as follows: First, try to load the module normally (via the outer parentRequire call). If it succeeds, onload is called and there is nothing for us to do. If it fails, we log the failedModule and cleanup some internal RequireJS state with requirejs.undef. Most importantly, we define the module as a trivial shim that returns some DEFAULT (here, null). As a result, when we require it again (through the inner parentRequire call), we know it’ll be loaded successfully. Usage Plugins in RequireJS are invoked on a per-module basis. You can specify that a certain dependency &#39;bar&#39; shall be loaded through a plugin &#39;foo&#39; by putting &#39;foo!bar&#39; on the dependency list: define([ &#39;foo!bar&#39;], function(bar) { // ... }); Both &#39;foo&#39; and &#39;bar&#39; represent module paths here: the first one is the path to the plugin module, while the second one is the actual dependency. In a more realistic example — like when our optional loader is involved — both of them would most likely be multi-segments paths: define([ &#39;myapp/ext/require/optional!myapp/common/buttons/awesome-button&#39;, ], function(AwesomeButtonController) { // ... }); As you can see, they can get pretty unreadable rather quickly. It would be better if the plugin prefix consisted of just one segment (i.e. optional!) instead. We can make that happen by adding a mapping to the RequireJS config: requirejs.config({ // ... map: { &#39;*&#39;: { &#39;optional&#39;: &#39;myapp/ext/require/optional&#39;, } } }) With this renaming in place, the loading of non-mandatory dependencies becomes quite a bit clearer: define([ &#39;optional!myapp/common/buttons/awesome-button&#39;, ], function(AwesomeButtonController) { // ... if (!AwesomeButtonController) { // ... (some work around) ... } }); Of course, you still need to actually code around the potential lack of an optional dependency. The if statement above is just an illustrative example; you may find it more sensible to provide some shim instead: AwesomeButtonController = AwesomeButtonController || function() { // ... }; Either way, I recommend trying to keep the size of such conditional logic to a minimum. Ideally, it should be confined to a single place, or — better yet — abstracted behind a function. An actual import statement has made it into the ES6 (ECMAScript 2015) standard but, as of this writing, no browser implements it. ↩ Most of the code for the plugin presented here is based on this StackOverflow answer. ↩"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://xion.io/post/code/requirejs-optional.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2015-09-29 22:15:00-07:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="http://xion.io/">
<meta property="article:section" content="Code"/>
<meta property="article:tag" content="JavaScript"/>
<meta property="article:tag" content="RequireJS"/>
<meta property="article:tag" content="modules"/>
<meta property="article:tag" content="Web Workers"/>
<meta property="article:tag" content="DOM"/>
<meta property="article:tag" content="AJAX"/>
<meta property="og:image" content="http://xion.io/logo.jpeg">
  <title>Karol Kuczmarski's Blog &ndash; Optional loading of RequireJS modules</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://xion.io">
        <img src="http://xion.io/logo.jpeg" alt="Karol Kuczmarski" title="Karol Kuczmarski">
      </a>
      <h1><a href="http://xion.io">Karol Kuczmarski</a></h1>
      <p>fn(Tea) -> Code</p>
      <nav>
        <ul class="list">
          <li><a href="http://xion.io/page/about.html#about">About</a></li>
          <li><a href="http://xion.io/page/projects.html#projects">Projects</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-github" href="http://github.com/Xion" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-stack-overflow" href="http://stackoverflow.com/users/434799/xion" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
        <li><a class="sc-twitter" href="http://twitter.com/Xion__" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-google" href="https://plus.google.com/+KarolKuczmarski" target="_blank"><i class="fa fa-google"></i></a></li>
        <li><a class="sc-rss" href="/feeds/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="http://xion.io">Home</a>
      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>
      <a href="http://xion.org.pl/">Old blog</a>
    </nav>

<article>
  <header>
    <h1 id="requirejs-optional">Optional loading of RequireJS&nbsp;modules</h1>
    <p>Posted on Tue 29 September 2015 in <a href="http://xion.io/category/code.html">Code</a></p>
  </header>
  <div>
    <p><a href="http://requirejs.org/">RequireJS</a> is a module loader for JavaScript. Similar to its alternatives such as
<a href="http://browserify.org/">Browserify</a>, it tries to solve an important problem on the web front(end):
dividing JavaScript code into modules for better maintainability while still loading them correctly and efficiently
without manual curation of the <code>&lt;script&gt;</code> tags.</p>
<p>Once it&#8217;s configured correctly (which can be rather <a href="http://requirejs.org/docs/api.html#config">non-trivial</a>, though),
modules in RequireJS are simply <code>define</code>d as functions that return arbitrary JavaScript&nbsp;objects:</p>
<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span>
    <span class="s1">&#39;jquery&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lodash&#39;</span><span class="p">,</span>

    <span class="s1">&#39;myapp/dep1&#39;</span><span class="p">,</span>
    <span class="s1">&#39;myapp/dep2&#39;</span><span class="p">,</span>
<span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dep1</span><span class="p">,</span> <span class="nx">dep2</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ... all of the module&#39;s code ...</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="nx">exportedSymbol1</span><span class="o">:</span> <span class="p">...,</span>
        <span class="nx">exportedSymbol2</span><span class="o">:</span> <span class="p">...,</span>
    <span class="p">};</span>
<span class="p">});</span>
</pre></div>


<p>Before executing the function, RequireJS loads all the specified dependencies, repeating the process recursively
and asynchronously. Return values from module functions are passed as parameters to the next module function,
and thus the whole mechanism clicks, serving as a crafty workaround for the lack of proper <code>import</code> functionality<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>.</p>
<h4>Relative&nbsp;failures</h4>
<p>If, at some point in the chain, the desired module cannot be found or loaded, the entire process grinds to a halt
with an error. Most of the time, this is perfectly acceptable (or even desirable) behavior, equivalent to an incorrect
<code>import</code> statement, invalid <code>#include</code> directive, or similar mistake in other&nbsp;languages.</p>
<p>But there are situations when we&#8217;d like to proceed with a missing module, because the dependent code is prepared
to handle it. The canonical example are
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Web Workers</a>.
Unlike traditional web application code, Web Worker scripts operate outside of a context of any single page,
having no access to the <abbr title="Document Object Model"><span class="caps">DOM</span></abbr> tree (because <em>which</em> <span class="caps">DOM</span> tree would it be?).
Correspondingly, they have no <code>document</code> nor <code>window</code> objects in their global&nbsp;scope.</p>
<p>Unfortunately, some libraries (<em>*cough*</em> jQuery <em>*cough*</em>) require those objects as a hard (and usually implicit)
dependency. This doesn&#8217;t exactly help if we&#8217;d like to use them in worker code for other features, not related to <span class="caps">DOM</span>.
In case of jQuery, for example, it could be the <span class="caps">API</span> for making <span class="caps">AJAX</span> calls, which is still decidedly more pleasant
than dealing with bare <code>XMLHTTPRequest</code> if we&#8217;re doing anything&nbsp;non-trivial.</p>
<p>Due to this hard dependency on <span class="caps">DOM</span>, however, Web Workers cannot <code>require</code> jQuery. No biggie, you may think: browsers
supporting workers also offer an excellent, promise-based
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch <span class="caps">API</span></a> that largely replaces the old <span class="caps">AJAX</span>,
so we may just use it in worker code. Good thinking indeed, but it doesn&#8217;t solve the issue of <em>sharing code</em> between
main (&#8220;<span class="caps">UI</span>&#8221;) part of the app and Web&nbsp;Workers.</p>
<p>Suppose you have the following dependency&nbsp;graph:</p>
<p><div class="graphviz" style="text-align: center;"><img src="data:image/png;base64,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"></div></p>
<p>The <code>common</code> module has some logic that we&#8217;d want reused between regular <code>&lt;script&gt;</code>-based code and a Web Worker,
but its dependency on jQuery makes it impossible. It would work, however, if this dependency was a <em>soft</em> one.
If <code>common</code> could <em>detect</em> that jQuery is not available and fall back to other solutions (like the Fetch <span class="caps">API</span>),
we would be able to <code>require</code> it in both execution&nbsp;environments.</p>
<h4>The <code>optional</code> plugin</h4>
<p>What we need, it seems, is an ability to say that some dependencies (like <code>'jquery'</code>) are <em>optional</em>. They can be loaded
if they&#8217;re available but otherwise, they shouldn&#8217;t cause the whole dependency structure to crumble. RequireJS does not
support this functionality by default, but it&#8217;s easy enough to add it via a <em>plugin</em>.</p>
<p>There are already <a href="https://github.com/jrburke/requirejs/wiki/Plugins">several useful plugins</a> available for RequireJS
that offer some interesting features. As of this writing, however, optional module loading doesn&#8217;t seem to be among them.
That&#8217;s not a big problem: rolling out our own<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup> plugin turns out to be relatively&nbsp;easy.</p>
<p><a href="http://requirejs.org/docs/plugins.html">RequireJS plugins</a> are themselves modules: you create them as separate JavaScript
files having code wrapped in <code>define</code> call. They can also declare their own dependencies like any other module.
The only requirement is that they export an object with <a href="http://requirejs.org/docs/plugins.html#api">certain <span class="caps">API</span></a>:
at minimum, it has to include the <code>load</code> method. Since our <code>optional</code> plugin is very simple, <code>load</code> is in fact
the only method we have to&nbsp;implement:</p>
<div class="highlight"><pre><span class="cm">/* Skeleton of a simple RequireJS plugin module. */</span>

<span class="nx">define</span><span class="p">([],</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

<span class="kd">function</span> <span class="nx">load</span><span class="p">(</span><span class="nx">moduleName</span><span class="p">,</span> <span class="nx">parentRequire</span><span class="p">,</span> <span class="nx">onload</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">return</span> <span class="p">{</span>
    <span class="nx">load</span><span class="o">:</span> <span class="nx">load</span><span class="p">,</span>
<span class="p">};</span>

<span class="p">});</span>
</pre></div>


<p>As its name would hint, <code>load</code> carries out the actual module loading which a plugin is allowed to influence, modify,
or even replace with something altogether different. In our case, we don&#8217;t want to be too invasive, but we need to
detect failure in the original loading procedure and step&nbsp;in.</p>
<p>I mentioned previously that module loading is asynchronous, which JavaScript often translates to &#8220;callbacks&#8221;.
Here, <code>load</code> receives the <code>onload</code> callback which we eventually need to invoke. It also get the mysterious
<code>parentRequire</code> argument; this is simply a regular <code>require</code> function that&#8217;d normally be used if our plugin didn&#8217;t
stand in the&nbsp;way.</p>
<p>Those two are the most important pieces of the puzzle, which overall has a pretty succinct&nbsp;solution:</p>
<div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * RequireJS plugin for optional module loading.</span>
<span class="cm"> */</span>
<span class="nx">define</span> <span class="p">([],</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>


<span class="cm">/** Default value to return when a module failed to load. */</span>
<span class="kd">var</span> <span class="nx">DEFAULT</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">load</span><span class="p">(</span><span class="nx">moduleName</span><span class="p">,</span> <span class="nx">parentRequire</span><span class="p">,</span> <span class="nx">onload</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">parentRequire</span><span class="p">([</span><span class="nx">moduleName</span><span class="p">],</span> <span class="nx">onload</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">failedModule</span> <span class="o">=</span> <span class="nx">err</span><span class="p">.</span><span class="nx">requireModules</span> <span class="o">&amp;&amp;</span> <span class="nx">requireModules</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="s2">&quot;Could not load optional module: &quot;</span> <span class="o">+</span> <span class="nx">failedModule</span><span class="p">);</span>
        <span class="nx">requirejs</span><span class="p">.</span><span class="nx">undef</span><span class="p">(</span><span class="nx">failedModule</span><span class="p">);</span>

        <span class="nx">define</span><span class="p">(</span><span class="nx">failedModule</span><span class="p">,</span> <span class="p">[],</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">DEFAULT</span><span class="p">;</span> <span class="p">});</span>
        <span class="nx">parentRequire</span><span class="p">([</span><span class="nx">failedModule</span><span class="p">],</span> <span class="nx">onload</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="k">return</span> <span class="p">{</span>
    <span class="nx">load</span><span class="o">:</span> <span class="nx">load</span><span class="p">,</span>
<span class="p">};</span>

<span class="p">});</span>
</pre></div>


<p>The logic here is as&nbsp;follows:</p>
<ul>
<li>First, try to load the module normally (via the outer <code>parentRequire</code> call).</li>
<li>If it succeeds, <code>onload</code> is called and there is nothing for us to&nbsp;do.</li>
<li>If it fails, we log the <code>failedModule</code> and cleanup some internal RequireJS state with <code>requirejs.undef</code>.</li>
<li>Most importantly, we <code>define</code> the module as a trivial shim that returns some <code>DEFAULT</code> (here, <code>null</code>).</li>
<li>As a result, when we require it again (through the inner <code>parentRequire</code> call), we <em>know</em> it&#8217;ll be loaded&nbsp;successfully.</li>
</ul>
<h4>Usage</h4>
<p>Plugins in RequireJS are invoked on a per-module basis. You can specify that a certain dependency <code>'bar'</code> shall be loaded
through a plugin <code>'foo'</code> by putting <code>'foo!bar'</code> on the dependency&nbsp;list:</p>
<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span> <span class="s1">&#39;foo!bar&#39;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">bar</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">});</span>
</pre></div>


<p>Both <code>'foo'</code> and <code>'bar'</code> represent module paths here: the first one is the path to the <em>plugin</em> module,
while the second one is the actual dependency. In a more realistic example &#8212; like when our optional loader is involved &#8212;
both of them would most likely be multi-segments&nbsp;paths:</p>
<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span>
    <span class="s1">&#39;myapp/ext/require/optional!myapp/common/buttons/awesome-button&#39;</span><span class="p">,</span>
<span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">AwesomeButtonController</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">});</span>
</pre></div>


<p>As you can see, they can get pretty unreadable rather quickly. It would be better if the plugin prefix consisted
of just one segment (i.e. <code>optional!</code>) instead. We can make that happen by adding
<a href="http://requirejs.org/docs/api.html#config-map">a mapping</a> to the RequireJS&nbsp;config:</p>
<div class="highlight"><pre><span class="nx">requirejs</span><span class="p">.</span><span class="nx">config</span><span class="p">({</span>
    <span class="c1">// ...</span>
    <span class="nx">map</span><span class="o">:</span> <span class="p">{</span>
        <span class="s1">&#39;*&#39;</span><span class="o">:</span> <span class="p">{</span>
            <span class="s1">&#39;optional&#39;</span><span class="o">:</span> <span class="s1">&#39;myapp/ext/require/optional&#39;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})</span>
</pre></div>


<p>With this renaming in place, the loading of non-mandatory dependencies becomes quite a bit&nbsp;clearer:</p>
<div class="highlight"><pre><span class="nx">define</span><span class="p">([</span>
    <span class="s1">&#39;optional!myapp/common/buttons/awesome-button&#39;</span><span class="p">,</span>
<span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">AwesomeButtonController</span><span class="p">)</span> <span class="p">{</span>

<span class="c1">// ...</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">AwesomeButtonController</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ... (some work around) ...</span>
<span class="p">}</span>

<span class="p">});</span>
</pre></div>


<p>Of course, you still need to actually code around the potential lack of an optional dependency.
The <code>if</code> statement above is just an illustrative example; you may find it more sensible to provide some shim&nbsp;instead:</p>
<div class="highlight"><pre><span class="nx">AwesomeButtonController</span> <span class="o">=</span> <span class="nx">AwesomeButtonController</span> <span class="o">||</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>


<p>Either way, I recommend trying to keep the size of such conditional logic to a minimum.
Ideally, it should be confined to a single place, or &#8212; better yet &#8212; abstracted behind a&nbsp;function.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>An actual <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import"><code>import</code> statement</a>
has made it into the <span class="caps">ES6</span> (ECMAScript 2015) standard but, as of this writing, no browser implements it.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Most of the code for the plugin presented here is based on
<a href="http://stackoverflow.com/a/27422370/434799">this StackOverflow answer</a>.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="http://xion.io/tag/javascript.html">JavaScript</a>
      <a href="http://xion.io/tag/requirejs.html">RequireJS</a>
      <a href="http://xion.io/tag/modules.html">modules</a>
      <a href="http://xion.io/tag/web-workers.html">Web Workers</a>
      <a href="http://xion.io/tag/dom.html">DOM</a>
      <a href="http://xion.io/tag/ajax.html">AJAX</a>
    </p>
  </div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'xionblog';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</article>

    <footer>
<p>
  &copy; Karol Kuczmarski 2017 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-27379564-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "Optional loading of RequireJS modules",
  "headline": "Optional loading of RequireJS modules",
  "datePublished": "2015-09-29 22:15:00-07:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "Karol Kuczmarski",
    "url": "http://xion.io/"
  },
  "image": "http://xion.io/logo.jpeg",
  "url": "http://xion.io/post/code/requirejs-optional.html",
  "description": "RequireJS is a module loader for JavaScript. Similar to its alternatives such as Browserify, it tries to solve an important problem on the web front(end): dividing JavaScript code into modules for better maintainability while still loading them correctly and efficiently without manual curation of the <script> tags. Once it’s configured correctly (which can be rather non-trivial, though), modules in RequireJS are simply defined as functions that return arbitrary JavaScript objects: define([ 'jquery', 'lodash', 'myapp/dep1', 'myapp/dep2', ], function($, _, dep1, dep2) { // ... all of the module's code ... return { exportedSymbol1: ..., exportedSymbol2: ..., }; }); Before executing the function, RequireJS loads all the specified dependencies, repeating the process recursively and asynchronously. Return values from module functions are passed as parameters to the next module function, and thus the whole mechanism clicks, serving as a crafty workaround for the lack of proper import functionality1. Relative failures If, at some point in the chain, the desired module cannot be found or loaded, the entire process grinds to a halt with an error. Most of the time, this is perfectly acceptable (or even desirable) behavior, equivalent to an incorrect import statement, invalid #include directive, or similar mistake in other languages. But there are situations when we’d like to proceed with a missing module, because the dependent code is prepared to handle it. The canonical example are Web Workers. Unlike traditional web application code, Web Worker scripts operate outside of a context of any single page, having no access to the DOM tree (because which DOM tree would it be?). Correspondingly, they have no document nor window objects in their global scope. Unfortunately, some libraries (*cough* jQuery *cough*) require those objects as a hard (and usually implicit) dependency. This doesn’t exactly help if we’d like to use them in worker code for other features, not related to DOM. In case of jQuery, for example, it could be the API for making AJAX calls, which is still decidedly more pleasant than dealing with bare XMLHTTPRequest if we’re doing anything non-trivial. Due to this hard dependency on DOM, however, Web Workers cannot require jQuery. No biggie, you may think: browsers supporting workers also offer an excellent, promise-based Fetch API that largely replaces the old AJAX, so we may just use it in worker code. Good thinking indeed, but it doesn’t solve the issue of sharing code between main (“UI”) part of the app and Web Workers. Suppose you have the following dependency graph: The common module has some logic that we’d want reused between regular <script>-based code and a Web Worker, but its dependency on jQuery makes it impossible. It would work, however, if this dependency was a soft one. If common could detect that jQuery is not available and fall back to other solutions (like the Fetch API), we would be able to require it in both execution environments. The optional plugin What we need, it seems, is an ability to say that some dependencies (like 'jquery') are optional. They can be loaded if they’re available but otherwise, they shouldn’t cause the whole dependency structure to crumble. RequireJS does not support this functionality by default, but it’s easy enough to add it via a plugin. There are already several useful plugins available for RequireJS that offer some interesting features. As of this writing, however, optional module loading doesn’t seem to be among them. That’s not a big problem: rolling out our own2 plugin turns out to be relatively easy. RequireJS plugins are themselves modules: you create them as separate JavaScript files having code wrapped in define call. They can also declare their own dependencies like any other module. The only requirement is that they export an object with certain API: at minimum, it has to include the load method. Since our optional plugin is very simple, load is in fact the only method we have to implement: /* Skeleton of a simple RequireJS plugin module. */ define([], function() { function load(moduleName, parentRequire, onload, config) { // ... } return { load: load, }; }); As its name would hint, load carries out the actual module loading which a plugin is allowed to influence, modify, or even replace with something altogether different. In our case, we don’t want to be too invasive, but we need to detect failure in the original loading procedure and step in. I mentioned previously that module loading is asynchronous, which JavaScript often translates to “callbacks”. Here, load receives the onload callback which we eventually need to invoke. It also get the mysterious parentRequire argument; this is simply a regular require function that’d normally be used if our plugin didn’t stand in the way. Those two are the most important pieces of the puzzle, which overall has a pretty succinct solution: /** * RequireJS plugin for optional module loading. */ define ([], function() { /** Default value to return when a module failed to load. */ var DEFAULT = null; function load(moduleName, parentRequire, onload) { parentRequire([moduleName], onload, function (err) { var failedModule = err.requireModules && requireModules[0]; console.warn("Could not load optional module: " + failedModule); requirejs.undef(failedModule); define(failedModule, [], function() { return DEFAULT; }); parentRequire([failedModule], onload); }); } return { load: load, }; }); The logic here is as follows: First, try to load the module normally (via the outer parentRequire call). If it succeeds, onload is called and there is nothing for us to do. If it fails, we log the failedModule and cleanup some internal RequireJS state with requirejs.undef. Most importantly, we define the module as a trivial shim that returns some DEFAULT (here, null). As a result, when we require it again (through the inner parentRequire call), we know it’ll be loaded successfully. Usage Plugins in RequireJS are invoked on a per-module basis. You can specify that a certain dependency 'bar' shall be loaded through a plugin 'foo' by putting 'foo!bar' on the dependency list: define([ 'foo!bar'], function(bar) { // ... }); Both 'foo' and 'bar' represent module paths here: the first one is the path to the plugin module, while the second one is the actual dependency. In a more realistic example — like when our optional loader is involved — both of them would most likely be multi-segments paths: define([ 'myapp/ext/require/optional!myapp/common/buttons/awesome-button', ], function(AwesomeButtonController) { // ... }); As you can see, they can get pretty unreadable rather quickly. It would be better if the plugin prefix consisted of just one segment (i.e. optional!) instead. We can make that happen by adding a mapping to the RequireJS config: requirejs.config({ // ... map: { '*': { 'optional': 'myapp/ext/require/optional', } } }) With this renaming in place, the loading of non-mandatory dependencies becomes quite a bit clearer: define([ 'optional!myapp/common/buttons/awesome-button', ], function(AwesomeButtonController) { // ... if (!AwesomeButtonController) { // ... (some work around) ... } }); Of course, you still need to actually code around the potential lack of an optional dependency. The if statement above is just an illustrative example; you may find it more sensible to provide some shim instead: AwesomeButtonController = AwesomeButtonController || function() { // ... }; Either way, I recommend trying to keep the size of such conditional logic to a minimum. Ideally, it should be confined to a single place, or — better yet — abstracted behind a function. An actual import statement has made it into the ES6 (ECMAScript 2015) standard but, as of this writing, no browser implements it. ↩ Most of the code for the plugin presented here is based on this StackOverflow answer. ↩"
}
</script></body>
</html>