<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/font-awesome.min.css">

    <link href="http://xion.io/style.css" rel="stylesheet">




  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

<meta name="author" content="Karol Kuczmarski" />
<meta name="description" content="One of the downsides of working with a simple and minimalistic programming language such as Go is that abstracting for code reuse is often rather challenging. What’s brought up most often in this context is Go’s lack of support for generics (higher order types). But here I wanted to talk about a different mechanism that — unlike generics — can be transplanted to Go quite successfully: function decorators. Canonical example Decorators are most commonly found in Python (where they can be applied not just to functions, but also classes), but have syntactical analogues in Java (annotations), C# (attributes), and a few other languages. A decorator looks like a modifier adorning a function definition, distinguished by its initial @ sign: @app.route(&#39;/home&#39;) @login_required def home(): return render_template(&#39;user/home.html&#39;) Even if you’re not familiar with the particular web framework this request handler is meant for — or indeed, the Python language itself — it shouldn’t be too difficult to figure out what purpose the two decorators serve. What’s really important is that their goals are neatly separated from essential logic of the request handler: it doesn’t have to explicitly check if the user is logged in — it has the @login_required decorator it doesn’t have to be separately registered in some centalized URL routing choke point — it has the @app.route decorator instead Such separation of concerns is a desirable quality in software, because it makes it easier to reason about different aspects of the system. Under the hood Behind this synctactic sugar and lofty phrasing, the code above is still perfectly equivalent to its undecorated version: def home(): if not current_user.is_authenticated: abort(403, &#34;Login Required&#34;) return render_template(&#39;user/home.html&#39;) app.add_url_route(&#39;/home&#39;, view_func=home) No source code transformations take place, either: @login_required doesn’t actually “inject” the if statement at the beginning of home function. What happens instead is that it takes the whole function and wraps it in a new one which also contains the crucial check: def login_required(func): &#34;&#34;&#34;Grossly simplified version of a decorator enforcing user login.&#34;&#34;&#34; def wrapped(*args, **kwargs): if not current_user.is_authenticated: abort(403, &#34;Login Required&#34;) return func(*args, **kwargs) return wrapped Given this definition, decorating home simply means passing it to the login_required function, and calling its result a new home: def home(): return render_template(&#39;user/home.html&#39;) home = login_required(home) As you’ve probably guessed, the @ syntax is nothing else than a syntatic sugar for the above. But how sweet a sugar it is! (The @app.route decorator is simultaneously simpler and more complicated. I recommend having a direct look at its source code for more insight). What gophers can learn Unlike Python, in Go, we are out of luck when it comes to dedicated language support for decorators. However, the general principle still applies: we can decorate functions by writing — ahem — decorator functions. Consider, for example, a trivial net/http request handler: func hello(w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, &#34;Hello, world!\n&#34;) } Any real web application will have many similar handlers. They are usually wired to their corresponding URL paths during program startup: func main() { http.HandleFunc(&#34;/hello&#34;, hello) // ... } This approach to routing configuration provides an opportunity to decorate some (or all) of the request handlers with any auxiliary functionality that the application may require. Handler in, handler out To do that, though, we need to write the necessary decorator functions first. For a simplest possible example, let’s create one that automatically fills in the Server: header of HTTP response with the name and version of our web application: func WithServerHeader(h http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { w.Header().Set(&#34;Server&#34;, &#34;HelloServer v0.0.1&#34;) h(w, r) } } Using it is then a simple matter of wrapping the original handler in a decorator call: http.HandleFunc(&#34;/hello&#34;, WithServerHeader(hello)) As it both accepts and returns a http.HandlerFunc — a function type matching request handlers’ signatures — we don’t need anything else to be able to wrap our handlers in as many decorators as necessary: http.HandleFunc(&#34;/&#34;, WithServerHeader(index)) http.HandleFunc(&#34;/home&#34;, WithServerHeader(LoginRequired(home))) http.HandleFunc(&#34;/api/share&#34;, WithServerHeader(LoginRequired(CsrfProtected(api.Share)))) It’s possible simply by the means of ordinary function composition. Going meta Looking at the last line of the example above — which is made-up but could very well come from actual production code — you probably can’t help but notice that stacking function calls like that creates a somewhat messy amalgamation of parentheses. Beyond three or four items, a decorator chain such as this one becomes rather unwieldy to follow. If we’re concerned about readability, it’s possible to alleviate the issue by taking another step up the abstraction ladder. Rather than composing the decorators explicitly, we can write a function that does it for us: type HttpHandlerDecorator func(http.HandlerFunc) http.HandlerFunc func Handler(h http.HandlerFunc, decors ...HttpHandlerDecorator) http.HandlerFunc { for i := range decors { d := decors[len(decors) - 1 - i] // iterate in reverse h = d(h) } return h } and thus eliminate all the parentheses: http.HandleFunc(&#34;/api/share&#34;, Handler(api.Share, WithServerHeader, LoginRequired, CsrfProtected)) This technique proves especially valuable if the decorators themselves are parameterized: http.HandleFunc(&#34;/api/notifications&#34;, Handler(api.Notifications, WithServerHeader, LoginRequired, Cached(time.Duration(5)*time.Minute))) In practice, you may find it valuable to wrap the complete http.HandleFunc call to accept a request handler along with its decorator chain, or the equivalent of such a call in any of the numerous Go web frameworks." />
<meta name="keywords" content="Go, functions, decorators">
<meta property="og:site_name" content="Karol Kuczmarski's Blog"/>
<meta property="og:title" content="Decorated functions in Go"/>
<meta property="og:description" content="One of the downsides of working with a simple and minimalistic programming language such as Go is that abstracting for code reuse is often rather challenging. What’s brought up most often in this context is Go’s lack of support for generics (higher order types). But here I wanted to talk about a different mechanism that — unlike generics — can be transplanted to Go quite successfully: function decorators. Canonical example Decorators are most commonly found in Python (where they can be applied not just to functions, but also classes), but have syntactical analogues in Java (annotations), C# (attributes), and a few other languages. A decorator looks like a modifier adorning a function definition, distinguished by its initial @ sign: @app.route(&#39;/home&#39;) @login_required def home(): return render_template(&#39;user/home.html&#39;) Even if you’re not familiar with the particular web framework this request handler is meant for — or indeed, the Python language itself — it shouldn’t be too difficult to figure out what purpose the two decorators serve. What’s really important is that their goals are neatly separated from essential logic of the request handler: it doesn’t have to explicitly check if the user is logged in — it has the @login_required decorator it doesn’t have to be separately registered in some centalized URL routing choke point — it has the @app.route decorator instead Such separation of concerns is a desirable quality in software, because it makes it easier to reason about different aspects of the system. Under the hood Behind this synctactic sugar and lofty phrasing, the code above is still perfectly equivalent to its undecorated version: def home(): if not current_user.is_authenticated: abort(403, &#34;Login Required&#34;) return render_template(&#39;user/home.html&#39;) app.add_url_route(&#39;/home&#39;, view_func=home) No source code transformations take place, either: @login_required doesn’t actually “inject” the if statement at the beginning of home function. What happens instead is that it takes the whole function and wraps it in a new one which also contains the crucial check: def login_required(func): &#34;&#34;&#34;Grossly simplified version of a decorator enforcing user login.&#34;&#34;&#34; def wrapped(*args, **kwargs): if not current_user.is_authenticated: abort(403, &#34;Login Required&#34;) return func(*args, **kwargs) return wrapped Given this definition, decorating home simply means passing it to the login_required function, and calling its result a new home: def home(): return render_template(&#39;user/home.html&#39;) home = login_required(home) As you’ve probably guessed, the @ syntax is nothing else than a syntatic sugar for the above. But how sweet a sugar it is! (The @app.route decorator is simultaneously simpler and more complicated. I recommend having a direct look at its source code for more insight). What gophers can learn Unlike Python, in Go, we are out of luck when it comes to dedicated language support for decorators. However, the general principle still applies: we can decorate functions by writing — ahem — decorator functions. Consider, for example, a trivial net/http request handler: func hello(w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, &#34;Hello, world!\n&#34;) } Any real web application will have many similar handlers. They are usually wired to their corresponding URL paths during program startup: func main() { http.HandleFunc(&#34;/hello&#34;, hello) // ... } This approach to routing configuration provides an opportunity to decorate some (or all) of the request handlers with any auxiliary functionality that the application may require. Handler in, handler out To do that, though, we need to write the necessary decorator functions first. For a simplest possible example, let’s create one that automatically fills in the Server: header of HTTP response with the name and version of our web application: func WithServerHeader(h http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { w.Header().Set(&#34;Server&#34;, &#34;HelloServer v0.0.1&#34;) h(w, r) } } Using it is then a simple matter of wrapping the original handler in a decorator call: http.HandleFunc(&#34;/hello&#34;, WithServerHeader(hello)) As it both accepts and returns a http.HandlerFunc — a function type matching request handlers’ signatures — we don’t need anything else to be able to wrap our handlers in as many decorators as necessary: http.HandleFunc(&#34;/&#34;, WithServerHeader(index)) http.HandleFunc(&#34;/home&#34;, WithServerHeader(LoginRequired(home))) http.HandleFunc(&#34;/api/share&#34;, WithServerHeader(LoginRequired(CsrfProtected(api.Share)))) It’s possible simply by the means of ordinary function composition. Going meta Looking at the last line of the example above — which is made-up but could very well come from actual production code — you probably can’t help but notice that stacking function calls like that creates a somewhat messy amalgamation of parentheses. Beyond three or four items, a decorator chain such as this one becomes rather unwieldy to follow. If we’re concerned about readability, it’s possible to alleviate the issue by taking another step up the abstraction ladder. Rather than composing the decorators explicitly, we can write a function that does it for us: type HttpHandlerDecorator func(http.HandlerFunc) http.HandlerFunc func Handler(h http.HandlerFunc, decors ...HttpHandlerDecorator) http.HandlerFunc { for i := range decors { d := decors[len(decors) - 1 - i] // iterate in reverse h = d(h) } return h } and thus eliminate all the parentheses: http.HandleFunc(&#34;/api/share&#34;, Handler(api.Share, WithServerHeader, LoginRequired, CsrfProtected)) This technique proves especially valuable if the decorators themselves are parameterized: http.HandleFunc(&#34;/api/notifications&#34;, Handler(api.Notifications, WithServerHeader, LoginRequired, Cached(time.Duration(5)*time.Minute))) In practice, you may find it valuable to wrap the complete http.HandleFunc call to accept a request handler along with its decorator chain, or the equivalent of such a call in any of the numerous Go web frameworks."/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://xion.io/post/code/go-decorated-functions.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2015-09-04 20:27:00-07:00"/>
<meta property="article:modified_time" content="2015-09-05 08:36:00-07:00"/>
<meta property="article:author" content="http://xion.io/">
<meta property="article:section" content="Code"/>
<meta property="article:tag" content="Go"/>
<meta property="article:tag" content="functions"/>
<meta property="article:tag" content="decorators"/>
<meta property="og:image" content="http://xion.io/logo.jpeg">
  <title>Karol Kuczmarski's Blog &ndash; Decorated functions in Go</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://xion.io">
        <img src="http://xion.io/logo.jpeg" alt="Karol Kuczmarski" title="Karol Kuczmarski">
      </a>
      <h1><a href="http://xion.io">Karol Kuczmarski</a></h1>
      <p>fn(Tea) -> Code</p>
      <nav>
        <ul class="list">
          <li><a href="http://xion.io/page/about.html#about">About</a></li>
          <li><a href="http://xion.io/page/projects.html#projects">Projects</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-github" href="http://github.com/Xion" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-stack-overflow" href="http://stackoverflow.com/users/434799/xion" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
        <li><a class="sc-twitter" href="http://twitter.com/Xion__" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-google" href="https://plus.google.com/+KarolKuczmarski" target="_blank"><i class="fa fa-google"></i></a></li>
        <li><a class="sc-rss" href="/feeds/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="http://xion.io">Home</a>
      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>
      <a href="http://xion.org.pl/">Old blog</a>
    </nav>

<article>
  <header>
    <h1 id="go-decorated-functions">Decorated functions in&nbsp;Go</h1>
    <p>Posted on Fri 04 September 2015 in <a href="http://xion.io/category/code.html">Code</a></p>
  </header>
  <div>
    <p>One of the downsides of working with a simple and minimalistic programming language such as <a href="http://golang.org">Go</a>
is that <a href="http://blog.atte.ro/2015/08/29/golang-code-reuse.html">abstracting for code reuse</a>
is often rather challenging. What&#8217;s brought up most often in this context is Go&#8217;s lack of support for generics
(higher order&nbsp;types).</p>
<p>But here I wanted to talk about a different mechanism that &#8212; unlike generics &#8212; can be transplanted to Go
quite successfully: function&nbsp;decorators.</p>
<h4>Canonical&nbsp;example</h4>
<p>Decorators are most commonly found in Python (where they can be applied not just to functions, but also classes),
but have syntactical analogues in Java (annotations), C# (attributes), and a few other&nbsp;languages.</p>
<p>A <em>decorator</em> looks like a modifier adorning a function definition, distinguished by its initial <code>@</code> sign:</p>
<div class="highlight"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/home&#39;</span><span class="p">)</span>
<span class="nd">@login_required</span>
<span class="k">def</span> <span class="nf">home</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;user/home.html&#39;</span><span class="p">)</span>
</pre></div>


<p>Even if you&#8217;re not familiar with the <a href="http://flask.pocoo.org">particular web framework</a> this request handler is meant for
&#8212; or indeed, the Python language itself &#8212; it shouldn&#8217;t be too difficult to figure out what purpose the two decorators&nbsp;serve.</p>
<p>What&#8217;s really important is that their goals are neatly separated from essential logic of the request&nbsp;handler:</p>
<ul>
<li>it doesn&#8217;t have to explicitly check if the user is logged in &#8212; it has the <code>@login_required</code> decorator</li>
<li>it doesn&#8217;t have to be separately registered in some
<a href="https://docs.djangoproject.com/en/1.8/topics/http/urls/#example">centalized <span class="caps">URL</span> routing choke point</a> &#8212;
it has the <code>@app.route</code> decorator&nbsp;instead</li>
</ul>
<p>Such <em>separation of concerns</em> is a desirable quality in software, because it makes it easier
to reason about different aspects of the&nbsp;system.</p>
<h4>Under the&nbsp;hood</h4>
<p>Behind this synctactic sugar and lofty phrasing, the code above is still perfectly equivalent
to its undecorated&nbsp;version:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">home</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">current_user</span><span class="o">.</span><span class="n">is_authenticated</span><span class="p">:</span>
        <span class="n">abort</span><span class="p">(</span><span class="mi">403</span><span class="p">,</span> <span class="s">&quot;Login Required&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;user/home.html&#39;</span><span class="p">)</span>

<span class="n">app</span><span class="o">.</span><span class="n">add_url_route</span><span class="p">(</span><span class="s">&#39;/home&#39;</span><span class="p">,</span> <span class="n">view_func</span><span class="o">=</span><span class="n">home</span><span class="p">)</span>
</pre></div>


<p>No source code transformations take place, either: <code>@login_required</code> doesn&#8217;t actually &#8220;inject&#8221; the <code>if</code> statement
at the beginning of <code>home</code> function. What happens instead is that it takes the whole function and <em>wraps it</em>
in a new one which also contains the crucial&nbsp;check:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">login_required</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Grossly simplified version of a decorator enforcing user login.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">current_user</span><span class="o">.</span><span class="n">is_authenticated</span><span class="p">:</span>
            <span class="n">abort</span><span class="p">(</span><span class="mi">403</span><span class="p">,</span> <span class="s">&quot;Login Required&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapped</span>
</pre></div>


<p>Given this definition, decorating <code>home</code> simply means passing it to the <code>login_required</code> function, and calling its result
a new <code>home</code>:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">home</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s">&#39;user/home.html&#39;</span><span class="p">)</span>

<span class="n">home</span> <span class="o">=</span> <span class="n">login_required</span><span class="p">(</span><span class="n">home</span><span class="p">)</span>
</pre></div>


<p>As you&#8217;ve probably guessed, the <code>@</code> syntax is nothing else than a syntatic sugar for the above.
But how sweet a sugar it&nbsp;is!</p>
<p><small>(The <code>@app.route</code> decorator is simultaneously simpler and more complicated. I recommend having a direct look at
<a href="https://github.com/mitsuhiko/flask/blob/2446ca63a8d840a35ea4eac02672b24a6fcf406f/flask/app.py#L1040">its source code</a>
for more insight).</small></p>
<h4>What gophers can&nbsp;learn</h4>
<p>Unlike Python, in Go, we are out of luck when it comes to dedicated language support for decorators.
However, the general principle still applies: we can decorate functions by writing &#8212; <em>ahem</em> &#8212; decorator&nbsp;functions.</p>
<p>Consider, for example, a trivial <code>net/http</code> request&nbsp;handler:</p>
<div class="highlight"><pre><span class="kd">func</span> <span class="nx">hello</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprint</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;Hello, world!\n&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>Any real web application will have many similar handlers. They are usually wired to their corresponding <span class="caps">URL</span> paths
during program&nbsp;startup:</p>
<div class="highlight"><pre><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/hello&quot;</span><span class="p">,</span> <span class="nx">hello</span><span class="p">)</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>


<p>This approach to routing configuration provides an opportunity to decorate some (or all) of the request handlers with
any auxiliary functionality that the application may&nbsp;require.</p>
<h4>Handler in, handler&nbsp;out</h4>
<p>To do that, though, we need to write the necessary decorator functions first. For a simplest possible example,
let&#8217;s create one that automatically fills in the <code>Server:</code> header of <span class="caps">HTTP</span> response with the name and version
of our web&nbsp;application:</p>
<div class="highlight"><pre><span class="kd">func</span> <span class="nx">WithServerHeader</span><span class="p">(</span><span class="nx">h</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">)</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">w</span><span class="p">.</span><span class="nx">Header</span><span class="p">().</span><span class="nx">Set</span><span class="p">(</span><span class="s">&quot;Server&quot;</span><span class="p">,</span> <span class="s">&quot;HelloServer v0.0.1&quot;</span><span class="p">)</span>
        <span class="nx">h</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Using it is then a simple matter of wrapping the original handler in a decorator&nbsp;call:</p>
<div class="highlight"><pre><span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/hello&quot;</span><span class="p">,</span> <span class="nx">WithServerHeader</span><span class="p">(</span><span class="nx">hello</span><span class="p">))</span>
</pre></div>


<p>As it both accepts and returns a <code>http.HandlerFunc</code> &#8212; a function type matching request handlers&#8217; signatures &#8212;
we don&#8217;t need anything else to be able to wrap our handlers in as many decorators as&nbsp;necessary:</p>
<div class="highlight"><pre><span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="nx">WithServerHeader</span><span class="p">(</span><span class="nx">index</span><span class="p">))</span>
<span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/home&quot;</span><span class="p">,</span> <span class="nx">WithServerHeader</span><span class="p">(</span><span class="nx">LoginRequired</span><span class="p">(</span><span class="nx">home</span><span class="p">)))</span>
<span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/api/share&quot;</span><span class="p">,</span> <span class="nx">WithServerHeader</span><span class="p">(</span><span class="nx">LoginRequired</span><span class="p">(</span><span class="nx">CsrfProtected</span><span class="p">(</span><span class="nx">api</span><span class="p">.</span><span class="nx">Share</span><span class="p">))))</span>
</pre></div>


<p>It&#8217;s possible simply by the means of ordinary function&nbsp;composition.</p>
<h4>Going&nbsp;meta</h4>
<p>Looking at the last line of the example above &#8212; which is made-up but could very well come from actual production code
&#8212; you probably can&#8217;t help but notice that stacking function calls like that creates a somewhat messy amalgamation
of parentheses. Beyond three or four items, a decorator chain such as this one becomes rather unwieldy to&nbsp;follow.</p>
<p>If we&#8217;re concerned about readability, it&#8217;s possible to alleviate the issue by taking another step up
the abstraction ladder. Rather than composing the decorators explicitly, we can write a function that does it for&nbsp;us:</p>
<div class="highlight"><pre><span class="kd">type</span> <span class="nx">HttpHandlerDecorator</span> <span class="kd">func</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">)</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span>

<span class="kd">func</span> <span class="nx">Handler</span><span class="p">(</span><span class="nx">h</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">,</span> <span class="nx">decors</span> <span class="o">...</span><span class="nx">HttpHandlerDecorator</span><span class="p">)</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">decors</span> <span class="p">{</span>
        <span class="nx">d</span> <span class="o">:=</span> <span class="nx">decors</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">decors</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nx">i</span><span class="p">]</span>  <span class="c1">// iterate in reverse</span>
        <span class="nx">h</span> <span class="p">=</span> <span class="nx">d</span><span class="p">(</span><span class="nx">h</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">h</span>
<span class="p">}</span>
</pre></div>


<p>and thus eliminate all the&nbsp;parentheses:</p>
<div class="highlight"><pre><span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/api/share&quot;</span><span class="p">,</span> <span class="nx">Handler</span><span class="p">(</span><span class="nx">api</span><span class="p">.</span><span class="nx">Share</span><span class="p">,</span>
    <span class="nx">WithServerHeader</span><span class="p">,</span> <span class="nx">LoginRequired</span><span class="p">,</span> <span class="nx">CsrfProtected</span><span class="p">))</span>
</pre></div>


<p>This technique proves especially valuable if the decorators themselves are&nbsp;parameterized:</p>
<div class="highlight"><pre><span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/api/notifications&quot;</span><span class="p">,</span> <span class="nx">Handler</span><span class="p">(</span><span class="nx">api</span><span class="p">.</span><span class="nx">Notifications</span><span class="p">,</span>
    <span class="nx">WithServerHeader</span><span class="p">,</span> <span class="nx">LoginRequired</span><span class="p">,</span> <span class="nx">Cached</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span><span class="p">)))</span>
</pre></div>


<p>In practice, you may find it valuable to wrap the complete <code>http.HandleFunc</code> call to accept a request handler
along with its decorator chain, or the equivalent of such a call in any of the numerous
<a href="https://corner.squareup.com/2014/05/evaluating-go-frameworks.html">Go web frameworks</a>.</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="http://xion.io/tag/go.html">Go</a>
      <a href="http://xion.io/tag/functions.html">functions</a>
      <a href="http://xion.io/tag/decorators.html">decorators</a>
    </p>
  </div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'xionblog';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</article>

    <footer>
<p>
  &copy; Karol Kuczmarski 2017 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-27379564-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "Decorated functions in Go",
  "headline": "Decorated functions in Go",
  "datePublished": "2015-09-04 20:27:00-07:00",
  "dateModified": "2015-09-05 08:36:00-07:00",
  "author": {
    "@type": "Person",
    "name": "Karol Kuczmarski",
    "url": "http://xion.io/"
  },
  "image": "http://xion.io/logo.jpeg",
  "url": "http://xion.io/post/code/go-decorated-functions.html",
  "description": "One of the downsides of working with a simple and minimalistic programming language such as Go is that abstracting for code reuse is often rather challenging. What’s brought up most often in this context is Go’s lack of support for generics (higher order types). But here I wanted to talk about a different mechanism that — unlike generics — can be transplanted to Go quite successfully: function decorators. Canonical example Decorators are most commonly found in Python (where they can be applied not just to functions, but also classes), but have syntactical analogues in Java (annotations), C# (attributes), and a few other languages. A decorator looks like a modifier adorning a function definition, distinguished by its initial @ sign: @app.route('/home') @login_required def home(): return render_template('user/home.html') Even if you’re not familiar with the particular web framework this request handler is meant for — or indeed, the Python language itself — it shouldn’t be too difficult to figure out what purpose the two decorators serve. What’s really important is that their goals are neatly separated from essential logic of the request handler: it doesn’t have to explicitly check if the user is logged in — it has the @login_required decorator it doesn’t have to be separately registered in some centalized URL routing choke point — it has the @app.route decorator instead Such separation of concerns is a desirable quality in software, because it makes it easier to reason about different aspects of the system. Under the hood Behind this synctactic sugar and lofty phrasing, the code above is still perfectly equivalent to its undecorated version: def home(): if not current_user.is_authenticated: abort(403, "Login Required") return render_template('user/home.html') app.add_url_route('/home', view_func=home) No source code transformations take place, either: @login_required doesn’t actually “inject” the if statement at the beginning of home function. What happens instead is that it takes the whole function and wraps it in a new one which also contains the crucial check: def login_required(func): """Grossly simplified version of a decorator enforcing user login.""" def wrapped(*args, **kwargs): if not current_user.is_authenticated: abort(403, "Login Required") return func(*args, **kwargs) return wrapped Given this definition, decorating home simply means passing it to the login_required function, and calling its result a new home: def home(): return render_template('user/home.html') home = login_required(home) As you’ve probably guessed, the @ syntax is nothing else than a syntatic sugar for the above. But how sweet a sugar it is! (The @app.route decorator is simultaneously simpler and more complicated. I recommend having a direct look at its source code for more insight). What gophers can learn Unlike Python, in Go, we are out of luck when it comes to dedicated language support for decorators. However, the general principle still applies: we can decorate functions by writing — ahem — decorator functions. Consider, for example, a trivial net/http request handler: func hello(w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, "Hello, world!\n") } Any real web application will have many similar handlers. They are usually wired to their corresponding URL paths during program startup: func main() { http.HandleFunc("/hello", hello) // ... } This approach to routing configuration provides an opportunity to decorate some (or all) of the request handlers with any auxiliary functionality that the application may require. Handler in, handler out To do that, though, we need to write the necessary decorator functions first. For a simplest possible example, let’s create one that automatically fills in the Server: header of HTTP response with the name and version of our web application: func WithServerHeader(h http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { w.Header().Set("Server", "HelloServer v0.0.1") h(w, r) } } Using it is then a simple matter of wrapping the original handler in a decorator call: http.HandleFunc("/hello", WithServerHeader(hello)) As it both accepts and returns a http.HandlerFunc — a function type matching request handlers’ signatures — we don’t need anything else to be able to wrap our handlers in as many decorators as necessary: http.HandleFunc("/", WithServerHeader(index)) http.HandleFunc("/home", WithServerHeader(LoginRequired(home))) http.HandleFunc("/api/share", WithServerHeader(LoginRequired(CsrfProtected(api.Share)))) It’s possible simply by the means of ordinary function composition. Going meta Looking at the last line of the example above — which is made-up but could very well come from actual production code — you probably can’t help but notice that stacking function calls like that creates a somewhat messy amalgamation of parentheses. Beyond three or four items, a decorator chain such as this one becomes rather unwieldy to follow. If we’re concerned about readability, it’s possible to alleviate the issue by taking another step up the abstraction ladder. Rather than composing the decorators explicitly, we can write a function that does it for us: type HttpHandlerDecorator func(http.HandlerFunc) http.HandlerFunc func Handler(h http.HandlerFunc, decors ...HttpHandlerDecorator) http.HandlerFunc { for i := range decors { d := decors[len(decors) - 1 - i] // iterate in reverse h = d(h) } return h } and thus eliminate all the parentheses: http.HandleFunc("/api/share", Handler(api.Share, WithServerHeader, LoginRequired, CsrfProtected)) This technique proves especially valuable if the decorators themselves are parameterized: http.HandleFunc("/api/notifications", Handler(api.Notifications, WithServerHeader, LoginRequired, Cached(time.Duration(5)*time.Minute))) In practice, you may find it valuable to wrap the complete http.HandleFunc call to accept a request handler along with its decorator chain, or the equivalent of such a call in any of the numerous Go web frameworks."
}
</script></body>
</html>