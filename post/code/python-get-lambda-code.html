<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/font-awesome.min.css">

    <link href="http://xion.io/style.css" rel="stylesheet">




  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

<meta name="author" content="Karol Kuczmarski" />
<meta name="description" content="…or: The Most Hideous Hack I’ve (Almost) Done In callee, the argument matcher library for Python that I released recently, there is this lovely TODO note for a seemingly simple feature. When using the Matching construct with a simple lambda predicate: mock_foo.assert_called_with(Matching(lambda x: x % 2 == 0)) it would be great to see its code in the error message if the assertion fails. Right now it’s just going to say something like &lt;Matching &lt;function &lt;lambda&gt; at 0x7f5d8a06eb18&gt;&gt;. Provided you don’t possess a supernatural ability of dereferencing pointers in your head, this won’t give you any immediate hint as to what went wrong. Wouldn’t it be nice if it read as, say, &lt;Matching \x: x % 2&gt; instead?1 So I thought: why not try and implement such a mechanism? This is Python, after all — a language where you can spawn completely new classes at runtime, walk the stack backwards (or even forward) and read the local variables, or change the behavior of the import system itself. Surely it would be possible — nay, easy — to get the source code of a short lambda function, right? Boy, was I wrong. Make no mistake, though: the task turned out to be absolutely doable, at least in the scope I wanted it done. But what would you think of a solution that involves not just the usual Python hackery, but also AST inspection, transformations of the source code as text, and bytecode shenanigans?… The code, all the code, and… much more than the code Let’s start from the beginning, though. Here’s a short lambda function, the kind of which we’d like to obtain the source code of: is_even = lambda x: x % 2 = 0 If the documentation for Python standard library is to be believed, this should be pretty easy. In the inspect module, there is a function called no different than getsource. For our purposes, however, getsourcelines is a little more convienient, because we can easily tell when the lambda is too long: def get_short_lambda_source(lambda_func): try: source_lines, _ = inspect.getsourcelines(lambda_func) except IOError: return None if len(source_lines) &gt; 1: return None return source_lines[0].strip() Of course if you programmed in Python for any longer period of time, you know very well that the standard docs are not to be trusted. And it’s not just that the except clause should also include TypeError, because it will be thrown when you try to pass any of the Python builtins to getsourcelines. More important is the ambiguity of what does “source lines for an object” actually mean. “Source lines containing the object definition” would be much more accurate, and this seemingly small distinction is rather crucial here. Passing a lambda function to either getsourcelines or getsource, we’ll get its source and everything else that the returned lines included. That’s right. Say hello to the complete is_even = assignment, and the entire assert_called_with invocation! And in case you are wondering: yes, the result will also include any end-of-line comments. No token left behind! Trim left Clearly this is more than we’ve bargained for. Maybe there is a way to strip away the unnecessary cruft? Python does know how to parse itself, after all: the standard ast module is a manifestation of this knowledge. Perhaps we can use it to retrieve the lambda AST node in order to turn it — and just it — back into Python code?… def get_short_lambda_ast_node(lambda_func): source_text = get_short_lambda_source(lambda_func) if source_text: source_ast = ast.parse(source_text) return next((node for node in ast.walk(source_ast) if isinstance(node, ast.Lambda)), None) But as it turns out, getting the source text back this way is only mostly possible. See, every substantial AST node — which is either an expression (ast.expr) or a statement (ast.stmt) — has two common attributes: lineno and col_offset. When combined, they point to a place in the original source code where the node was parsed from. This is how we can find out where to look for the definition of our lambda function. Looks promising, right? The only problem is we don’t know when to stop looking. That’s right: nodes created by ast.parse are annotated with their start offset, but not with length nor the end offset. As a result, the best we can do when it comes to carving out the lambda source from the very first example is this: lambda x: x % 2 == 0)) So close! Those hanging parentheses are evidently just taunting us, but how can we remove them? lambda is basically just a Python expression, so in principle it can be followed by almost anything. This is doubly true for lambdas inside the Matching construct, as they may be a part of some larger mock assertion: mock_foo.assert_called_with(Matching(lambda x: x % 2 == 0), Integer() &amp; GreaterThan(42)) Here, the extraneous suffix is the entirety of ), Integer() &amp; GreaterThan(42)), quite a lot of more than just )). And that’s of course nowhere near the limit of possiblities: for one, there may be more lambdas in there, too! Back off, slowly It seems, however, that there is one thing those troublesome tails have in common: they aren’t syntactically valid. Intuitively, a lambda node nested within some other syntactical constructs will have their closing fragments (e.g. )) appear somewhere after its end. Without the corresponding openings (e.g. Matching(), those fragments won’t parse. So here’s the crazy idea. What we have is invalid Python, but only because of some unspecified number of extra characters. How about we just try and remove them, one by one, until we get something that is syntactically correct? If we are not mistaken, this will finally be our lambda and nothing else. The fortune favors the brave, so let’s go ahead and try it: # ... continuing get_short_lambda_source() ... source_text = source_lines[0].strip() lambda_node = get_short_lambda_ast_node(lambda_func) lambda_text = source_text[lambda_node.col_offset:] min_length = len(&#39;lambda:_&#39;) # shortest possible lambda expression while len(lambda_text) &gt; min_length: try: ast.parse(lambda_text) return lambda_text except SyntaxError: lambda_text = lambda_text[:-1] return None Considering that we’re basically taking lessons from the dusty old tomes in the Restricted Section of Hogwarts library, the magic here looks quite simple. As long as there is something that can pass for a lambda definition, we try to parse it and see if it succeeds. The line that says except SyntaxError: is obviously not something for the faint of heart, but at least we are specifying what exception we anticipate catching. And the kicker? It works. By that I mean it doesn’t return garbage results for a few obvious and not so obvious test cases, which is already more than you would normally expect from hacks of this magnitude. All the lambdas defined until this paragraph, for example, can have their source code extracted without issue. Just one more thing So… victory? Not quite. Astute readers may recall my promise of some bytecode arcana, and now’s the time for it. Despite the initial success of our gradual, character dropping approach, there are cases where it doesn’t produce the correct result. Consider, for example, a lambda definition that’s nestled within a tuple2: &gt;&gt;&gt; x = lambda _: True, 0 &gt;&gt;&gt; get_short_lambda_source(x[0]) lambda _: True, 0 We would of course expect the result to be lambda _: True, without a comma or zero. Unfortunately, here’s where our earlier assumption fails rather spectacularly. The line of code extracted from AST is syntactically valid even with the extra characters. As a result, ast.parse succeeds too early and returns an incorrect definition. It should have been of a lambda contained within a tuple, but tuple is apparently what the lambda returns. You may say that this is the sharp end of a narrow edge case, and anyone who defines functions like that deserves all the trouble they get. And sure, I wouldn’t mind if we just threw hands in the air and told them we’re simply unable to retrieve the source here. But my opinion is that it doesn’t justify serving them obviously wrong results! A halting problem Not if we can help it, anyway. Have a look at the expected source code and the one we’ve extracted, side by side: lambda _: True lambda _: True, 0 The second line isn’t just longer: it is also doing more. It isn’t just defining a lambda; it defines it, conjures up a constant 0, and then packs them both into a tuple. That’s at least two additional steps compared to the original. Those steps have a more precise name, too: they are the bytecode instructions. Every piece of Python source is compiled to a binary bytecode before it’s executed, because the interpreter can only work with this representation. Compilation typically happens when a Python module is first imported, producing a .pyc file corresponding to its .py file. Subsequent imports will simply reuse the cached bytecode. Moreover, any function or class object has its bytecode accessible (read-only) at runtime. There is even a dedicated data type to hold it — called simply code — with a buffer of raw bytes under one of its attributes. Finally, the bytecode compiler itself is also available to Python programs as a built-in compile function. You don’t see it used as often as its counterparts eval and exec (which hopefully are a rare sight themselves!), but it taps into the same internal machinery of Python. So how does it all add up? The idea is, basically, to cross-check the alleged source code of the lambda with its own bytecode. Any junk that’s still left to trim — even if syntactically valid — will surface as a divergence after compilation. Thus we can simply continue dropping characters until the bytecodes match: lambda_text = source_text[lambda_node.col_offset:] lambda_body_text = source_text[lambda_node.body.col_offset:] min_length = len(&#39;lambda:_&#39;) # shortest possible lambda expression while len(lambda_text) &gt; min_length: try: code = compile(lambda_body_text, &#39;&lt;unused filename&gt;&#39;, &#39;eval&#39;) if len(code.co_code) == len(lambda_func.__code__.co_code): return lambda_text except SyntaxError: pass lambda_text = lambda_text[:-1] lambda_body_text = lambda_body_text[:-1] return None Okay, maybe not the exact bytes3, but stopping at the identical bytecode length is good enough a strategy. As an obvious bonus, compile will also take care of detecting syntax errors in the candidate source code, so we don’t need the ast parsing anymore. That escalated quickly! Believe it or not, but there aren’t any more objections to this solution, You can view it in its glorious entirety by looking at this gist. Does it mean it is also making its cameo in the callee library?… No, I’m afraid not. Normally, I’m not the one to shy away from, ahem, bold solutions to tough problems. But in this case, the magnitude of hackery required is just too great, the result not satisfactory enough, the feature’s priority isn’t really all that high, and the maintenance burden it’d introduce is most likely too large. In the end, it was great fun figuring it out: yet another example of how you can fiddle with Python to do basically anything. Still, we must not get too preoccupied with whether or not we can as to forget if we should. Backslash (\) is how lambda functions are denoted in Haskell. We want to be short and sweet, so it feels like a natural choice. ↩ This isn’t an actual snippet from a Python REPL, because inspect.getsourcelines requires the object to be defined in a .py file. ↩ Why we won’t always get an identical bytecode? The short answer is that some instructions may be swapped for their approximate equivalents. The long answer is that with compile, we aren’t able to replicate the exact closure environment of the original lambda. When a function refers to an free variable (like foo in lambda x: x + foo), it is its closure where the value for that variable comes from. For ad-hoc lambdas, this is typically the local scope of its outer function. Code produced by compile, however, isn’t associated with any such local scope. All free names are thus assumed to refer to global variables. Because Python uses different bytecode instructions for referencing local and global names (LOAD_FAST vs LOAD_GLOBAL), the result of compile may differ from a piece of bytecode produced in the regular manner. ↩" />
<meta name="keywords" content="Python, functions, AST, bytecode">
<meta property="og:site_name" content="Karol Kuczmarski's Blog"/>
<meta property="og:title" content="Source code of a Python lambda"/>
<meta property="og:description" content="…or: The Most Hideous Hack I’ve (Almost) Done In callee, the argument matcher library for Python that I released recently, there is this lovely TODO note for a seemingly simple feature. When using the Matching construct with a simple lambda predicate: mock_foo.assert_called_with(Matching(lambda x: x % 2 == 0)) it would be great to see its code in the error message if the assertion fails. Right now it’s just going to say something like &lt;Matching &lt;function &lt;lambda&gt; at 0x7f5d8a06eb18&gt;&gt;. Provided you don’t possess a supernatural ability of dereferencing pointers in your head, this won’t give you any immediate hint as to what went wrong. Wouldn’t it be nice if it read as, say, &lt;Matching \x: x % 2&gt; instead?1 So I thought: why not try and implement such a mechanism? This is Python, after all — a language where you can spawn completely new classes at runtime, walk the stack backwards (or even forward) and read the local variables, or change the behavior of the import system itself. Surely it would be possible — nay, easy — to get the source code of a short lambda function, right? Boy, was I wrong. Make no mistake, though: the task turned out to be absolutely doable, at least in the scope I wanted it done. But what would you think of a solution that involves not just the usual Python hackery, but also AST inspection, transformations of the source code as text, and bytecode shenanigans?… The code, all the code, and… much more than the code Let’s start from the beginning, though. Here’s a short lambda function, the kind of which we’d like to obtain the source code of: is_even = lambda x: x % 2 = 0 If the documentation for Python standard library is to be believed, this should be pretty easy. In the inspect module, there is a function called no different than getsource. For our purposes, however, getsourcelines is a little more convienient, because we can easily tell when the lambda is too long: def get_short_lambda_source(lambda_func): try: source_lines, _ = inspect.getsourcelines(lambda_func) except IOError: return None if len(source_lines) &gt; 1: return None return source_lines[0].strip() Of course if you programmed in Python for any longer period of time, you know very well that the standard docs are not to be trusted. And it’s not just that the except clause should also include TypeError, because it will be thrown when you try to pass any of the Python builtins to getsourcelines. More important is the ambiguity of what does “source lines for an object” actually mean. “Source lines containing the object definition” would be much more accurate, and this seemingly small distinction is rather crucial here. Passing a lambda function to either getsourcelines or getsource, we’ll get its source and everything else that the returned lines included. That’s right. Say hello to the complete is_even = assignment, and the entire assert_called_with invocation! And in case you are wondering: yes, the result will also include any end-of-line comments. No token left behind! Trim left Clearly this is more than we’ve bargained for. Maybe there is a way to strip away the unnecessary cruft? Python does know how to parse itself, after all: the standard ast module is a manifestation of this knowledge. Perhaps we can use it to retrieve the lambda AST node in order to turn it — and just it — back into Python code?… def get_short_lambda_ast_node(lambda_func): source_text = get_short_lambda_source(lambda_func) if source_text: source_ast = ast.parse(source_text) return next((node for node in ast.walk(source_ast) if isinstance(node, ast.Lambda)), None) But as it turns out, getting the source text back this way is only mostly possible. See, every substantial AST node — which is either an expression (ast.expr) or a statement (ast.stmt) — has two common attributes: lineno and col_offset. When combined, they point to a place in the original source code where the node was parsed from. This is how we can find out where to look for the definition of our lambda function. Looks promising, right? The only problem is we don’t know when to stop looking. That’s right: nodes created by ast.parse are annotated with their start offset, but not with length nor the end offset. As a result, the best we can do when it comes to carving out the lambda source from the very first example is this: lambda x: x % 2 == 0)) So close! Those hanging parentheses are evidently just taunting us, but how can we remove them? lambda is basically just a Python expression, so in principle it can be followed by almost anything. This is doubly true for lambdas inside the Matching construct, as they may be a part of some larger mock assertion: mock_foo.assert_called_with(Matching(lambda x: x % 2 == 0), Integer() &amp; GreaterThan(42)) Here, the extraneous suffix is the entirety of ), Integer() &amp; GreaterThan(42)), quite a lot of more than just )). And that’s of course nowhere near the limit of possiblities: for one, there may be more lambdas in there, too! Back off, slowly It seems, however, that there is one thing those troublesome tails have in common: they aren’t syntactically valid. Intuitively, a lambda node nested within some other syntactical constructs will have their closing fragments (e.g. )) appear somewhere after its end. Without the corresponding openings (e.g. Matching(), those fragments won’t parse. So here’s the crazy idea. What we have is invalid Python, but only because of some unspecified number of extra characters. How about we just try and remove them, one by one, until we get something that is syntactically correct? If we are not mistaken, this will finally be our lambda and nothing else. The fortune favors the brave, so let’s go ahead and try it: # ... continuing get_short_lambda_source() ... source_text = source_lines[0].strip() lambda_node = get_short_lambda_ast_node(lambda_func) lambda_text = source_text[lambda_node.col_offset:] min_length = len(&#39;lambda:_&#39;) # shortest possible lambda expression while len(lambda_text) &gt; min_length: try: ast.parse(lambda_text) return lambda_text except SyntaxError: lambda_text = lambda_text[:-1] return None Considering that we’re basically taking lessons from the dusty old tomes in the Restricted Section of Hogwarts library, the magic here looks quite simple. As long as there is something that can pass for a lambda definition, we try to parse it and see if it succeeds. The line that says except SyntaxError: is obviously not something for the faint of heart, but at least we are specifying what exception we anticipate catching. And the kicker? It works. By that I mean it doesn’t return garbage results for a few obvious and not so obvious test cases, which is already more than you would normally expect from hacks of this magnitude. All the lambdas defined until this paragraph, for example, can have their source code extracted without issue. Just one more thing So… victory? Not quite. Astute readers may recall my promise of some bytecode arcana, and now’s the time for it. Despite the initial success of our gradual, character dropping approach, there are cases where it doesn’t produce the correct result. Consider, for example, a lambda definition that’s nestled within a tuple2: &gt;&gt;&gt; x = lambda _: True, 0 &gt;&gt;&gt; get_short_lambda_source(x[0]) lambda _: True, 0 We would of course expect the result to be lambda _: True, without a comma or zero. Unfortunately, here’s where our earlier assumption fails rather spectacularly. The line of code extracted from AST is syntactically valid even with the extra characters. As a result, ast.parse succeeds too early and returns an incorrect definition. It should have been of a lambda contained within a tuple, but tuple is apparently what the lambda returns. You may say that this is the sharp end of a narrow edge case, and anyone who defines functions like that deserves all the trouble they get. And sure, I wouldn’t mind if we just threw hands in the air and told them we’re simply unable to retrieve the source here. But my opinion is that it doesn’t justify serving them obviously wrong results! A halting problem Not if we can help it, anyway. Have a look at the expected source code and the one we’ve extracted, side by side: lambda _: True lambda _: True, 0 The second line isn’t just longer: it is also doing more. It isn’t just defining a lambda; it defines it, conjures up a constant 0, and then packs them both into a tuple. That’s at least two additional steps compared to the original. Those steps have a more precise name, too: they are the bytecode instructions. Every piece of Python source is compiled to a binary bytecode before it’s executed, because the interpreter can only work with this representation. Compilation typically happens when a Python module is first imported, producing a .pyc file corresponding to its .py file. Subsequent imports will simply reuse the cached bytecode. Moreover, any function or class object has its bytecode accessible (read-only) at runtime. There is even a dedicated data type to hold it — called simply code — with a buffer of raw bytes under one of its attributes. Finally, the bytecode compiler itself is also available to Python programs as a built-in compile function. You don’t see it used as often as its counterparts eval and exec (which hopefully are a rare sight themselves!), but it taps into the same internal machinery of Python. So how does it all add up? The idea is, basically, to cross-check the alleged source code of the lambda with its own bytecode. Any junk that’s still left to trim — even if syntactically valid — will surface as a divergence after compilation. Thus we can simply continue dropping characters until the bytecodes match: lambda_text = source_text[lambda_node.col_offset:] lambda_body_text = source_text[lambda_node.body.col_offset:] min_length = len(&#39;lambda:_&#39;) # shortest possible lambda expression while len(lambda_text) &gt; min_length: try: code = compile(lambda_body_text, &#39;&lt;unused filename&gt;&#39;, &#39;eval&#39;) if len(code.co_code) == len(lambda_func.__code__.co_code): return lambda_text except SyntaxError: pass lambda_text = lambda_text[:-1] lambda_body_text = lambda_body_text[:-1] return None Okay, maybe not the exact bytes3, but stopping at the identical bytecode length is good enough a strategy. As an obvious bonus, compile will also take care of detecting syntax errors in the candidate source code, so we don’t need the ast parsing anymore. That escalated quickly! Believe it or not, but there aren’t any more objections to this solution, You can view it in its glorious entirety by looking at this gist. Does it mean it is also making its cameo in the callee library?… No, I’m afraid not. Normally, I’m not the one to shy away from, ahem, bold solutions to tough problems. But in this case, the magnitude of hackery required is just too great, the result not satisfactory enough, the feature’s priority isn’t really all that high, and the maintenance burden it’d introduce is most likely too large. In the end, it was great fun figuring it out: yet another example of how you can fiddle with Python to do basically anything. Still, we must not get too preoccupied with whether or not we can as to forget if we should. Backslash (\) is how lambda functions are denoted in Haskell. We want to be short and sweet, so it feels like a natural choice. ↩ This isn’t an actual snippet from a Python REPL, because inspect.getsourcelines requires the object to be defined in a .py file. ↩ Why we won’t always get an identical bytecode? The short answer is that some instructions may be swapped for their approximate equivalents. The long answer is that with compile, we aren’t able to replicate the exact closure environment of the original lambda. When a function refers to an free variable (like foo in lambda x: x + foo), it is its closure where the value for that variable comes from. For ad-hoc lambdas, this is typically the local scope of its outer function. Code produced by compile, however, isn’t associated with any such local scope. All free names are thus assumed to refer to global variables. Because Python uses different bytecode instructions for referencing local and global names (LOAD_FAST vs LOAD_GLOBAL), the result of compile may differ from a piece of bytecode produced in the regular manner. ↩"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://xion.io/post/code/python-get-lambda-code.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2016-04-19 07:43:00-07:00"/>
<meta property="article:modified_time" content="2016-08-15 23:08:00-07:00"/>
<meta property="article:author" content="http://xion.io/">
<meta property="article:section" content="Code"/>
<meta property="article:tag" content="Python"/>
<meta property="article:tag" content="functions"/>
<meta property="article:tag" content="AST"/>
<meta property="article:tag" content="bytecode"/>
<meta property="og:image" content="http://xion.io/logo.jpeg">
  <title>Karol Kuczmarski's Blog &ndash; Source code of a Python lambda</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://xion.io">
        <img src="http://xion.io/logo.jpeg" alt="Karol Kuczmarski" title="Karol Kuczmarski">
      </a>
      <h1><a href="http://xion.io">Karol Kuczmarski</a></h1>
      <p>fn(Tea) -> Code</p>
      <nav>
        <ul class="list">
          <li><a href="http://xion.io/page/about.html#about">About</a></li>
          <li><a href="http://xion.io/page/projects.html#projects">Projects</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-github" href="http://github.com/Xion" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-stack-overflow" href="http://stackoverflow.com/users/434799/xion" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
        <li><a class="sc-twitter" href="http://twitter.com/Xion__" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-google" href="https://plus.google.com/+KarolKuczmarski" target="_blank"><i class="fa fa-google"></i></a></li>
        <li><a class="sc-rss" href="/feeds/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="http://xion.io">Home</a>
      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>
      <a href="http://xion.org.pl/">Old blog</a>
    </nav>

<article>
  <header>
    <h1 id="python-get-lambda-code">Source code of a Python&nbsp;lambda</h1>
    <p>Posted on Tue 19 April 2016 in <a href="http://xion.io/category/code.html">Code</a></p>
  </header>
  <div>
    <p><em>&#8230;or: The Most Hideous Hack I&#8217;ve (Almost)&nbsp;Done</em></p>
<p>In <a href="http://github.com/Xion/callee">callee</a>, the <a href="http://callee.readthedocs.org">argument matcher library for Python</a> that
<a href="http://xion.io/post/news/callee-intro.html">I released recently</a>, there is this lovely
<a href="https://github.com/Xion/callee/blob/f695ff4e1c45bfd45445ebb8014a202029a93dce/callee/general.py#L55"><code>TODO</code> note</a>
for a seemingly simple feature. When using the
<a href="http://callee.readthedocs.org/en/stable/reference/general.html#callee.general.Matching"><code>Matching</code> construct</a>
with a simple <code>lambda</code> predicate:</p>
<div class="highlight"><pre><span class="n">mock_foo</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="n">Matching</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>


<p>it would be great to see its <em>code</em> in the error message if the assertion fails. Right now it&#8217;s just going to say
something like <code>&lt;Matching &lt;function &lt;lambda&gt; at 0x7f5d8a06eb18&gt;&gt;</code>. Provided you don&#8217;t possess a supernatural ability
of dereferencing pointers in your head, this won&#8217;t give you any immediate hint as to what went wrong. Wouldn&#8217;t it be nice
if it read as, say, <code>&lt;Matching \x: x % 2&gt;</code> instead?<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup></p>
<p>So I thought: why not try and implement such a mechanism? This is Python, after all &#8212; a language where you can spawn
<a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/#simple-metaclass-use">completely new classes</a>
at runtime, walk the stack <a href="https://docs.python.org/2/library/inspect.html#the-interpreter-stack">backwards</a>
(or even <a href="https://docs.python.org/2/library/sys.html#sys.settrace">forward</a>) and read the local variables,
or change the behavior of the <a href="http://xion.org.pl/2012/05/06/hacking-python-imports/">import system itself</a>.
Surely it would be possible &#8212; nay, easy &#8212; to get the source code of a short lambda function,&nbsp;right?</p>
<p>Boy, was I <em>wrong</em>.</p>
<p>Make no mistake, though: the task turned out to be absolutely doable, at least in the scope I wanted it done.
But what would you think of a solution that involves not just the usual Python hackery, but also <span class="caps">AST</span> inspection,
transformations of the source code as text, <em>and</em> bytecode&nbsp;shenanigans?&#8230;</p>
<h4>The code, all the code, and&#8230; much more than the&nbsp;code</h4>
<p>Let&#8217;s start from the beginning, though. Here&#8217;s a short lambda function, the kind of which we&#8217;d like to obtain
the source code&nbsp;of:</p>
<div class="highlight"><pre><span class="n">is_even</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>


<p>If the documentation for Python standard library is to be believed, this should be pretty easy.
In the <a href="https://docs.python.org/2/library/inspect.html"><code>inspect</code> module</a>,
there is a function called no different than
<a href="https://docs.python.org/2/library/inspect.html#inspect.getsource"><code>getsource</code></a>. For our purposes, however,
<a href="https://docs.python.org/2/library/inspect.html#inspect.getsourcelines"><code>getsourcelines</code></a> is a little more
convienient, because we can easily tell when the lambda is too&nbsp;long:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">get_short_lambda_source</span><span class="p">(</span><span class="n">lambda_func</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">source_lines</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">lambda_func</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_lines</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">source_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</pre></div>


<p>Of course if you programmed in Python for any longer period of time, you know very well that the standard docs
are <em>not</em> to be trusted. And it&#8217;s not just that the <code>except</code> clause should also include <code>TypeError</code>, because it
will be thrown when you try to pass any of the Python builtins to <code>getsourcelines</code>.</p>
<p>More important is the ambiguity of what does &#8220;source lines for an object&#8221; actually mean. &#8220;Source lines <em>containing</em>
the object definition&#8221; would be much more accurate, and this seemingly small distinction is rather crucial here.
Passing a lambda function to either <code>getsourcelines</code> or <code>getsource</code>, we&#8217;ll get its source <em>and everything else</em>
that the returned lines&nbsp;included.</p>
<p>That&#8217;s right. Say hello to the complete <code>is_even =</code> assignment, and the entire <code>assert_called_with</code> invocation!
And in case you are wondering: yes, the result will also include any end-of-line comments. No token left&nbsp;behind!</p>
<h4>Trim&nbsp;left</h4>
<p>Clearly this is more than we&#8217;ve bargained for. Maybe there is a way to strip away the unnecessary cruft? Python does
know how to parse itself, after all: the standard <a href="https://docs.python.org/2/library/ast.html"><code>ast</code> module</a>
is a manifestation of this knowledge. Perhaps we can use it to retrieve the <code>lambda</code> <span class="caps">AST</span> node in order to turn it &#8212;
and just it &#8212; back into Python&nbsp;code?&#8230;</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">get_short_lambda_ast_node</span><span class="p">(</span><span class="n">lambda_func</span><span class="p">):</span>
    <span class="n">source_text</span> <span class="o">=</span> <span class="n">get_short_lambda_source</span><span class="p">(</span><span class="n">lambda_func</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">source_text</span><span class="p">:</span>
        <span class="n">source_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source_text</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">((</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">ast</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">source_ast</span><span class="p">)</span>
                     <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Lambda</span><span class="p">)),</span> <span class="bp">None</span><span class="p">)</span>
</pre></div>


<p>But as it turns out, getting the source text back this way is only <em>mostly</em>&nbsp;possible.</p>
<p>See, every substantial <span class="caps">AST</span> node &#8212; which is either an expression (<code>ast.expr</code>) or a statement (<code>ast.stmt</code>) &#8212;
has two common attributes: <code>lineno</code> and <code>col_offset</code>. When combined, they point to a place in the original source code
where the node was parsed from. This is how we can find out where to look for the definition of our lambda&nbsp;function.</p>
<p>Looks promising, right? The only problem is we don&#8217;t know when to <em>stop</em> looking.
That&#8217;s right: nodes created by <code>ast.parse</code> are annotated with their start offset, but not with length nor the end offset.
As a result, the best we can do when it comes to carving out the lambda source from the very first example is&nbsp;this:</p>
<div class="highlight"><pre><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>


<p>So close! Those hanging parentheses are evidently just taunting us, but how can we remove them? <code>lambda</code> is basically
just a Python expression, so in principle it can be followed by almost anything. This is doubly true for lambdas inside
the <code>Matching</code> construct, as they may be a part of some larger mock&nbsp;assertion:</p>
<div class="highlight"><pre><span class="n">mock_foo</span><span class="o">.</span><span class="n">assert_called_with</span><span class="p">(</span><span class="n">Matching</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="n">Integer</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">GreaterThan</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
</pre></div>


<p>Here, the extraneous suffix is the entirety of <code>), Integer() &amp; GreaterThan(42))</code>, quite a lot of more than just <code>))</code>.
And that&#8217;s of course nowhere near the limit of possiblities: for one, there may be more <code>lambda</code>s in there,&nbsp;too!</p>
<h4>Back off, <em>slowly</em></h4>
<p>It seems, however, that there is one thing those troublesome tails have in common: <em>they aren&#8217;t syntactically valid</em>.</p>
<p>Intuitively, a <code>lambda</code> node nested within some other syntactical constructs will have their closing fragments (e.g. <code>)</code>)
appear somewhere after its end. Without the corresponding openings (e.g. <code>Matching(</code>), those fragments won&#8217;t&nbsp;parse.</p>
<p>So here&#8217;s the crazy idea. What we have is invalid Python, but only because of some unspecified number of extra characters.
How about we just try and remove them, one by one, until we get something that <em>is</em> syntactically correct?
If we are not mistaken, this will finally be our lambda and nothing&nbsp;else.</p>
<p>The fortune favors the brave, so let&#8217;s go ahead and try&nbsp;it:</p>
<div class="highlight"><pre><span class="c"># ... continuing get_short_lambda_source() ...</span>

<span class="n">source_text</span> <span class="o">=</span> <span class="n">source_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="n">lambda_node</span> <span class="o">=</span> <span class="n">get_short_lambda_ast_node</span><span class="p">(</span><span class="n">lambda_func</span><span class="p">)</span>

<span class="n">lambda_text</span> <span class="o">=</span> <span class="n">source_text</span><span class="p">[</span><span class="n">lambda_node</span><span class="o">.</span><span class="n">col_offset</span><span class="p">:]</span>
<span class="n">min_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="s">&#39;lambda:_&#39;</span><span class="p">)</span>  <span class="c"># shortest possible lambda expression</span>
<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">lambda_text</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">min_length</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">lambda_text</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lambda_text</span>
    <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
        <span class="n">lambda_text</span> <span class="o">=</span> <span class="n">lambda_text</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="k">return</span> <span class="bp">None</span>
</pre></div>


<p>Considering that we&#8217;re basically taking lessons from the dusty old tomes in the Restricted Section of Hogwarts library,
the magic here looks quite simple. As long as there is something that can pass for a lambda definition,
we try to parse it and see if it succeeds. The line that says <code>except SyntaxError:</code> is obviously not something for
the faint of heart, but at least we are specifying
<a href="https://docs.python.org/2/howto/doanddont.html#except"><em>what</em> exception</a> we anticipate&nbsp;catching.</p>
<p>And the kicker? It <em>works</em>. By that I mean it doesn&#8217;t return garbage results for a few obvious and not so obvious
test cases, which is already more than you would normally expect from hacks of this magnitude.
All the lambdas defined until this paragraph, for example, can have their source code extracted without&nbsp;issue.</p>
<h4>Just one more&nbsp;thing</h4>
<p>So&#8230; victory? Not quite. Astute readers may recall my promise of some bytecode arcana, and now&#8217;s the time for&nbsp;it.</p>
<p>Despite the initial success of our gradual, character dropping approach, there are cases where it doesn&#8217;t produce
the correct result. Consider, for example, a lambda definition that&#8217;s nestled within a tuple<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>:</p>
<div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span> <span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_short_lambda_source</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span> <span class="mi">0</span>
</pre></div>


<p>We would of course expect the result to be <code>lambda _: True</code>, without a comma or&nbsp;zero.</p>
<p>Unfortunately, here&#8217;s where our earlier assumption fails rather spectacularly. The line of code extracted from <span class="caps">AST</span>
is syntactically valid even <em>with</em> the extra characters. As a result, <code>ast.parse</code> succeeds too early and returns an
incorrect definition. It should have been of a lambda contained within a tuple, but tuple is apparently what the lambda
<em>returns</em>.</p>
<p>You may say that this is the sharp end of a narrow edge case, and anyone who defines functions like that deserves all
the trouble they get. And sure, I wouldn&#8217;t mind if we just threw hands in the air and told them we&#8217;re simply unable
to retrieve the source here. But my opinion is that it doesn&#8217;t justify serving them obviously <em>wrong</em>&nbsp;results!</p>
<h4>A halting&nbsp;problem</h4>
<p>Not if we can help it, anyway. Have a look at the expected source code and the one we&#8217;ve extracted, side by&nbsp;side:</p>
<div class="highlight"><pre><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="bp">True</span>
<span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span> <span class="mi">0</span>
</pre></div>


<p>The second line isn&#8217;t just longer: it is also <em>doing more</em>. It isn&#8217;t just defining a lambda; it defines it,
conjures up a constant <code>0</code>, and then packs them both into a tuple. That&#8217;s at least two additional steps compared to
the&nbsp;original.</p>
<p>Those steps have a more precise name, too: they are the <em>bytecode instructions</em>. Every piece of Python source is compiled
to a binary bytecode before it&#8217;s executed, because the interpreter can only work with this representation.
Compilation typically happens when a Python module is first imported, producing a <em>.pyc</em> file corresponding to its
<em>.py</em> file. Subsequent imports will simply reuse the cached&nbsp;bytecode.</p>
<p>Moreover, any function or class object has its bytecode accessible (read-only) at runtime. There is even a
<a href="http://late.am/post/2012/03/26/exploring-python-code-objects.html">dedicated data type</a> to hold it &#8212; called simply
<code>code</code> &#8212; with a buffer of raw bytes under one of its&nbsp;attributes.</p>
<p>Finally, the bytecode compiler itself is also available to Python programs as a built-in
<a href="https://docs.python.org/2/library/functions.html#compile"><code>compile</code> function</a>. You don&#8217;t see it used as often as its
counterparts <a href="https://docs.python.org/2/library/functions.html#eval"><code>eval</code></a>
and <a href="https://docs.python.org/2/reference/simple_stmts.html#exec"><code>exec</code></a> (which hopefully are a rare sight themselves!),
but it taps into the same internal machinery of&nbsp;Python.</p>
<p>So how does it all add up? The idea is, basically, to cross-check the alleged source code of the lambda with its own
<em>byte</em>code. Any junk that&#8217;s still left to trim &#8212; even if syntactically valid &#8212; will surface as a divergence after
compilation. Thus we can simply continue dropping characters until the bytecodes&nbsp;match:</p>
<div class="highlight"><pre><span class="n">lambda_text</span> <span class="o">=</span> <span class="n">source_text</span><span class="p">[</span><span class="n">lambda_node</span><span class="o">.</span><span class="n">col_offset</span><span class="p">:]</span>
<span class="n">lambda_body_text</span> <span class="o">=</span> <span class="n">source_text</span><span class="p">[</span><span class="n">lambda_node</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">col_offset</span><span class="p">:]</span>
<span class="n">min_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="s">&#39;lambda:_&#39;</span><span class="p">)</span>  <span class="c"># shortest possible lambda expression</span>
<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">lambda_text</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">min_length</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">code</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">lambda_body_text</span><span class="p">,</span> <span class="s">&#39;&lt;unused filename&gt;&#39;</span><span class="p">,</span> <span class="s">&#39;eval&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">code</span><span class="o">.</span><span class="n">co_code</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lambda_func</span><span class="o">.</span><span class="n">__code__</span><span class="o">.</span><span class="n">co_code</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">lambda_text</span>
    <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">lambda_text</span> <span class="o">=</span> <span class="n">lambda_text</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">lambda_body_text</span> <span class="o">=</span> <span class="n">lambda_body_text</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="k">return</span> <span class="bp">None</span>
</pre></div>


<p>Okay, maybe not the exact bytes<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>, but stopping at the identical bytecode <em>length</em> is good enough a strategy.
As an obvious bonus, <code>compile</code> will also take care of detecting syntax errors in the candidate source code,
so we don&#8217;t need the <code>ast</code> parsing&nbsp;anymore.</p>
<h4>That escalated&nbsp;quickly!</h4>
<p>Believe it or not, but there aren&#8217;t any more objections to this solution, You can view it in its glorious entirety
by looking at <a href="https://gist.github.com/Xion/617c1496ff45f3673a5692c3b0e3f75a">this gist</a>.</p>
<p>Does it mean it is also making its cameo in the <a href="https://github.com/Xion/callee"><em>callee</em> library</a>?&#8230;</p>
<p>No, I&#8217;m afraid&nbsp;not.</p>
<p>Normally, I&#8217;m not the one to shy away from, ahem, <em>bold</em> solutions to tough problems. But in this case, the magnitude
of hackery required is just too great, the result not satisfactory enough, the feature&#8217;s priority isn&#8217;t really
all that high, and the maintenance burden it&#8217;d introduce is most likely too&nbsp;large.</p>
<p>In the end, it was great fun figuring it out: yet another example of how you can fiddle with Python to do basically
anything. Still, we must not get too preoccupied with whether or not we can as to forget if we <em>should</em>.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Backslash (<code>\</code>) is how lambda functions are denoted in Haskell. We want to be short and sweet, so it feels
like a natural choice.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>This isn&#8217;t an actual snippet from a Python <span class="caps">REPL</span>, because <code>inspect.getsourcelines</code> requires the object to be
defined in a <em>.py</em> file.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>Why we won&#8217;t always get an identical bytecode? The short answer is that some instructions may be swapped
for their approximate equivalents.<br/>
The long answer is that with <code>compile</code>, we aren&#8217;t able to replicate the exact closure environment of the original lambda.
When a function refers to an <em>free variable</em> (like <code>foo</code> in <code>lambda x: x + foo</code>), it is its closure where the value
for that variable comes from. For ad-hoc lambdas, this is typically the local scope of its <em>outer function</em>.</br>
Code produced by <code>compile</code>, however, isn&#8217;t associated with any such local scope. All free names are thus assumed
to refer to <em>global</em> variables. Because Python uses different bytecode instructions for referencing local and global
names (<code>LOAD_FAST</code> vs <code>LOAD_GLOBAL</code>), the result of <code>compile</code> may differ from a piece of bytecode produced in the regular
manner.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
</ol>
</div>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="http://xion.io/tag/python.html">Python</a>
      <a href="http://xion.io/tag/functions.html">functions</a>
      <a href="http://xion.io/tag/ast.html">AST</a>
      <a href="http://xion.io/tag/bytecode.html">bytecode</a>
    </p>
  </div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'xionblog';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</article>

    <footer>
<p>
  &copy; Karol Kuczmarski 2018 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-27379564-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "Source code of a Python lambda",
  "headline": "Source code of a Python lambda",
  "datePublished": "2016-04-19 07:43:00-07:00",
  "dateModified": "2016-08-15 23:08:00-07:00",
  "author": {
    "@type": "Person",
    "name": "Karol Kuczmarski",
    "url": "http://xion.io/"
  },
  "image": "http://xion.io/logo.jpeg",
  "url": "http://xion.io/post/code/python-get-lambda-code.html",
  "description": "…or: The Most Hideous Hack I’ve (Almost) Done In callee, the argument matcher library for Python that I released recently, there is this lovely TODO note for a seemingly simple feature. When using the Matching construct with a simple lambda predicate: mock_foo.assert_called_with(Matching(lambda x: x % 2 == 0)) it would be great to see its code in the error message if the assertion fails. Right now it’s just going to say something like <Matching <function <lambda> at 0x7f5d8a06eb18>>. Provided you don’t possess a supernatural ability of dereferencing pointers in your head, this won’t give you any immediate hint as to what went wrong. Wouldn’t it be nice if it read as, say, <Matching \x: x % 2> instead?1 So I thought: why not try and implement such a mechanism? This is Python, after all — a language where you can spawn completely new classes at runtime, walk the stack backwards (or even forward) and read the local variables, or change the behavior of the import system itself. Surely it would be possible — nay, easy — to get the source code of a short lambda function, right? Boy, was I wrong. Make no mistake, though: the task turned out to be absolutely doable, at least in the scope I wanted it done. But what would you think of a solution that involves not just the usual Python hackery, but also AST inspection, transformations of the source code as text, and bytecode shenanigans?… The code, all the code, and… much more than the code Let’s start from the beginning, though. Here’s a short lambda function, the kind of which we’d like to obtain the source code of: is_even = lambda x: x % 2 = 0 If the documentation for Python standard library is to be believed, this should be pretty easy. In the inspect module, there is a function called no different than getsource. For our purposes, however, getsourcelines is a little more convienient, because we can easily tell when the lambda is too long: def get_short_lambda_source(lambda_func): try: source_lines, _ = inspect.getsourcelines(lambda_func) except IOError: return None if len(source_lines) > 1: return None return source_lines[0].strip() Of course if you programmed in Python for any longer period of time, you know very well that the standard docs are not to be trusted. And it’s not just that the except clause should also include TypeError, because it will be thrown when you try to pass any of the Python builtins to getsourcelines. More important is the ambiguity of what does “source lines for an object” actually mean. “Source lines containing the object definition” would be much more accurate, and this seemingly small distinction is rather crucial here. Passing a lambda function to either getsourcelines or getsource, we’ll get its source and everything else that the returned lines included. That’s right. Say hello to the complete is_even = assignment, and the entire assert_called_with invocation! And in case you are wondering: yes, the result will also include any end-of-line comments. No token left behind! Trim left Clearly this is more than we’ve bargained for. Maybe there is a way to strip away the unnecessary cruft? Python does know how to parse itself, after all: the standard ast module is a manifestation of this knowledge. Perhaps we can use it to retrieve the lambda AST node in order to turn it — and just it — back into Python code?… def get_short_lambda_ast_node(lambda_func): source_text = get_short_lambda_source(lambda_func) if source_text: source_ast = ast.parse(source_text) return next((node for node in ast.walk(source_ast) if isinstance(node, ast.Lambda)), None) But as it turns out, getting the source text back this way is only mostly possible. See, every substantial AST node — which is either an expression (ast.expr) or a statement (ast.stmt) — has two common attributes: lineno and col_offset. When combined, they point to a place in the original source code where the node was parsed from. This is how we can find out where to look for the definition of our lambda function. Looks promising, right? The only problem is we don’t know when to stop looking. That’s right: nodes created by ast.parse are annotated with their start offset, but not with length nor the end offset. As a result, the best we can do when it comes to carving out the lambda source from the very first example is this: lambda x: x % 2 == 0)) So close! Those hanging parentheses are evidently just taunting us, but how can we remove them? lambda is basically just a Python expression, so in principle it can be followed by almost anything. This is doubly true for lambdas inside the Matching construct, as they may be a part of some larger mock assertion: mock_foo.assert_called_with(Matching(lambda x: x % 2 == 0), Integer() & GreaterThan(42)) Here, the extraneous suffix is the entirety of ), Integer() & GreaterThan(42)), quite a lot of more than just )). And that’s of course nowhere near the limit of possiblities: for one, there may be more lambdas in there, too! Back off, slowly It seems, however, that there is one thing those troublesome tails have in common: they aren’t syntactically valid. Intuitively, a lambda node nested within some other syntactical constructs will have their closing fragments (e.g. )) appear somewhere after its end. Without the corresponding openings (e.g. Matching(), those fragments won’t parse. So here’s the crazy idea. What we have is invalid Python, but only because of some unspecified number of extra characters. How about we just try and remove them, one by one, until we get something that is syntactically correct? If we are not mistaken, this will finally be our lambda and nothing else. The fortune favors the brave, so let’s go ahead and try it: # ... continuing get_short_lambda_source() ... source_text = source_lines[0].strip() lambda_node = get_short_lambda_ast_node(lambda_func) lambda_text = source_text[lambda_node.col_offset:] min_length = len('lambda:_') # shortest possible lambda expression while len(lambda_text) > min_length: try: ast.parse(lambda_text) return lambda_text except SyntaxError: lambda_text = lambda_text[:-1] return None Considering that we’re basically taking lessons from the dusty old tomes in the Restricted Section of Hogwarts library, the magic here looks quite simple. As long as there is something that can pass for a lambda definition, we try to parse it and see if it succeeds. The line that says except SyntaxError: is obviously not something for the faint of heart, but at least we are specifying what exception we anticipate catching. And the kicker? It works. By that I mean it doesn’t return garbage results for a few obvious and not so obvious test cases, which is already more than you would normally expect from hacks of this magnitude. All the lambdas defined until this paragraph, for example, can have their source code extracted without issue. Just one more thing So… victory? Not quite. Astute readers may recall my promise of some bytecode arcana, and now’s the time for it. Despite the initial success of our gradual, character dropping approach, there are cases where it doesn’t produce the correct result. Consider, for example, a lambda definition that’s nestled within a tuple2: >>> x = lambda _: True, 0 >>> get_short_lambda_source(x[0]) lambda _: True, 0 We would of course expect the result to be lambda _: True, without a comma or zero. Unfortunately, here’s where our earlier assumption fails rather spectacularly. The line of code extracted from AST is syntactically valid even with the extra characters. As a result, ast.parse succeeds too early and returns an incorrect definition. It should have been of a lambda contained within a tuple, but tuple is apparently what the lambda returns. You may say that this is the sharp end of a narrow edge case, and anyone who defines functions like that deserves all the trouble they get. And sure, I wouldn’t mind if we just threw hands in the air and told them we’re simply unable to retrieve the source here. But my opinion is that it doesn’t justify serving them obviously wrong results! A halting problem Not if we can help it, anyway. Have a look at the expected source code and the one we’ve extracted, side by side: lambda _: True lambda _: True, 0 The second line isn’t just longer: it is also doing more. It isn’t just defining a lambda; it defines it, conjures up a constant 0, and then packs them both into a tuple. That’s at least two additional steps compared to the original. Those steps have a more precise name, too: they are the bytecode instructions. Every piece of Python source is compiled to a binary bytecode before it’s executed, because the interpreter can only work with this representation. Compilation typically happens when a Python module is first imported, producing a .pyc file corresponding to its .py file. Subsequent imports will simply reuse the cached bytecode. Moreover, any function or class object has its bytecode accessible (read-only) at runtime. There is even a dedicated data type to hold it — called simply code — with a buffer of raw bytes under one of its attributes. Finally, the bytecode compiler itself is also available to Python programs as a built-in compile function. You don’t see it used as often as its counterparts eval and exec (which hopefully are a rare sight themselves!), but it taps into the same internal machinery of Python. So how does it all add up? The idea is, basically, to cross-check the alleged source code of the lambda with its own bytecode. Any junk that’s still left to trim — even if syntactically valid — will surface as a divergence after compilation. Thus we can simply continue dropping characters until the bytecodes match: lambda_text = source_text[lambda_node.col_offset:] lambda_body_text = source_text[lambda_node.body.col_offset:] min_length = len('lambda:_') # shortest possible lambda expression while len(lambda_text) > min_length: try: code = compile(lambda_body_text, '<unused filename>', 'eval') if len(code.co_code) == len(lambda_func.__code__.co_code): return lambda_text except SyntaxError: pass lambda_text = lambda_text[:-1] lambda_body_text = lambda_body_text[:-1] return None Okay, maybe not the exact bytes3, but stopping at the identical bytecode length is good enough a strategy. As an obvious bonus, compile will also take care of detecting syntax errors in the candidate source code, so we don’t need the ast parsing anymore. That escalated quickly! Believe it or not, but there aren’t any more objections to this solution, You can view it in its glorious entirety by looking at this gist. Does it mean it is also making its cameo in the callee library?… No, I’m afraid not. Normally, I’m not the one to shy away from, ahem, bold solutions to tough problems. But in this case, the magnitude of hackery required is just too great, the result not satisfactory enough, the feature’s priority isn’t really all that high, and the maintenance burden it’d introduce is most likely too large. In the end, it was great fun figuring it out: yet another example of how you can fiddle with Python to do basically anything. Still, we must not get too preoccupied with whether or not we can as to forget if we should. Backslash (\) is how lambda functions are denoted in Haskell. We want to be short and sweet, so it feels like a natural choice. ↩ This isn’t an actual snippet from a Python REPL, because inspect.getsourcelines requires the object to be defined in a .py file. ↩ Why we won’t always get an identical bytecode? The short answer is that some instructions may be swapped for their approximate equivalents. The long answer is that with compile, we aren’t able to replicate the exact closure environment of the original lambda. When a function refers to an free variable (like foo in lambda x: x + foo), it is its closure where the value for that variable comes from. For ad-hoc lambdas, this is typically the local scope of its outer function. Code produced by compile, however, isn’t associated with any such local scope. All free names are thus assumed to refer to global variables. Because Python uses different bytecode instructions for referencing local and global names (LOAD_FAST vs LOAD_GLOBAL), the result of compile may differ from a piece of bytecode produced in the regular manner. ↩"
}
</script></body>
</html>