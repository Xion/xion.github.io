<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="http://xion.io/$theme/stylesheet/font-awesome.min.css">

    <link href="http://xion.io/style.css" rel="stylesheet">




  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

<meta name="author" content="Karol Kuczmarski" />
<meta name="description" content="In this post, I want to discuss some of the experiences I had with a project that I recently finished, gisht. By “finished” I mean that I don’t anticipate developing any new major features for it, though smaller things, bug fixes, or non-code stuff, is of course still very possible. I’m thinking this is as much “done” as most software projects can ever hope to be. Thus, it is probably the best time for a recap / summary / postmortem / etc. — something to recount the lessons learned, and assess the choices made. Some context The original purpose of gisht was to facilitate download &amp; execution of GitHub gists straight from the command line: $ gisht Xion/git-outgoing # run the https://gist.github.com/Xion/git-outgoing gist I initially wrote its first version in Python because I’ve accumulated a sizable number of small &amp; useful scripts (for Git, Unix, Python, etc.) which were all posted as gists. Sure, I could download them manually to ~/bin every time I used a new machine but that’s rather cumbersome, and I’m quite lazy. Well, lazy and impatient :) I noticed pretty fast that the speed tax of Python is basically unacceptable for a program like gisht. What I’m referring to here is not the speed of code execution, however, but only the startup time of Python interpreter. Irrespective of the machine, operating system, or language version, it doesn’t seem to go lower than about one hundred milliseconds; empirically, it’s often 2 or 3 times higher than that. For the common case of finding a cached gist (no downloads) and doing a simple fork+exec, this startup time was very noticeable and extremely jarring. It also precluded some more sophisticated uses for gisht, like putting its invocation into the shell’s $PROMPT1. Speed: delivered And so the obvious solution emerged: let’s rewrite it in Rust!… Because if I’m executing code straight from the internet, I should at least do it in a safe language. But jokes aside, it is obvious that a language compiling to native code is likely a good pick if you want to optimize for startup speed. So while the choice of Rust was in large part educational (gisht was one of my first projects to be written in it), it definitely hasn’t disappointed there. Even without any intentional optimization efforts, the app still runs instantaneously. I tried to take some measurements using the time command, but it never ticked into more than 0.001s. Perceptively, it is at least on par with git, so that’s acceptable for me :) Can’t segfault if your code doesn’t build Achieving the performance objective wouldn’t do us much good, however, if the road to get there involved excessive penalties on productivity. Such negative impact could manifest in many ways, including troublesome debugging due to a tricky runtime2, or difficulty in getting the code to compile in the first place. If you had even a passing contact with Rust, you’d expect the latter to be much more likely than the former. Indeed, Rust’s very design eschews runtime flexibility to a ridiculous degree (in its “safe” mode, at least), while also forcing you to absorb subtle &amp; complex ideas to even get your code past the compiler. The reward is increased likelihood your program will behave as intended — although it’s definitely not on the level of “if it compiles, it works” that can be offered by Haskell or Idris. But since gisht is hardly mission critical, I didn’t actually care too much about this increased reliability. I don’t think it’s likely that Rust would buy me much over something like modern C++. And if I were to really do some kind of cost-benefit analysis of several languages — rather than going with Rust simply to learn it better — then it would be hard to justify it over something like Go. It scales So the real question is: has Rust not hampered my productivity too much? Having the benefit of hindsight, I’m happy to say that the trade-off was definitely acceptable :) One thing I was particularly satisfied with was the language’s scalability. What I mean here is the ability to adapt as the project grows, but also to start quickly and remain nimble while the codebase is still pretty small. Many languages (most, perhaps) are naturally tailored towards the large end, doing their best to make it more bearable to work with big codebases. In turn, they often forget about helping projects take off in the first place. Between complicated build systems and dependency managers (Java), or a virtual lack of either (C++), it can be really hard to get going in a “serious” language like this. On the other hand, languages like Python make it very easy to start up and achieve relatively impressive results. Some people, however, report having encountered problems once the code evolves past certain size. While I’m actually very unsympathetic to those claims, I realize perception plays a significant role here, making those anecdotal experiences into a sort of self-fulfilling prophecy. This perception problem should almost certainly spare Rust, as it’s a natively compiled and statically typed language, with a respectable type system to boot. There is also some evidence that the language works well in large projects already. So the only question that we might want to ask is: how easy it is to actually start a project in Rust, and carry it towards some kind of MVP? Based on my experiences with gisht, I can say that it is, in fact, quite easy. Thanks mostly to the impressive Swiss army knife of cargo — acting as both package manager and a rudimentary build system — it was almost Python-trivial to cook a “Hello World” program that does something tangible, like talk to a JSON API. From there, it only took a few coding sessions to grow it into a functioning prototype. Abstractions galore As part of rewriting gisht from Python to Rust, I also wanted to fix some longstanding issues that limited its capabilities. The most important one was the hopeless coupling to GitHub and their particular flavor of gists. Sure, this is where the project even got its name from, but people use a dozen of different services to share code snippets and it should very possible to support them all. Here’s where it became necessary to utilize the abstraction capabilities that Rust has to offer. It was somewhat obvious to define a Host trait but of course its exact form had to be shaped over numerous iterations. Along the way, it even turned out that Result&lt;Option&lt;T&gt;&gt; and Option&lt;Result&lt;T&gt;&gt; are sometimes both necessary as return types :) Besides cleaner architecture, another neat thing about an explicit abstraction is the ability to slice a concept into smaller pieces — and then put some of them back together. While the Host trait could support a very diverse set of gist services and pastebins, many of them turned out to be just a slight variation of one central theme. Because of this similarity, it was possible to introduce a single Basic implementation which handles multiple services through varying sets of URL patterns. Devices like these aren’t of course specific to Rust: interfaces (traits) and classes are a staple of OO languages in general. But some other techniques were more idiomatic; the concept of iterators, for example, is flexible enough to accommodate looping over GitHub user’s gists, even as they read directly from HTTP responses. Hacking time Not everything was sunshine and rainbows, though. Take clap, for example. It’s mostly a very good crate for parsing command line arguments, but it couldn’t quite cope with the unusual requirements that gisht had. To make gisht Foo/bar work alongside gisht run Foo/bar, it was necessary to analyze argv before even handing it over to clap. This turned out to be surprisingly tricky to get right. Like, really tricky, with edges cases and stuff. But as it is often the case in software, the answer turned out to be yet another layer of indirection plus a copious amount of tests. In another instance, however, a direct library support was crucial. It so happened that hyper, the crate I’ve been using for HTTP requests, didn’t handle the Link: response header out of the box3. This was a stumbling block that prevented the gist iterator (mentioned earlier) from correctly handling pagination in the responses from GitHub API. Thankfully, having the Header abstraction in hyper meant it was possible to add the missing support in a relatively straighforward manner. Yes, it’s not a universal implementation that’d be suitable for every HTTP client, but it does the job for gisht just fine. Test-Reluctant Development And so the program kept growing steadily over the months, most notably through more and more gist hosts it could now support. Eventually, some of them would fall into a sort of twilight zone. They weren’t as complicated as GitHub to warrant writing a completely new Host instance, but they also couldn’t be handled via the Basic structure alone. A good example would be sprunge.us: mostly an ordinary pastebin, except for its optional syntax highlighting which may add some “junk” to the otherwise regular URLs. In order to handle those odd cases, I went for a classic wrapper/decorator pattern which, in its essence, boils down to something like this: pub struct Sprunge { inner: Basic, } impl Sprunge { pub fn new() -&gt; { Sprunge{inner: Basic::new(ID, &#34;sprunge.us&#34;, &#34;http://sprunge.us/${id}&#34;, ...)} } } impl Host for Sprunge { // override &amp; wrap methods that require custom logic: fn resolve_url(&amp;self, url: &amp;str) -&gt; Option&lt;io::Result&lt;Gist&gt;&gt; { let mut url_obj = try_opt!(Url::parse(url).ok()); url_obj.set_query(None); inner.resolve_url(url_obj.to_string().as_str()) } // passthrough to the `Basic` struct for others: fn fetch_gist(&amp;self, gist: &amp;Gist, mode: FetchMode) -&gt; io::Result&lt;()&gt; { self.inner.fetch_gist(gist, mode) } // (etc.) } Despite the noticeable boilerplate of a few pass-through methods, I was pretty happy with this solution, at least initially. After a few more unusual hosts, however, it became cumbersome to fix all the edge cases by looking only at the final output of the inner Basic implementation. The code was evidently asking for some tests, if only to check how the inner structure is being called. Shouldn’t be too hard, right?… Yeah, that’s what I thought, too. The reality, unfortunately, fell very short of those expectations. Stubs, mocks, fakes — test doubles in general — are a dark and forgotten corner of Rust that almost no one seems to pay any attention to. Absent a proper library support — much less a language one — the only way forward was to roll up my sleeves and implement a fake Host from scratch. But that was just the beginning. How do you seamlessly inject this fake implementation into the wrapper so that it replaces the Basic struct for testing? If you are not careful and go for the “obvious” solution — a trait object: pub struct Sprunge { inner: Box&lt;Host&gt;, } you’ll soon realize that you need not just a Box, but at least an Rc (or maybe even Arc). Without this kind of shared ownership, you’ll lose your chance to interrogate the test double once you hand it over to the wrapper. This, in turn, will heavily limit your ability to write effective tests. What’s the non-obvious approach, then? The full rationale would probably warrant a separate post, but the working recipe looks more or less like this: First, parametrize the wrapper with its inner type: pub struct Sprunge&lt;T: Host&gt; { inner: T }. Put that in an internal module with the correct visibility setup: mod internal { pub struct Sprunge&lt;T: Host&gt; { pub(super) inner: T, } } Make the regular (“production”) version of the wrapper into an alias, giving it the type parameter that you’ve been using directly4: pub type Sprunge = internal::Sprunge&lt;Basic&gt;; Change the new constructor to instantiate the internal type. In tests, create the wrapper with a fake inner object inside. As you can see in the real example, this convoluted technique removes the need for any pointer indirection. It also permits you to access the out-of-band interface that a fake object would normally expose. It’s a shame, though, that so much work is required for something that should be very simple. As it appears, testing is still a neglected topic in Rust. Packing up It wasn’t just Rust that played a notable role in the development of gisht. Pretty soon after getting the app to a presentable state, it became clear that a mere cargo build won’t do everything that’s necessary to carry out a complete build. It could do more, admittedly, if I had the foresight to explore Cargo build scripts a little more thoroughly. But overall, I don’t regret dropping back to my trusty ol’ pick: Python. Like in a few previous projects, I used the Invoke task runner for both the crucial and the auxiliary automation tasks. It is a relatively powerful tool — and probably the best in its class in Python that I know of — though it can be a bit capricious if you want to really fine-tune it. But it does make it much easier to organize your automation code, to reuse it between tasks, and to (ahem) invoke those tasks in a convenient manner. In any case, it certainly beats a collection of disconnected Bash scripts ;) What have I automated in this way, you may ask? Well, a couple of small things; those include: embedding of the current Git commit hash into the binary, to help identify the exact revision in the logs of any potential bug reports5 after a successful build, replacing the Usage section in README with the program’s --help output generating completion scripts for popular shells by invoking the binary with a magic hidden flag (courtesy of clap) Undoubtedly the biggest task that I relegated to Python/Invoke, was the preparation of release packages. When it comes to the various Linuxes (currently Debian and Red Hat flavors), this wasn’t particularly complicated. Major thanks are due to the amazing fpm tool here, which I recommend to anyone who needs to package their software in a distro-compatible manner. Homebrew, however — or more precisely, OS X itself — was quite a different story. Many, many failed attempts were needed to even get it to build on Travis, and the additional dependency on Python was partially to blame. To be fair, however, most of the pain was exclusively due to OpenSSL; getting that thing to build is always loads of “fun”, especially in such an opaque and poorly debuggable environment as Travis. The wrap There’s probably a lot of minor things and tidbits I could’ve mentioned along the way, but the story so far has most likely covered all the important topics. Let’s wrap it up then, and highlight some interesting points in the classic Yay/Meh/Nay manner. Yay It was definitely a good choice to rewrite gisht specifically in Rust. Besides all the advantages I’ve mentioned already, it is also worth noting that the language went through about 10 minor version bumps while I was working on this project. Of all those new releases, I don’t recall a single one that would introduce a breaking change. Most of the Rust ecosystem (third-party libraries) was a joy to use, and very easy to get started with. Honorable mention goes to serde_json and how easy it was to transition the code from rustc_serialize that I had used at first. With a possible exception of sucking in node.js as a huge dependency of your project and using Grunt, there is probably no better way of writing automation &amp; support code than Python. There may eventually be some Rust-based task runners that could try to compete, but I’m not very convinced about using a compiled language for this purpose (and especially one that takes so long to build). Meh While the clap crate is quite configurable and pretty straightforward to use, it does lack at least one feature that’d be very nice for gisht. Additionally, working with raw clap is often a little tedious, as it doesn’t assist you in translating parsed flags into your own configuration types, and thus requires shuffling those bits manually6. Being a defacto standard for continuous integration in open-source projects, Travis CI could be a little less finicky. In almost every project I decide to use it for, I end up with about half a dozen commits that frantically try to fix silly configuration issues, all before even a simple .travis.yml works as intended. Providing a way to test CI builds locally would be an obvious way to avoid this churn. Nay Testing in Rust is such a weird animal. On one hand, there is a first-class, out-of-the-box support for unit tests (and even integration tests) right in the toolchain. On the other hand, the relevant parts of the ecosystem are immature or lacking, as evidenced by the dreary story of mocking and stubbing. It’s no surprise that there is a long way to catch up to languages with the strongest testing culture (Java and C#/.NET7), but it’s disappointing to see Rust outclassed even by C++. Getting anything to build reliably on OSX in a CI environment is already a tall order. But if it involves things as OpenSSL, then it quickly goes from bad to terrible. I’m really not amused anymore how this “Just Works” system often turns out to hardly work at all. Since I don’t want to end on such a negative note, I feel compelled to state the obvious fact: every technology choice is a trade-off. In case of this project, however, the drawbacks were heavily outweighed by the benefits. For this reason, I can definitely recommend the software stack I’ve just described to anyone developing non-trivial, cross-platform command line tools. This is not an isolated complaint, by the way, as the interpreter startup time has recently emerged as an important issue to many developers of the Python language. ↩ Which may also include a practical lack thereof. ↩ It does handle it now, fortunately. ↩ Observant readers may notice that we’re exposing a technically private type (internal::Sprunge) through a publicly visible type alias. If that type was actually private, this would trigger a compiler warning which is slated to become a hard error at some point in the future. But, amusingly, we can fool the compiler by making it a public type inside a private module, which is exactly what we’re doing here. ↩ This has since been rewritten and is now done in build.rs — but that’s only because I implemented the relevant Cargo feature myself :) ↩ For an alternative approach that doesn’t seem to have this problem, check the structopt crate. ↩ Dynamically typed languages, due to their rich runtime, are basically a class of their own when it comes to testing ease, so it wouldn’t really be fair to hold them up for comparison. ↩" />
<meta name="keywords" content="Rust, gisht, CLI, GitHub, Python, testing">
<meta property="og:site_name" content="Karol Kuczmarski's Blog"/>
<meta property="og:title" content="Recap of the gisht project"/>
<meta property="og:description" content="In this post, I want to discuss some of the experiences I had with a project that I recently finished, gisht. By “finished” I mean that I don’t anticipate developing any new major features for it, though smaller things, bug fixes, or non-code stuff, is of course still very possible. I’m thinking this is as much “done” as most software projects can ever hope to be. Thus, it is probably the best time for a recap / summary / postmortem / etc. — something to recount the lessons learned, and assess the choices made. Some context The original purpose of gisht was to facilitate download &amp; execution of GitHub gists straight from the command line: $ gisht Xion/git-outgoing # run the https://gist.github.com/Xion/git-outgoing gist I initially wrote its first version in Python because I’ve accumulated a sizable number of small &amp; useful scripts (for Git, Unix, Python, etc.) which were all posted as gists. Sure, I could download them manually to ~/bin every time I used a new machine but that’s rather cumbersome, and I’m quite lazy. Well, lazy and impatient :) I noticed pretty fast that the speed tax of Python is basically unacceptable for a program like gisht. What I’m referring to here is not the speed of code execution, however, but only the startup time of Python interpreter. Irrespective of the machine, operating system, or language version, it doesn’t seem to go lower than about one hundred milliseconds; empirically, it’s often 2 or 3 times higher than that. For the common case of finding a cached gist (no downloads) and doing a simple fork+exec, this startup time was very noticeable and extremely jarring. It also precluded some more sophisticated uses for gisht, like putting its invocation into the shell’s $PROMPT1. Speed: delivered And so the obvious solution emerged: let’s rewrite it in Rust!… Because if I’m executing code straight from the internet, I should at least do it in a safe language. But jokes aside, it is obvious that a language compiling to native code is likely a good pick if you want to optimize for startup speed. So while the choice of Rust was in large part educational (gisht was one of my first projects to be written in it), it definitely hasn’t disappointed there. Even without any intentional optimization efforts, the app still runs instantaneously. I tried to take some measurements using the time command, but it never ticked into more than 0.001s. Perceptively, it is at least on par with git, so that’s acceptable for me :) Can’t segfault if your code doesn’t build Achieving the performance objective wouldn’t do us much good, however, if the road to get there involved excessive penalties on productivity. Such negative impact could manifest in many ways, including troublesome debugging due to a tricky runtime2, or difficulty in getting the code to compile in the first place. If you had even a passing contact with Rust, you’d expect the latter to be much more likely than the former. Indeed, Rust’s very design eschews runtime flexibility to a ridiculous degree (in its “safe” mode, at least), while also forcing you to absorb subtle &amp; complex ideas to even get your code past the compiler. The reward is increased likelihood your program will behave as intended — although it’s definitely not on the level of “if it compiles, it works” that can be offered by Haskell or Idris. But since gisht is hardly mission critical, I didn’t actually care too much about this increased reliability. I don’t think it’s likely that Rust would buy me much over something like modern C++. And if I were to really do some kind of cost-benefit analysis of several languages — rather than going with Rust simply to learn it better — then it would be hard to justify it over something like Go. It scales So the real question is: has Rust not hampered my productivity too much? Having the benefit of hindsight, I’m happy to say that the trade-off was definitely acceptable :) One thing I was particularly satisfied with was the language’s scalability. What I mean here is the ability to adapt as the project grows, but also to start quickly and remain nimble while the codebase is still pretty small. Many languages (most, perhaps) are naturally tailored towards the large end, doing their best to make it more bearable to work with big codebases. In turn, they often forget about helping projects take off in the first place. Between complicated build systems and dependency managers (Java), or a virtual lack of either (C++), it can be really hard to get going in a “serious” language like this. On the other hand, languages like Python make it very easy to start up and achieve relatively impressive results. Some people, however, report having encountered problems once the code evolves past certain size. While I’m actually very unsympathetic to those claims, I realize perception plays a significant role here, making those anecdotal experiences into a sort of self-fulfilling prophecy. This perception problem should almost certainly spare Rust, as it’s a natively compiled and statically typed language, with a respectable type system to boot. There is also some evidence that the language works well in large projects already. So the only question that we might want to ask is: how easy it is to actually start a project in Rust, and carry it towards some kind of MVP? Based on my experiences with gisht, I can say that it is, in fact, quite easy. Thanks mostly to the impressive Swiss army knife of cargo — acting as both package manager and a rudimentary build system — it was almost Python-trivial to cook a “Hello World” program that does something tangible, like talk to a JSON API. From there, it only took a few coding sessions to grow it into a functioning prototype. Abstractions galore As part of rewriting gisht from Python to Rust, I also wanted to fix some longstanding issues that limited its capabilities. The most important one was the hopeless coupling to GitHub and their particular flavor of gists. Sure, this is where the project even got its name from, but people use a dozen of different services to share code snippets and it should very possible to support them all. Here’s where it became necessary to utilize the abstraction capabilities that Rust has to offer. It was somewhat obvious to define a Host trait but of course its exact form had to be shaped over numerous iterations. Along the way, it even turned out that Result&lt;Option&lt;T&gt;&gt; and Option&lt;Result&lt;T&gt;&gt; are sometimes both necessary as return types :) Besides cleaner architecture, another neat thing about an explicit abstraction is the ability to slice a concept into smaller pieces — and then put some of them back together. While the Host trait could support a very diverse set of gist services and pastebins, many of them turned out to be just a slight variation of one central theme. Because of this similarity, it was possible to introduce a single Basic implementation which handles multiple services through varying sets of URL patterns. Devices like these aren’t of course specific to Rust: interfaces (traits) and classes are a staple of OO languages in general. But some other techniques were more idiomatic; the concept of iterators, for example, is flexible enough to accommodate looping over GitHub user’s gists, even as they read directly from HTTP responses. Hacking time Not everything was sunshine and rainbows, though. Take clap, for example. It’s mostly a very good crate for parsing command line arguments, but it couldn’t quite cope with the unusual requirements that gisht had. To make gisht Foo/bar work alongside gisht run Foo/bar, it was necessary to analyze argv before even handing it over to clap. This turned out to be surprisingly tricky to get right. Like, really tricky, with edges cases and stuff. But as it is often the case in software, the answer turned out to be yet another layer of indirection plus a copious amount of tests. In another instance, however, a direct library support was crucial. It so happened that hyper, the crate I’ve been using for HTTP requests, didn’t handle the Link: response header out of the box3. This was a stumbling block that prevented the gist iterator (mentioned earlier) from correctly handling pagination in the responses from GitHub API. Thankfully, having the Header abstraction in hyper meant it was possible to add the missing support in a relatively straighforward manner. Yes, it’s not a universal implementation that’d be suitable for every HTTP client, but it does the job for gisht just fine. Test-Reluctant Development And so the program kept growing steadily over the months, most notably through more and more gist hosts it could now support. Eventually, some of them would fall into a sort of twilight zone. They weren’t as complicated as GitHub to warrant writing a completely new Host instance, but they also couldn’t be handled via the Basic structure alone. A good example would be sprunge.us: mostly an ordinary pastebin, except for its optional syntax highlighting which may add some “junk” to the otherwise regular URLs. In order to handle those odd cases, I went for a classic wrapper/decorator pattern which, in its essence, boils down to something like this: pub struct Sprunge { inner: Basic, } impl Sprunge { pub fn new() -&gt; { Sprunge{inner: Basic::new(ID, &#34;sprunge.us&#34;, &#34;http://sprunge.us/${id}&#34;, ...)} } } impl Host for Sprunge { // override &amp; wrap methods that require custom logic: fn resolve_url(&amp;self, url: &amp;str) -&gt; Option&lt;io::Result&lt;Gist&gt;&gt; { let mut url_obj = try_opt!(Url::parse(url).ok()); url_obj.set_query(None); inner.resolve_url(url_obj.to_string().as_str()) } // passthrough to the `Basic` struct for others: fn fetch_gist(&amp;self, gist: &amp;Gist, mode: FetchMode) -&gt; io::Result&lt;()&gt; { self.inner.fetch_gist(gist, mode) } // (etc.) } Despite the noticeable boilerplate of a few pass-through methods, I was pretty happy with this solution, at least initially. After a few more unusual hosts, however, it became cumbersome to fix all the edge cases by looking only at the final output of the inner Basic implementation. The code was evidently asking for some tests, if only to check how the inner structure is being called. Shouldn’t be too hard, right?… Yeah, that’s what I thought, too. The reality, unfortunately, fell very short of those expectations. Stubs, mocks, fakes — test doubles in general — are a dark and forgotten corner of Rust that almost no one seems to pay any attention to. Absent a proper library support — much less a language one — the only way forward was to roll up my sleeves and implement a fake Host from scratch. But that was just the beginning. How do you seamlessly inject this fake implementation into the wrapper so that it replaces the Basic struct for testing? If you are not careful and go for the “obvious” solution — a trait object: pub struct Sprunge { inner: Box&lt;Host&gt;, } you’ll soon realize that you need not just a Box, but at least an Rc (or maybe even Arc). Without this kind of shared ownership, you’ll lose your chance to interrogate the test double once you hand it over to the wrapper. This, in turn, will heavily limit your ability to write effective tests. What’s the non-obvious approach, then? The full rationale would probably warrant a separate post, but the working recipe looks more or less like this: First, parametrize the wrapper with its inner type: pub struct Sprunge&lt;T: Host&gt; { inner: T }. Put that in an internal module with the correct visibility setup: mod internal { pub struct Sprunge&lt;T: Host&gt; { pub(super) inner: T, } } Make the regular (“production”) version of the wrapper into an alias, giving it the type parameter that you’ve been using directly4: pub type Sprunge = internal::Sprunge&lt;Basic&gt;; Change the new constructor to instantiate the internal type. In tests, create the wrapper with a fake inner object inside. As you can see in the real example, this convoluted technique removes the need for any pointer indirection. It also permits you to access the out-of-band interface that a fake object would normally expose. It’s a shame, though, that so much work is required for something that should be very simple. As it appears, testing is still a neglected topic in Rust. Packing up It wasn’t just Rust that played a notable role in the development of gisht. Pretty soon after getting the app to a presentable state, it became clear that a mere cargo build won’t do everything that’s necessary to carry out a complete build. It could do more, admittedly, if I had the foresight to explore Cargo build scripts a little more thoroughly. But overall, I don’t regret dropping back to my trusty ol’ pick: Python. Like in a few previous projects, I used the Invoke task runner for both the crucial and the auxiliary automation tasks. It is a relatively powerful tool — and probably the best in its class in Python that I know of — though it can be a bit capricious if you want to really fine-tune it. But it does make it much easier to organize your automation code, to reuse it between tasks, and to (ahem) invoke those tasks in a convenient manner. In any case, it certainly beats a collection of disconnected Bash scripts ;) What have I automated in this way, you may ask? Well, a couple of small things; those include: embedding of the current Git commit hash into the binary, to help identify the exact revision in the logs of any potential bug reports5 after a successful build, replacing the Usage section in README with the program’s --help output generating completion scripts for popular shells by invoking the binary with a magic hidden flag (courtesy of clap) Undoubtedly the biggest task that I relegated to Python/Invoke, was the preparation of release packages. When it comes to the various Linuxes (currently Debian and Red Hat flavors), this wasn’t particularly complicated. Major thanks are due to the amazing fpm tool here, which I recommend to anyone who needs to package their software in a distro-compatible manner. Homebrew, however — or more precisely, OS X itself — was quite a different story. Many, many failed attempts were needed to even get it to build on Travis, and the additional dependency on Python was partially to blame. To be fair, however, most of the pain was exclusively due to OpenSSL; getting that thing to build is always loads of “fun”, especially in such an opaque and poorly debuggable environment as Travis. The wrap There’s probably a lot of minor things and tidbits I could’ve mentioned along the way, but the story so far has most likely covered all the important topics. Let’s wrap it up then, and highlight some interesting points in the classic Yay/Meh/Nay manner. Yay It was definitely a good choice to rewrite gisht specifically in Rust. Besides all the advantages I’ve mentioned already, it is also worth noting that the language went through about 10 minor version bumps while I was working on this project. Of all those new releases, I don’t recall a single one that would introduce a breaking change. Most of the Rust ecosystem (third-party libraries) was a joy to use, and very easy to get started with. Honorable mention goes to serde_json and how easy it was to transition the code from rustc_serialize that I had used at first. With a possible exception of sucking in node.js as a huge dependency of your project and using Grunt, there is probably no better way of writing automation &amp; support code than Python. There may eventually be some Rust-based task runners that could try to compete, but I’m not very convinced about using a compiled language for this purpose (and especially one that takes so long to build). Meh While the clap crate is quite configurable and pretty straightforward to use, it does lack at least one feature that’d be very nice for gisht. Additionally, working with raw clap is often a little tedious, as it doesn’t assist you in translating parsed flags into your own configuration types, and thus requires shuffling those bits manually6. Being a defacto standard for continuous integration in open-source projects, Travis CI could be a little less finicky. In almost every project I decide to use it for, I end up with about half a dozen commits that frantically try to fix silly configuration issues, all before even a simple .travis.yml works as intended. Providing a way to test CI builds locally would be an obvious way to avoid this churn. Nay Testing in Rust is such a weird animal. On one hand, there is a first-class, out-of-the-box support for unit tests (and even integration tests) right in the toolchain. On the other hand, the relevant parts of the ecosystem are immature or lacking, as evidenced by the dreary story of mocking and stubbing. It’s no surprise that there is a long way to catch up to languages with the strongest testing culture (Java and C#/.NET7), but it’s disappointing to see Rust outclassed even by C++. Getting anything to build reliably on OSX in a CI environment is already a tall order. But if it involves things as OpenSSL, then it quickly goes from bad to terrible. I’m really not amused anymore how this “Just Works” system often turns out to hardly work at all. Since I don’t want to end on such a negative note, I feel compelled to state the obvious fact: every technology choice is a trade-off. In case of this project, however, the drawbacks were heavily outweighed by the benefits. For this reason, I can definitely recommend the software stack I’ve just described to anyone developing non-trivial, cross-platform command line tools. This is not an isolated complaint, by the way, as the interpreter startup time has recently emerged as an important issue to many developers of the Python language. ↩ Which may also include a practical lack thereof. ↩ It does handle it now, fortunately. ↩ Observant readers may notice that we’re exposing a technically private type (internal::Sprunge) through a publicly visible type alias. If that type was actually private, this would trigger a compiler warning which is slated to become a hard error at some point in the future. But, amusingly, we can fool the compiler by making it a public type inside a private module, which is exactly what we’re doing here. ↩ This has since been rewritten and is now done in build.rs — but that’s only because I implemented the relevant Cargo feature myself :) ↩ For an alternative approach that doesn’t seem to have this problem, check the structopt crate. ↩ Dynamically typed languages, due to their rich runtime, are basically a class of their own when it comes to testing ease, so it wouldn’t really be fair to hold them up for comparison. ↩"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://xion.io/post/programming/gisht-recap.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2017-11-24 17:52:00+00:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="http://xion.io/">
<meta property="article:section" content="Programming"/>
<meta property="article:tag" content="Rust"/>
<meta property="article:tag" content="gisht"/>
<meta property="article:tag" content="CLI"/>
<meta property="article:tag" content="GitHub"/>
<meta property="article:tag" content="Python"/>
<meta property="article:tag" content="testing"/>
<meta property="og:image" content="http://xion.io/logo.jpeg">
  <title>Karol Kuczmarski's Blog &ndash; Recap of the gisht project</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://xion.io">
        <img src="http://xion.io/logo.jpeg" alt="Karol Kuczmarski" title="Karol Kuczmarski">
      </a>
      <h1><a href="http://xion.io">Karol Kuczmarski</a></h1>
      <p>fn(Tea) -> Code</p>
      <nav>
        <ul class="list">
          <li><a href="http://xion.io/page/about.html#about">About</a></li>
          <li><a href="http://xion.io/page/projects.html#projects">Projects</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-github" href="http://github.com/Xion" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-stack-overflow" href="http://stackoverflow.com/users/434799/xion" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
        <li><a class="sc-twitter" href="http://twitter.com/Xion__" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-google" href="https://plus.google.com/+KarolKuczmarski" target="_blank"><i class="fa fa-google"></i></a></li>
        <li><a class="sc-rss" href="/feeds/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="http://xion.io">Home</a>
      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>
      <a href="http://xion.org.pl/">Old blog</a>
    </nav>

<article>
  <header>
    <h1 id="gisht-recap">Recap of the gisht&nbsp;project</h1>
    <p>Posted on Fri 24 November 2017 in <a href="http://xion.io/category/programming.html">Programming</a></p>
  </header>
  <div>
    <p>In this post, I want to discuss some of the experiences I had with a project
that I recently finished, <a href="https://github.com/Xion/gisht"><em>gisht</em></a>.
By &#8220;finished&#8221; I mean that I don&#8217;t anticipate developing any new major features for it,
though smaller things, bug fixes, or non-code stuff, is of course still very&nbsp;possible.</p>
<p>I&#8217;m thinking this is as much &#8220;done&#8221; as most software projects can ever hope to be.
Thus, it is probably the best time for a recap / summary / postmortem / etc. &#8212;
something to recount the lessons learned, and assess the choices&nbsp;made.</p>
<h4>Some&nbsp;context</h4>
<p>The original purpose of <em>gisht</em> was to facilitate download <span class="amp">&amp;</span> execution of GitHub gists
straight from the command&nbsp;line:</p>
<div class="highlight"><pre><span class="nv">$ </span>gisht Xion/git-outgoing  <span class="c"># run the https://gist.github.com/Xion/git-outgoing gist</span>
</pre></div>


<p>I initially wrote <a href="https://github.com/Xion/gisht.py">its first version in Python</a>
because I&#8217;ve accumulated a sizable number of small <span class="amp">&amp;</span> useful scripts
(for Git, Unix, Python, etc.) which were all posted as gists.
Sure, I could download them manually to <code>~/bin</code> every time I used a new machine
but that&#8217;s rather cumbersome, and I&#8217;m quite&nbsp;lazy.</p>
<p>Well, lazy <em>and</em> impatient :)
I noticed pretty fast that the speed tax of Python
is basically unacceptable for a program like <em>gisht</em>.</p>
<p>What I&#8217;m referring to here is not the speed of code execution, however,
but only the <em>startup time</em> of Python interpreter.
Irrespective of the machine, operating system, or language version,
it doesn&#8217;t seem to go lower than about one hundred milliseconds;
empirically, it&#8217;s often 2 or 3 times higher than that.
For the common case of finding a cached gist (no downloads)
and doing a simple <code>fork</code>+<code>exec</code>,
this startup time was very noticeable and extremely jarring.
It also precluded some more sophisticated uses for <em>gisht</em>,
like putting its invocation into the shell&#8217;s <code>$PROMPT</code><sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>.</p>
<h4>Speed:&nbsp;delivered</h4>
<p>And so the obvious solution emerged:
let&#8217;s <a href="https://transitiontech.ca/random/RIIR">rewrite it in Rust</a>!&#8230;</p>
<p>Because if I&#8217;m executing code straight from the internet,
I should at least do it in a <em>safe</em>&nbsp;language.</p>
<p>But jokes aside, it is obvious that a language compiling to native code
is likely a good pick if you want to optimize for startup speed.
So while the choice of Rust was in large part educational
(<em>gisht</em> was one of my first projects to be written in it),
it definitely hasn&#8217;t disappointed&nbsp;there.</p>
<p>Even without any intentional optimization efforts,
the app still runs <em>instantaneously</em>.
I tried to take some measurements using the <code>time</code> command,
but it never ticked into more than 0.001s.
Perceptively, it is at least on par with <code>git</code>,
so that&#8217;s acceptable for me&nbsp;:)</p>
<h4>Can&#8217;t segfault if your code doesn&#8217;t&nbsp;build</h4>
<p>Achieving the performance objective wouldn&#8217;t do us much good, however,
if the road to get there involved excessive penalties on productivity.
Such negative impact could manifest in many ways,
including troublesome debugging due to a tricky runtime<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>,
or difficulty in getting the code to compile in the first&nbsp;place.</p>
<p>If you had even a passing contact with Rust,
you&#8217;d expect the latter to be much more likely than the&nbsp;former.</p>
<p>Indeed, Rust&#8217;s very design eschews runtime flexibility to a ridiculous degree
(in its &#8220;safe&#8221; mode, at least),
while also forcing you to absorb subtle <span class="amp">&amp;</span> complex ideas
to even get your code past the compiler.
The reward is increased likelihood your program will behave as intended &#8212;
although it&#8217;s definitely not on the level of &#8220;if it compiles, it works&#8221;
that can be offered by Haskell or&nbsp;Idris.</p>
<p>But since <em>gisht</em> is hardly mission critical,
I didn&#8217;t actually care too much about this increased reliability.
I don&#8217;t think it&#8217;s likely that Rust would buy me much over something like modern C++.
And if I were to <em>really</em> do some kind of cost-benefit analysis of several languages
&#8212; rather than going with Rust simply to learn it better &#8212;
then it would be hard to justify it over something like&nbsp;Go.</p>
<h4>It&nbsp;scales</h4>
<p>So the real question is: has Rust <em>not hampered</em> my productivity too much?
Having the benefit of hindsight,
I&#8217;m happy to say that the trade-off was definitely acceptable&nbsp;:)</p>
<p>One thing I was particularly satisfied with was the language&#8217;s <em>scalability</em>.
What I mean here is the ability to adapt as the project grows,
but also to start quickly and remain nimble
while the codebase is still pretty&nbsp;small.</p>
<p>Many languages (most, perhaps) are naturally tailored towards the large end,
doing their best to make it more bearable to work with big codebases.
In turn, they often forget about helping projects take off in the first place.
Between complicated build systems and dependency managers (Java),
or a virtual lack of either (C++),
it can be really hard to get going in a &#8220;serious&#8221; language like&nbsp;this.</p>
<p>On the other hand, languages like Python make it very easy to start up
and achieve relatively impressive results.
Some people, however, report having encountered problems
once the code evolves past certain size.
While I&#8217;m actually
<a href="http://xion.io/post/programming/long-live-dynamic-languages.html">very unsympathetic</a> to those claims,
I realize perception plays a significant role here,
making those anecdotal experiences into a sort of self-fulfilling&nbsp;prophecy.</p>
<p>This perception problem should almost certainly spare Rust,
as it&#8217;s a natively compiled and statically typed language,
with a respectable type system to boot.
There is also <a href="https://servo.org/">some evidence</a>
that the language works well in large projects already.
So the only question that we might want to ask is:
how easy it is to actually <em>start</em> a project in Rust,
and carry it towards some kind of <abbr title="Minimum Viable Product"><span class="caps">MVP</span></abbr>?</p>
<p>Based on my experiences with <em>gisht</em>,
I can say that it is, in fact, quite easy.
Thanks mostly to the impressive Swiss army knife of <code>cargo</code>
&#8212; acting as both package manager and a rudimentary build system &#8212;
it was almost Python-trivial to cook a &#8220;Hello World&#8221; program
that does something tangible, like
<a href="https://github.com/Xion/gisht/blob/de1be876784d671dd84618c3a15d0836f9fd5697/src/main.rs">talk to a <span class="caps">JSON</span> <span class="caps">API</span></a>.
From there, it only took a few coding sessions to grow it
into a <a href="https://github.com/Xion/gisht/tree/5c156cb">functioning prototype</a>.</p>
<h4>Abstractions&nbsp;galore</h4>
<p>As part of rewriting <em>gisht</em> from Python to Rust,
I also wanted to fix some longstanding issues that limited its&nbsp;capabilities.</p>
<p>The most important one was the hopeless coupling to GitHub
and their particular flavor of gists.
Sure, this is where the project even got its name from,
but people use a dozen of different services to share code snippets
and it should very possible to support them&nbsp;all.</p>
<p>Here&#8217;s where it became necessary to utilize
the abstraction capabilities that Rust has to offer.
It was somewhat obvious to
<a href="https://github.com/Xion/gisht/blob/3fc443dc9986612fd46b4311ca2ecbc613a15cf9/src/gist.rs#L16">define a <code>Host</code> trait</a>
but of course its exact form had to be
<a href="https://github.com/Xion/gisht/commit/26746dfc2eac68b67753f71148eb9897a861914e#diff-9d0a9c0911fa012f0fcf8ca56b43f8c5">shaped</a>
over <a href="https://github.com/Xion/gisht/commit/1e54ad05480b42089977171f10d4727beca5f835#diff-9d0a9c0911fa012f0fcf8ca56b43f8c5">numerous iterations</a>.
Along the way, it even turned out that <code>Result&lt;Option&lt;T&gt;&gt;</code> and <code>Option&lt;Result&lt;T&gt;&gt;</code>
are sometimes <a href="https://github.com/Xion/gisht/blob/d9c30e69d58b2a4e5608e6c8a1aa6392133b490f/src/hosts/mod.rs#L44">both necessary</a>
as return types&nbsp;:)</p>
<p>Besides cleaner architecture,
another neat thing about an explicit abstraction is
the ability to slice a concept into smaller pieces &#8212;
and then put <em>some of them</em> back together.
While the <code>Host</code> trait could support a very diverse set of gist services and <em>pastebins</em>,
many of them turned out to be just a slight variation of one central theme.
Because of this similarity, it was possible to introduce
a single <a href="https://github.com/Xion/gisht/blob/d2e78b1f5ee4616b1d5eb7067c3c5dd0ce9e2fe4/src/hosts/simple.rs#L26"><code>Basic</code> implementation</a>
which handles multiple services through varying sets of <span class="caps">URL</span>&nbsp;patterns.</p>
<p>Devices like these aren&#8217;t of course specific to Rust:
interfaces (traits) and classes are a staple of <span class="caps">OO</span> languages in general.
But some other techniques were more idiomatic;
the concept of <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">iterators</a>, for example,
is flexible enough to accommodate
<a href="https://github.com/Xion/gisht/blob/4fa347c6197190b0f6c68dd548efc28287a5859f/src/hosts/github.rs#L354">looping over GitHub user&#8217;s gists</a>,
even as they read directly from <span class="caps">HTTP</span>&nbsp;responses.</p>
<h4>Hacking&nbsp;time</h4>
<p>Not everything was sunshine and rainbows,&nbsp;though.</p>
<p>Take <em>clap</em>, for example.
It&#8217;s mostly a very good crate for parsing command line arguments,
but it couldn&#8217;t <em>quite</em> cope with the unusual requirements that <em>gisht</em> had.
To make <code>gisht Foo/bar</code> work alongside <code>gisht run Foo/bar</code>,
it was necessary to
<a href="https://github.com/Xion/gisht/commit/0eff00e31f94f3856558ebb1f6655a9e6fc50ca6#diff-7397f82f682a49eb62e2b056118124d0">analyze <code>argv</code></a>
before even handing it over to <code>clap</code>.
This turned out to be
<a href="https://github.com/Xion/gisht/commit/e7ab06a01d4675947965ec82fc6f3ec5a2517c89#diff-7397f82f682a49eb62e2b056118124d0">surprisingly tricky</a>
to get right.
Like,
<a href="https://github.com/Xion/gisht/commit/69e8aad4a1743beb57184dc38150ef02b306a0a1#diff-7397f82f682a49eb62e2b056118124d0">really</a>
tricky, with
<a href="https://github.com/Xion/gisht/commit/acadcfa0a97fe52584fbf8198541baa8733cb0a5#diff-7397f82f682a49eb62e2b056118124d0R58">edges cases</a>
and
<a href="https://github.com/Xion/gisht/commit/a9eb599168f5b6821aefa46dde0b0a89a41cd4e6#diff-7397f82f682a49eb62e2b056118124d0R562">stuff</a>.
But as it is often the case in software,
the answer turned out to be yet another layer of indirection plus
<a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/src/args.rs#L457-L578">a copious amount of tests</a>.</p>
<p>In another instance, however, a direct library support was&nbsp;crucial.</p>
<p>It so happened that <em>hyper</em>, the crate I&#8217;ve been using for <span class="caps">HTTP</span> requests,
didn&#8217;t handle the <code>Link:</code> response header out of the box<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>.
This was a stumbling block that prevented the gist iterator (mentioned earlier)
from correctly handling pagination in the responses from GitHub <span class="caps">API</span>.
Thankfully, having <a href="https://docs.rs/hyper/0.11.7/hyper/header/trait.Header.html">the <code>Header</code> abstraction</a> in <em>hyper</em>
meant it was possible to add the missing support in
<a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/src/ext/hyper.rs">a relatively straighforward manner</a>.
Yes, it&#8217;s <a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/src/ext/hyper.rs#L23">not a universal implementation</a>
that&#8217;d be suitable for <em>every</em> <span class="caps">HTTP</span> client,
but it does the job for <em>gisht</em> just&nbsp;fine.</p>
<h4>Test-Reluctant&nbsp;Development</h4>
<p>And so the program kept growing steadily over the months,
most notably through
<a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/src/hosts/mod.rs#L101">more and more gist hosts</a>
it could now&nbsp;support.</p>
<p>Eventually, some of them would fall into a sort of twilight zone.
They weren&#8217;t as complicated as GitHub to warrant writing a completely new <code>Host</code> instance,
but they also couldn&#8217;t be handled via
<a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/src/hosts/common/basic.rs#L28">the <code>Basic</code> structure</a> alone.
A good example would be <a href="http://sprunge.us/">sprunge.us</a>:
mostly an ordinary pastebin,
except for its optional syntax highlighting
which may add some &#8220;junk&#8221; to the otherwise regular&nbsp;URLs.</p>
<p>In order to handle those odd cases,
I went for a classic wrapper/decorator pattern which, in its essence,
boils down to something like&nbsp;this:</p>
<div class="highlight"><pre><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="n">Sprunge</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">inner</span><span class="o">:</span><span class="w"> </span><span class="n">Basic</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Sprunge</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">new</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Sprunge</span><span class="p">{</span><span class="n">inner</span><span class="o">:</span><span class="w"> </span><span class="n">Basic</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;sprunge.us&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="s">&quot;http://sprunge.us/${id}&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">...)}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Host</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Sprunge</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// override &amp; wrap methods that require custom logic:</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">resolve_url</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">url</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">io</span><span class="o">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Gist</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">url_obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">try_opt</span><span class="o">!</span><span class="p">(</span><span class="n">Url</span><span class="o">::</span><span class="n">parse</span><span class="p">(</span><span class="n">url</span><span class="p">).</span><span class="n">ok</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="n">url_obj</span><span class="p">.</span><span class="n">set_query</span><span class="p">(</span><span class="nb">None</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">inner</span><span class="p">.</span><span class="n">resolve_url</span><span class="p">(</span><span class="n">url_obj</span><span class="p">.</span><span class="n">to_string</span><span class="p">().</span><span class="n">as_str</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// passthrough to the `Basic` struct for others:</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">fetch_gist</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">gist</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Gist</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="o">:</span><span class="w"> </span><span class="n">FetchMode</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">io</span><span class="o">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">fetch_gist</span><span class="p">(</span><span class="n">gist</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// (etc.)</span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Despite the noticeable boilerplate of a few pass-through methods,
I was pretty happy with this solution, at least initially.
After a few more unusual hosts, however,
it became cumbersome to fix all the edge cases
by looking only at the final output of the inner <code>Basic</code> implementation.
The code was evidently asking for some <em>tests</em>,
if only to check how the inner structure is being&nbsp;called.</p>
<p>Shouldn&#8217;t be too hard, right?&#8230; Yeah, that&#8217;s what I thought,&nbsp;too.</p>
<p>The reality, unfortunately, fell very short of those expectations.
Stubs, mocks, fakes &#8212;
<a href="https://testing.googleblog.com/2013/07/testing-on-toilet-know-your-test-doubles.html"><em>test doubles</em></a>
in general &#8212;
are a dark and forgotten corner of Rust
that almost no one seems to pay any attention to.
Absent a proper library support &#8212; much less a language one &#8212;
the only way forward was to roll up my sleeves
and implement
<a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/src/testing/inmemory_host.rs">a fake <code>Host</code></a>
from&nbsp;scratch.</p>
<p>But that was just the beginning.
How do you seamlessly inject this fake implementation into the wrapper
so that it replaces the <code>Basic</code> struct for testing?
If you are not careful and go for the &#8220;obvious&#8221; solution &#8212; a trait&nbsp;object:</p>
<div class="highlight"><pre><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="n">Sprunge</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">inner</span><span class="o">:</span><span class="w"> </span><span class="n">Box</span><span class="o">&lt;</span><span class="n">Host</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>you&#8217;ll soon realize that you need not just a <code>Box</code>, but at least an <code>Rc</code> (or maybe even <code>Arc</code>).
Without this kind of shared ownership,
you&#8217;ll lose your chance to interrogate the test double once you hand it over to the wrapper.
This, in turn, will heavily limit your ability to write effective&nbsp;tests.</p>
<p>What&#8217;s the non-obvious approach, then?
The full rationale would probably warrant a separate post,
but the working recipe looks more or less like&nbsp;this:</p>
<ul>
<li>
<p>First, <em>parametrize</em> the wrapper with its inner type:
  <code>pub struct Sprunge&lt;T: Host&gt; { inner: T }</code>.</p>
</li>
<li>
<p>Put that in an internal module with the correct visibility&nbsp;setup:</p>
<div class="highlight"><pre><span class="kn">mod</span><span class="w"> </span><span class="n">internal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="n">Sprunge</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="n">Host</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">pub</span><span class="p">(</span><span class="n">super</span><span class="p">)</span><span class="w"> </span><span class="n">inner</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


</li>
<li>
<p>Make the regular (&#8220;production&#8221;) version of the wrapper into an <em>alias</em>,
  giving it the type parameter that you&#8217;ve been using directly<sup id="fnref:4"><a class="footnote-ref" href="#fn:4" rel="footnote">4</a></sup>:</p>
<div class="highlight"><pre><span class="k">pub</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="n">Sprunge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">internal</span><span class="o">::</span><span class="n">Sprunge</span><span class="o">&lt;</span><span class="n">Basic</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>


</li>
<li>
<p>Change the <code>new</code> constructor to instantiate the <code>internal</code> type.</p>
</li>
<li>
<p>In tests, create the wrapper with a fake <code>inner</code> object&nbsp;inside.</p>
</li>
</ul>
<p>As you can see in
<a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/src/hosts/sprunge.rs">the real example</a>,
this convoluted technique removes the need for any pointer indirection.
It also permits you to
<a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/src/hosts/sprunge.rs#L152">access the out-of-band interface</a>
that a fake object would normally&nbsp;expose.</p>
<p>It&#8217;s a shame, though, that so much work is required for something
that should be very simple.
As it appears, testing is still a neglected topic in&nbsp;Rust.</p>
<h4>Packing&nbsp;up</h4>
<p>It wasn&#8217;t just Rust that played a notable role in the development of <em>gisht</em>.</p>
<p>Pretty soon after getting the app to a presentable state,
it became clear that a mere <code>cargo build</code> won&#8217;t do everything
that&#8217;s necessary to carry out a complete build.
It <em>could</em> do more, admittedly,
if I had the foresight to explore <a href="http://doc.crates.io/build-script.html">Cargo build scripts</a>
a little more thoroughly.
But overall, I don&#8217;t regret dropping back to my trusty ol&#8217; pick:&nbsp;Python.</p>
<p>Like in a few previous projects, I used the <a href="http://pyinvoke.org">Invoke task runner</a>
for both the crucial and the auxiliary automation tasks.
It is a relatively powerful tool
&#8212; and probably the best in its class in Python that I know of &#8212;
though it can be a bit capricious if you want to
<a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/tasks/release/__init__.py#L69">really fine-tune it</a>.
But it does make it much easier to organize your automation code,
to reuse it between tasks, and to (ahem) <em>invoke</em> those tasks in a convenient&nbsp;manner.</p>
<p>In any case, it certainly beats a collection of disconnected Bash scripts&nbsp;;)</p>
<p>What have I automated in this way, you may ask?
Well, a couple of small things; those&nbsp;include:</p>
<ul>
<li>
<p>embedding of the current Git commit hash into the binary,
to help identify the exact revision in the logs of any potential bug reports<sup id="fnref:5"><a class="footnote-ref" href="#fn:5" rel="footnote">5</a></sup></p>
</li>
<li>
<p>after a successful build,
<a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/tasks/build.py#L40">replacing</a>
the <em>Usage</em> section in <em><span class="caps">README</span></em> with the program&#8217;s <code>--help</code> output</p>
</li>
<li>
<p>generating <a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/tasks/build.py#L96">completion scripts</a>
for popular shells by invoking the binary with a magic hidden flag (courtesy of <em>clap</em>)</p>
</li>
</ul>
<p>Undoubtedly the biggest task that I relegated to Python/Invoke,
was the preparation of
<a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/tasks/release/__init__.py"><em>release packages</em></a>.
When it comes to the various Linuxes (currently Debian and Red Hat flavors),
this wasn&#8217;t particularly complicated.
Major thanks are due to the amazing <a href="https://github.com/jordansissel/fpm"><em>fpm</em> tool</a> here,
which I recommend to anyone who needs to package their software in a distro-compatible&nbsp;manner.</p>
<p>Homebrew, however &#8212; or more precisely, <span class="caps">OS</span> X itself &#8212; was quite a different story.
Many, <a href="https://github.com/Xion/gisht/commits/a5423a63d10221c50faa1cb30a999a85286853a1">many</a>
failed attempts were needed to even get it to build on <a href="https://travis-ci.org">Travis</a>,
and the additional dependency on Python was
<a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/ci/travis/before_install-osx.sh#L15">partially to blame</a>.
To be fair, however, most of the pain was exclusively due to OpenSSL;
getting that thing to build is always <a href="https://github.com/sfackler/rust-openssl/issues/255">loads of &#8220;fun&#8221;</a>,
especially in such an opaque and poorly debuggable environment as&nbsp;Travis.</p>
<h4>The&nbsp;wrap</h4>
<p>There&#8217;s probably a lot of minor things and tidbits I could&#8217;ve mentioned along the way,
but the story so far has most likely covered all the important topics.
Let&#8217;s wrap it up then, and highlight some interesting points in the classic <em>Yay/Meh/Nay</em>&nbsp;manner.</p>
<h5>Yay</h5>
<ul>
<li>
<p>It was definitely a good choice to rewrite <em>gisht</em> specifically in Rust.
Besides all the advantages I&#8217;ve mentioned already,
it is also worth noting that the language went through about 10 minor version bumps
while I was working on this project.
Of all those new releases,
I don&#8217;t recall a single one that would introduce a breaking&nbsp;change.</p>
</li>
<li>
<p>Most of the Rust ecosystem (third-party libraries) was a joy to use,
and very easy to get started with.
Honorable mention goes to <em>serde_json</em> and how easy it was to
<a href="https://github.com/Xion/gisht/commit/a0655a6a5b86c05df5665e3bc7f1512f2476c9e4">transition the code</a>
from <em>rustc_serialize</em> that I had used at&nbsp;first.</p>
</li>
<li>
<p>With a possible exception of sucking in node.js as a huge dependency of your project
and using Grunt, there is probably no better way of writing automation <span class="amp">&amp;</span> support code than Python.
There may eventually be some Rust-based task runners that could try to compete,
but I&#8217;m not very convinced about using a compiled language for this purpose
(and especially one that takes so long to&nbsp;build).</p>
</li>
</ul>
<h5>Meh</h5>
<ul>
<li>
<p>While <a href="https://docs.rs/clap">the <em>clap</em> crate</a> is quite configurable and pretty straightforward to use,
it does lack at least <a href="https://github.com/kbknapp/clap-rs/issues/568">one feature</a>
that&#8217;d be very nice for <em>gisht</em>.
Additionally, working with raw <em>clap</em> is often a little tedious,
as it doesn&#8217;t assist you in translating parsed flags into your own configuration types,
and thus requires
<a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/src/args.rs#L138-L182">shuffling those bits</a>
manually<sup id="fnref:6"><a class="footnote-ref" href="#fn:6" rel="footnote">6</a></sup>.</p>
</li>
<li>
<p>Being a <em>defacto</em> standard for continuous integration in open-source projects,
<a href="https://travis-ci.org">Travis <span class="caps">CI</span></a> could be a <em>little</em> less finicky.
In almost every project I decide to use it for,
I end up with about half a dozen commits
that frantically try to fix silly configuration issues,
all before even a simple <em>.travis.yml</em> works as intended.
Providing a way to test <span class="caps">CI</span> builds locally would be an obvious way to avoid this&nbsp;churn.</p>
</li>
</ul>
<h5>Nay</h5>
<ul>
<li>
<p>Testing in Rust is such a weird animal.
On one hand, there is a first-class, out-of-the-box support for unit tests
(and even integration tests) right in the toolchain.
On the other hand, the relevant parts of the ecosystem are immature or lacking,
as evidenced by the dreary story of mocking and stubbing.
It&#8217;s no surprise that there is a long way to catch up to languages with the strongest testing culture
(Java and C#/.<span class="caps">NET</span><sup id="fnref:7"><a class="footnote-ref" href="#fn:7" rel="footnote">7</a></sup>), but it&#8217;s disappointing to see Rust outclassed
<a href="https://github.com/google/googletest">even by C++</a>.</p>
</li>
<li>
<p>Getting anything to build reliably on <span class="caps">OSX</span> in a <span class="caps">CI</span> environment is already a tall order.
But if it involves things as OpenSSL, then it quickly goes from bad to terrible.
I&#8217;m really not amused anymore how this &#8220;Just Works&#8221; system often turns out to hardly work at&nbsp;all.</p>
</li>
</ul>
<p>Since I don&#8217;t want to end on such a negative note,
I feel compelled to state the obvious fact: every technology choice is a trade-off.
In case of this project, however, the drawbacks were <em>heavily</em> outweighed by the&nbsp;benefits.</p>
<p>For this reason, I can definitely recommend the software stack I&#8217;ve just described
to anyone developing non-trivial, cross-platform command line&nbsp;tools.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>This is not an isolated complaint, by the way,
as the interpreter startup time has recently emerged as <a href="https://lwn.net/Articles/730915/">an important issue</a>
to many developers of the Python language.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Which may also include a practical <em>lack</em> thereof.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>It does handle it <a href="https://docs.rs/hyper/0.11.7/hyper/header/struct.Link.html">now</a>, fortunately.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>Observant readers may notice that we&#8217;re exposing a technically private type (<code>internal::Sprunge</code>)
through a publicly visible type alias. If that type was <em>actually</em> private,
this would trigger a compiler warning
which is slated to become <a href="https://github.com/rust-lang/rust/issues/34537">a hard error</a>
at some point in the future. But, amusingly, we can fool the compiler by making it a
<em>public type</em> inside a <em>private module</em>, which is exactly what we&#8217;re doing here.&#160;<a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:5">
<p>This has since been rewritten and is now done in
<a href="https://github.com/Xion/gisht/blob/30df960052f2a03270bbb5ca1f7be0920978007d/build.rs"><em>build.rs</em></a>
&#8212; but that&#8217;s only because I implemented
<a href="https://github.com/rust-lang/cargo/pull/3929">the relevant Cargo feature</a> myself :)&#160;<a class="footnote-backref" href="#fnref:5" rev="footnote" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:6">
<p>For an alternative approach that doesn&#8217;t seem to have this problem,
check <a href="https://docs.rs/structopt_derive">the <em>structopt</em> crate</a>.&#160;<a class="footnote-backref" href="#fnref:6" rev="footnote" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:7">
<p>Dynamically typed languages, due to their rich runtime,
are basically a class of their own when it comes to testing ease,
so it wouldn&#8217;t really be fair to hold them up for comparison.&#160;<a class="footnote-backref" href="#fnref:7" rev="footnote" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
</ol>
</div>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="http://xion.io/tag/rust.html">Rust</a>
      <a href="http://xion.io/tag/gisht.html">gisht</a>
      <a href="http://xion.io/tag/cli.html">CLI</a>
      <a href="http://xion.io/tag/github.html">GitHub</a>
      <a href="http://xion.io/tag/python.html">Python</a>
      <a href="http://xion.io/tag/testing.html">testing</a>
    </p>
  </div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'xionblog';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</article>

    <footer>
<p>
  &copy; Karol Kuczmarski 2018 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-27379564-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "Recap of the gisht project",
  "headline": "Recap of the gisht project",
  "datePublished": "2017-11-24 17:52:00+00:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "Karol Kuczmarski",
    "url": "http://xion.io/"
  },
  "image": "http://xion.io/logo.jpeg",
  "url": "http://xion.io/post/programming/gisht-recap.html",
  "description": "In this post, I want to discuss some of the experiences I had with a project that I recently finished, gisht. By “finished” I mean that I don’t anticipate developing any new major features for it, though smaller things, bug fixes, or non-code stuff, is of course still very possible. I’m thinking this is as much “done” as most software projects can ever hope to be. Thus, it is probably the best time for a recap / summary / postmortem / etc. — something to recount the lessons learned, and assess the choices made. Some context The original purpose of gisht was to facilitate download & execution of GitHub gists straight from the command line: $ gisht Xion/git-outgoing # run the https://gist.github.com/Xion/git-outgoing gist I initially wrote its first version in Python because I’ve accumulated a sizable number of small & useful scripts (for Git, Unix, Python, etc.) which were all posted as gists. Sure, I could download them manually to ~/bin every time I used a new machine but that’s rather cumbersome, and I’m quite lazy. Well, lazy and impatient :) I noticed pretty fast that the speed tax of Python is basically unacceptable for a program like gisht. What I’m referring to here is not the speed of code execution, however, but only the startup time of Python interpreter. Irrespective of the machine, operating system, or language version, it doesn’t seem to go lower than about one hundred milliseconds; empirically, it’s often 2 or 3 times higher than that. For the common case of finding a cached gist (no downloads) and doing a simple fork+exec, this startup time was very noticeable and extremely jarring. It also precluded some more sophisticated uses for gisht, like putting its invocation into the shell’s $PROMPT1. Speed: delivered And so the obvious solution emerged: let’s rewrite it in Rust!… Because if I’m executing code straight from the internet, I should at least do it in a safe language. But jokes aside, it is obvious that a language compiling to native code is likely a good pick if you want to optimize for startup speed. So while the choice of Rust was in large part educational (gisht was one of my first projects to be written in it), it definitely hasn’t disappointed there. Even without any intentional optimization efforts, the app still runs instantaneously. I tried to take some measurements using the time command, but it never ticked into more than 0.001s. Perceptively, it is at least on par with git, so that’s acceptable for me :) Can’t segfault if your code doesn’t build Achieving the performance objective wouldn’t do us much good, however, if the road to get there involved excessive penalties on productivity. Such negative impact could manifest in many ways, including troublesome debugging due to a tricky runtime2, or difficulty in getting the code to compile in the first place. If you had even a passing contact with Rust, you’d expect the latter to be much more likely than the former. Indeed, Rust’s very design eschews runtime flexibility to a ridiculous degree (in its “safe” mode, at least), while also forcing you to absorb subtle & complex ideas to even get your code past the compiler. The reward is increased likelihood your program will behave as intended — although it’s definitely not on the level of “if it compiles, it works” that can be offered by Haskell or Idris. But since gisht is hardly mission critical, I didn’t actually care too much about this increased reliability. I don’t think it’s likely that Rust would buy me much over something like modern C++. And if I were to really do some kind of cost-benefit analysis of several languages — rather than going with Rust simply to learn it better — then it would be hard to justify it over something like Go. It scales So the real question is: has Rust not hampered my productivity too much? Having the benefit of hindsight, I’m happy to say that the trade-off was definitely acceptable :) One thing I was particularly satisfied with was the language’s scalability. What I mean here is the ability to adapt as the project grows, but also to start quickly and remain nimble while the codebase is still pretty small. Many languages (most, perhaps) are naturally tailored towards the large end, doing their best to make it more bearable to work with big codebases. In turn, they often forget about helping projects take off in the first place. Between complicated build systems and dependency managers (Java), or a virtual lack of either (C++), it can be really hard to get going in a “serious” language like this. On the other hand, languages like Python make it very easy to start up and achieve relatively impressive results. Some people, however, report having encountered problems once the code evolves past certain size. While I’m actually very unsympathetic to those claims, I realize perception plays a significant role here, making those anecdotal experiences into a sort of self-fulfilling prophecy. This perception problem should almost certainly spare Rust, as it’s a natively compiled and statically typed language, with a respectable type system to boot. There is also some evidence that the language works well in large projects already. So the only question that we might want to ask is: how easy it is to actually start a project in Rust, and carry it towards some kind of MVP? Based on my experiences with gisht, I can say that it is, in fact, quite easy. Thanks mostly to the impressive Swiss army knife of cargo — acting as both package manager and a rudimentary build system — it was almost Python-trivial to cook a “Hello World” program that does something tangible, like talk to a JSON API. From there, it only took a few coding sessions to grow it into a functioning prototype. Abstractions galore As part of rewriting gisht from Python to Rust, I also wanted to fix some longstanding issues that limited its capabilities. The most important one was the hopeless coupling to GitHub and their particular flavor of gists. Sure, this is where the project even got its name from, but people use a dozen of different services to share code snippets and it should very possible to support them all. Here’s where it became necessary to utilize the abstraction capabilities that Rust has to offer. It was somewhat obvious to define a Host trait but of course its exact form had to be shaped over numerous iterations. Along the way, it even turned out that Result<Option<T>> and Option<Result<T>> are sometimes both necessary as return types :) Besides cleaner architecture, another neat thing about an explicit abstraction is the ability to slice a concept into smaller pieces — and then put some of them back together. While the Host trait could support a very diverse set of gist services and pastebins, many of them turned out to be just a slight variation of one central theme. Because of this similarity, it was possible to introduce a single Basic implementation which handles multiple services through varying sets of URL patterns. Devices like these aren’t of course specific to Rust: interfaces (traits) and classes are a staple of OO languages in general. But some other techniques were more idiomatic; the concept of iterators, for example, is flexible enough to accommodate looping over GitHub user’s gists, even as they read directly from HTTP responses. Hacking time Not everything was sunshine and rainbows, though. Take clap, for example. It’s mostly a very good crate for parsing command line arguments, but it couldn’t quite cope with the unusual requirements that gisht had. To make gisht Foo/bar work alongside gisht run Foo/bar, it was necessary to analyze argv before even handing it over to clap. This turned out to be surprisingly tricky to get right. Like, really tricky, with edges cases and stuff. But as it is often the case in software, the answer turned out to be yet another layer of indirection plus a copious amount of tests. In another instance, however, a direct library support was crucial. It so happened that hyper, the crate I’ve been using for HTTP requests, didn’t handle the Link: response header out of the box3. This was a stumbling block that prevented the gist iterator (mentioned earlier) from correctly handling pagination in the responses from GitHub API. Thankfully, having the Header abstraction in hyper meant it was possible to add the missing support in a relatively straighforward manner. Yes, it’s not a universal implementation that’d be suitable for every HTTP client, but it does the job for gisht just fine. Test-Reluctant Development And so the program kept growing steadily over the months, most notably through more and more gist hosts it could now support. Eventually, some of them would fall into a sort of twilight zone. They weren’t as complicated as GitHub to warrant writing a completely new Host instance, but they also couldn’t be handled via the Basic structure alone. A good example would be sprunge.us: mostly an ordinary pastebin, except for its optional syntax highlighting which may add some “junk” to the otherwise regular URLs. In order to handle those odd cases, I went for a classic wrapper/decorator pattern which, in its essence, boils down to something like this: pub struct Sprunge { inner: Basic, } impl Sprunge { pub fn new() -> { Sprunge{inner: Basic::new(ID, "sprunge.us", "http://sprunge.us/${id}", ...)} } } impl Host for Sprunge { // override & wrap methods that require custom logic: fn resolve_url(&self, url: &str) -> Option<io::Result<Gist>> { let mut url_obj = try_opt!(Url::parse(url).ok()); url_obj.set_query(None); inner.resolve_url(url_obj.to_string().as_str()) } // passthrough to the `Basic` struct for others: fn fetch_gist(&self, gist: &Gist, mode: FetchMode) -> io::Result<()> { self.inner.fetch_gist(gist, mode) } // (etc.) } Despite the noticeable boilerplate of a few pass-through methods, I was pretty happy with this solution, at least initially. After a few more unusual hosts, however, it became cumbersome to fix all the edge cases by looking only at the final output of the inner Basic implementation. The code was evidently asking for some tests, if only to check how the inner structure is being called. Shouldn’t be too hard, right?… Yeah, that’s what I thought, too. The reality, unfortunately, fell very short of those expectations. Stubs, mocks, fakes — test doubles in general — are a dark and forgotten corner of Rust that almost no one seems to pay any attention to. Absent a proper library support — much less a language one — the only way forward was to roll up my sleeves and implement a fake Host from scratch. But that was just the beginning. How do you seamlessly inject this fake implementation into the wrapper so that it replaces the Basic struct for testing? If you are not careful and go for the “obvious” solution — a trait object: pub struct Sprunge { inner: Box<Host>, } you’ll soon realize that you need not just a Box, but at least an Rc (or maybe even Arc). Without this kind of shared ownership, you’ll lose your chance to interrogate the test double once you hand it over to the wrapper. This, in turn, will heavily limit your ability to write effective tests. What’s the non-obvious approach, then? The full rationale would probably warrant a separate post, but the working recipe looks more or less like this: First, parametrize the wrapper with its inner type: pub struct Sprunge<T: Host> { inner: T }. Put that in an internal module with the correct visibility setup: mod internal { pub struct Sprunge<T: Host> { pub(super) inner: T, } } Make the regular (“production”) version of the wrapper into an alias, giving it the type parameter that you’ve been using directly4: pub type Sprunge = internal::Sprunge<Basic>; Change the new constructor to instantiate the internal type. In tests, create the wrapper with a fake inner object inside. As you can see in the real example, this convoluted technique removes the need for any pointer indirection. It also permits you to access the out-of-band interface that a fake object would normally expose. It’s a shame, though, that so much work is required for something that should be very simple. As it appears, testing is still a neglected topic in Rust. Packing up It wasn’t just Rust that played a notable role in the development of gisht. Pretty soon after getting the app to a presentable state, it became clear that a mere cargo build won’t do everything that’s necessary to carry out a complete build. It could do more, admittedly, if I had the foresight to explore Cargo build scripts a little more thoroughly. But overall, I don’t regret dropping back to my trusty ol’ pick: Python. Like in a few previous projects, I used the Invoke task runner for both the crucial and the auxiliary automation tasks. It is a relatively powerful tool — and probably the best in its class in Python that I know of — though it can be a bit capricious if you want to really fine-tune it. But it does make it much easier to organize your automation code, to reuse it between tasks, and to (ahem) invoke those tasks in a convenient manner. In any case, it certainly beats a collection of disconnected Bash scripts ;) What have I automated in this way, you may ask? Well, a couple of small things; those include: embedding of the current Git commit hash into the binary, to help identify the exact revision in the logs of any potential bug reports5 after a successful build, replacing the Usage section in README with the program’s --help output generating completion scripts for popular shells by invoking the binary with a magic hidden flag (courtesy of clap) Undoubtedly the biggest task that I relegated to Python/Invoke, was the preparation of release packages. When it comes to the various Linuxes (currently Debian and Red Hat flavors), this wasn’t particularly complicated. Major thanks are due to the amazing fpm tool here, which I recommend to anyone who needs to package their software in a distro-compatible manner. Homebrew, however — or more precisely, OS X itself — was quite a different story. Many, many failed attempts were needed to even get it to build on Travis, and the additional dependency on Python was partially to blame. To be fair, however, most of the pain was exclusively due to OpenSSL; getting that thing to build is always loads of “fun”, especially in such an opaque and poorly debuggable environment as Travis. The wrap There’s probably a lot of minor things and tidbits I could’ve mentioned along the way, but the story so far has most likely covered all the important topics. Let’s wrap it up then, and highlight some interesting points in the classic Yay/Meh/Nay manner. Yay It was definitely a good choice to rewrite gisht specifically in Rust. Besides all the advantages I’ve mentioned already, it is also worth noting that the language went through about 10 minor version bumps while I was working on this project. Of all those new releases, I don’t recall a single one that would introduce a breaking change. Most of the Rust ecosystem (third-party libraries) was a joy to use, and very easy to get started with. Honorable mention goes to serde_json and how easy it was to transition the code from rustc_serialize that I had used at first. With a possible exception of sucking in node.js as a huge dependency of your project and using Grunt, there is probably no better way of writing automation & support code than Python. There may eventually be some Rust-based task runners that could try to compete, but I’m not very convinced about using a compiled language for this purpose (and especially one that takes so long to build). Meh While the clap crate is quite configurable and pretty straightforward to use, it does lack at least one feature that’d be very nice for gisht. Additionally, working with raw clap is often a little tedious, as it doesn’t assist you in translating parsed flags into your own configuration types, and thus requires shuffling those bits manually6. Being a defacto standard for continuous integration in open-source projects, Travis CI could be a little less finicky. In almost every project I decide to use it for, I end up with about half a dozen commits that frantically try to fix silly configuration issues, all before even a simple .travis.yml works as intended. Providing a way to test CI builds locally would be an obvious way to avoid this churn. Nay Testing in Rust is such a weird animal. On one hand, there is a first-class, out-of-the-box support for unit tests (and even integration tests) right in the toolchain. On the other hand, the relevant parts of the ecosystem are immature or lacking, as evidenced by the dreary story of mocking and stubbing. It’s no surprise that there is a long way to catch up to languages with the strongest testing culture (Java and C#/.NET7), but it’s disappointing to see Rust outclassed even by C++. Getting anything to build reliably on OSX in a CI environment is already a tall order. But if it involves things as OpenSSL, then it quickly goes from bad to terrible. I’m really not amused anymore how this “Just Works” system often turns out to hardly work at all. Since I don’t want to end on such a negative note, I feel compelled to state the obvious fact: every technology choice is a trade-off. In case of this project, however, the drawbacks were heavily outweighed by the benefits. For this reason, I can definitely recommend the software stack I’ve just described to anyone developing non-trivial, cross-platform command line tools. This is not an isolated complaint, by the way, as the interpreter startup time has recently emerged as an important issue to many developers of the Python language. ↩ Which may also include a practical lack thereof. ↩ It does handle it now, fortunately. ↩ Observant readers may notice that we’re exposing a technically private type (internal::Sprunge) through a publicly visible type alias. If that type was actually private, this would trigger a compiler warning which is slated to become a hard error at some point in the future. But, amusingly, we can fool the compiler by making it a public type inside a private module, which is exactly what we’re doing here. ↩ This has since been rewritten and is now done in build.rs — but that’s only because I implemented the relevant Cargo feature myself :) ↩ For an alternative approach that doesn’t seem to have this problem, check the structopt crate. ↩ Dynamically typed languages, due to their rich runtime, are basically a class of their own when it comes to testing ease, so it wouldn’t really be fair to hold them up for comparison. ↩"
}
</script></body>
</html>